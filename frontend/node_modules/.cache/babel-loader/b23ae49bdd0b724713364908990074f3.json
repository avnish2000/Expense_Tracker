{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Shape } from \"./shape\";\nimport { Path } from \"./path\";\nimport { BBox } from \"../bbox\";\nimport { normalizeAngle360 } from \"../../util/angle\";\nimport { chainObjects } from \"../../util/object\";\nimport { isEqual } from \"../../util/number\";\nexport var ArcType;\n\n(function (ArcType) {\n  ArcType[ArcType[\"Open\"] = 0] = \"Open\";\n  ArcType[ArcType[\"Chord\"] = 1] = \"Chord\";\n  ArcType[ArcType[\"Round\"] = 2] = \"Round\";\n})(ArcType || (ArcType = {}));\n/**\n * Elliptical arc node.\n */\n\n\nvar Arc =\n/** @class */\nfunction (_super) {\n  __extends(Arc, _super);\n\n  function Arc() {\n    var _this = _super.call(this) || this;\n\n    _this._centerX = 0;\n    _this._centerY = 0;\n    _this._radiusX = 10;\n    _this._radiusY = 10;\n    _this._startAngle = 0;\n    _this._endAngle = Math.PI * 2;\n    _this._counterClockwise = false;\n    /**\n     * The type of arc to render:\n     * - {@link ArcType.Open} - end points of the arc segment are not connected (default)\n     * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment\n     * - {@link ArcType.Round} - each of the end points of the arc segment are connected\n     *                           to the center of the arc\n     * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their\n     * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support\n     * would require using two paths - one for rendering, another for hit testing - and there\n     * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}\n     * to create a closed path.\n     */\n\n    _this._type = ArcType.Open;\n\n    _this.restoreOwnStyles();\n\n    return _this;\n  }\n\n  Object.defineProperty(Arc.prototype, \"centerX\", {\n    get: function () {\n      return this._centerX;\n    },\n    set: function (value) {\n      if (this._centerX !== value) {\n        this._centerX = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"centerY\", {\n    get: function () {\n      return this._centerY;\n    },\n    set: function (value) {\n      if (this._centerY !== value) {\n        this._centerY = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"radiusX\", {\n    get: function () {\n      return this._radiusX;\n    },\n    set: function (value) {\n      if (this._radiusX !== value) {\n        this._radiusX = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"radiusY\", {\n    get: function () {\n      return this._radiusY;\n    },\n    set: function (value) {\n      if (this._radiusY !== value) {\n        this._radiusY = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"startAngle\", {\n    get: function () {\n      return this._startAngle;\n    },\n    set: function (value) {\n      if (this._startAngle !== value) {\n        this._startAngle = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"endAngle\", {\n    get: function () {\n      return this._endAngle;\n    },\n    set: function (value) {\n      if (this._endAngle !== value) {\n        this._endAngle = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"fullPie\", {\n    get: function () {\n      return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"counterClockwise\", {\n    get: function () {\n      return this._counterClockwise;\n    },\n    set: function (value) {\n      if (this._counterClockwise !== value) {\n        this._counterClockwise = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Arc.prototype, \"type\", {\n    get: function () {\n      return this._type;\n    },\n    set: function (value) {\n      if (this._type !== value) {\n        this._type = value;\n        this.dirtyPath = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Arc.prototype.updatePath = function () {\n    var path = this.path;\n    path.clear(); // No need to recreate the Path, can simply clear the existing one.\n    // This is much faster than the native Path2D implementation even though this `cubicArc`\n    // method is pure TypeScript and actually produces the definition of an elliptical arc,\n    // where you can specify two radii and rotation, while Path2D's `arc` method simply produces\n    // a circular arc. Maybe it's due to the experimental nature of the Path2D class,\n    // maybe it's because we have to create a new instance of it on each render, who knows...\n\n    path.cubicArc(this.centerX, this.centerY, this.radiusX, this.radiusY, 0, this.startAngle, this.endAngle, this.counterClockwise ? 1 : 0);\n\n    if (this.type === ArcType.Chord) {\n      path.closePath();\n    } else if (this.type === ArcType.Round && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  };\n\n  Arc.prototype.computeBBox = function () {\n    // Only works with full arcs (circles) and untransformed ellipses.\n    return new BBox(this.centerX - this.radiusX, this.centerY - this.radiusY, this.radiusX * 2, this.radiusY * 2);\n  };\n\n  Arc.prototype.isPointInPath = function (x, y) {\n    var point = this.transformPoint(x, y);\n    var bbox = this.computeBBox();\n    return this.type !== ArcType.Open && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);\n  };\n\n  Arc.className = 'Arc';\n  Arc.defaultStyles = chainObjects(Shape.defaultStyles, {\n    lineWidth: 1,\n    fillStyle: null\n  });\n  return Arc;\n}(Path);\n\nexport { Arc };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/shape/arc.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Shape","Path","BBox","normalizeAngle360","chainObjects","isEqual","ArcType","Arc","_super","_this","call","_centerX","_centerY","_radiusX","_radiusY","_startAngle","_endAngle","Math","PI","_counterClockwise","_type","Open","restoreOwnStyles","defineProperty","get","set","value","dirtyPath","enumerable","configurable","startAngle","endAngle","updatePath","path","clear","cubicArc","centerX","centerY","radiusX","radiusY","counterClockwise","type","Chord","closePath","Round","fullPie","lineTo","computeBBox","isPointInPath","x","y","point","transformPoint","bbox","containsPoint","className","defaultStyles","lineWidth","fillStyle"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Shape } from \"./shape\";\nimport { Path } from \"./path\";\nimport { BBox } from \"../bbox\";\nimport { normalizeAngle360 } from \"../../util/angle\";\nimport { chainObjects } from \"../../util/object\";\nimport { isEqual } from \"../../util/number\";\nexport var ArcType;\n(function (ArcType) {\n    ArcType[ArcType[\"Open\"] = 0] = \"Open\";\n    ArcType[ArcType[\"Chord\"] = 1] = \"Chord\";\n    ArcType[ArcType[\"Round\"] = 2] = \"Round\";\n})(ArcType || (ArcType = {}));\n/**\n * Elliptical arc node.\n */\nvar Arc = /** @class */ (function (_super) {\n    __extends(Arc, _super);\n    function Arc() {\n        var _this = _super.call(this) || this;\n        _this._centerX = 0;\n        _this._centerY = 0;\n        _this._radiusX = 10;\n        _this._radiusY = 10;\n        _this._startAngle = 0;\n        _this._endAngle = Math.PI * 2;\n        _this._counterClockwise = false;\n        /**\n         * The type of arc to render:\n         * - {@link ArcType.Open} - end points of the arc segment are not connected (default)\n         * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment\n         * - {@link ArcType.Round} - each of the end points of the arc segment are connected\n         *                           to the center of the arc\n         * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their\n         * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support\n         * would require using two paths - one for rendering, another for hit testing - and there\n         * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}\n         * to create a closed path.\n         */\n        _this._type = ArcType.Open;\n        _this.restoreOwnStyles();\n        return _this;\n    }\n    Object.defineProperty(Arc.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (value) {\n            if (this._centerX !== value) {\n                this._centerX = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (value) {\n            if (this._centerY !== value) {\n                this._centerY = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"radiusX\", {\n        get: function () {\n            return this._radiusX;\n        },\n        set: function (value) {\n            if (this._radiusX !== value) {\n                this._radiusX = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"radiusY\", {\n        get: function () {\n            return this._radiusY;\n        },\n        set: function (value) {\n            if (this._radiusY !== value) {\n                this._radiusY = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"startAngle\", {\n        get: function () {\n            return this._startAngle;\n        },\n        set: function (value) {\n            if (this._startAngle !== value) {\n                this._startAngle = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"endAngle\", {\n        get: function () {\n            return this._endAngle;\n        },\n        set: function (value) {\n            if (this._endAngle !== value) {\n                this._endAngle = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"fullPie\", {\n        get: function () {\n            return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"counterClockwise\", {\n        get: function () {\n            return this._counterClockwise;\n        },\n        set: function (value) {\n            if (this._counterClockwise !== value) {\n                this._counterClockwise = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"type\", {\n        get: function () {\n            return this._type;\n        },\n        set: function (value) {\n            if (this._type !== value) {\n                this._type = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Arc.prototype.updatePath = function () {\n        var path = this.path;\n        path.clear(); // No need to recreate the Path, can simply clear the existing one.\n        // This is much faster than the native Path2D implementation even though this `cubicArc`\n        // method is pure TypeScript and actually produces the definition of an elliptical arc,\n        // where you can specify two radii and rotation, while Path2D's `arc` method simply produces\n        // a circular arc. Maybe it's due to the experimental nature of the Path2D class,\n        // maybe it's because we have to create a new instance of it on each render, who knows...\n        path.cubicArc(this.centerX, this.centerY, this.radiusX, this.radiusY, 0, this.startAngle, this.endAngle, this.counterClockwise ? 1 : 0);\n        if (this.type === ArcType.Chord) {\n            path.closePath();\n        }\n        else if (this.type === ArcType.Round && !this.fullPie) {\n            path.lineTo(this.centerX, this.centerY);\n            path.closePath();\n        }\n    };\n    Arc.prototype.computeBBox = function () {\n        // Only works with full arcs (circles) and untransformed ellipses.\n        return new BBox(this.centerX - this.radiusX, this.centerY - this.radiusY, this.radiusX * 2, this.radiusY * 2);\n    };\n    Arc.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return this.type !== ArcType.Open\n            && bbox.containsPoint(point.x, point.y)\n            && this.path.isPointInPath(point.x, point.y);\n    };\n    Arc.className = 'Arc';\n    Arc.defaultStyles = chainObjects(Shape.defaultStyles, {\n        lineWidth: 1,\n        fillStyle: null\n    });\n    return Arc;\n}(Path));\nexport { Arc };\n"]},"metadata":{},"sourceType":"module"}