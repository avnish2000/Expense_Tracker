{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { Group } from \"../../scene/group\";\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\";\n// import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\nimport { createId } from \"../../util/id\";\nvar GroupedCategoryAxisLabel = /** @class */function (_super) {\n  __extends(GroupedCategoryAxisLabel, _super);\n  function GroupedCategoryAxisLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.grid = false;\n    return _this;\n  }\n  return GroupedCategoryAxisLabel;\n}(AxisLabel);\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar GroupedCategoryAxis = /** @class */function (_super) {\n  __extends(GroupedCategoryAxis, _super);\n  function GroupedCategoryAxis() {\n    var _this = _super.call(this, new BandScale()) || this;\n    _this.id = createId(_this);\n    _this.tickScale = new BandScale();\n    _this.group = new Group();\n    _this.longestSeparatorLength = 0;\n    _this.translation = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Axis rotation angle in degrees.\n     */\n    _this.rotation = 0;\n    _this.line = {\n      width: 1,\n      color: 'rgba(195, 195, 195, 1)'\n    };\n    // readonly tick = new AxisTick();\n    _this.label = new GroupedCategoryAxisLabel();\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n    _this.labelColor = 'rgba(87, 87, 87, 1)';\n    var _a = _this,\n      group = _a.group,\n      scale = _a.scale,\n      tickScale = _a.tickScale;\n    scale.paddingOuter = 0.1;\n    scale.paddingInner = scale.paddingOuter * 2;\n    _this.requestedRange = scale.range.slice();\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    _this.gridLineSelection = Selection.select(group).selectAll();\n    _this.axisLineSelection = Selection.select(group).selectAll();\n    _this.separatorSelection = Selection.select(group).selectAll();\n    _this.labelSelection = Selection.select(group).selectAll();\n    return _this;\n    // this.group.append(this.bboxRect); // debug (bbox)\n  }\n\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n    get: function () {\n      return this.scale.domain;\n    },\n    set: function (value) {\n      this.scale.domain = value;\n      var tickTree = ticksToTree(value);\n      this.tickTreeLayout = treeLayout(tickTree);\n      var domain = value.slice();\n      domain.push('');\n      this.tickScale.domain = domain;\n      this.resizeTickTree();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n    get: function () {\n      return this.requestedRange.slice();\n    },\n    set: function (value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  GroupedCategoryAxis.prototype.updateRange = function () {\n    var _a = this,\n      rr = _a.requestedRange,\n      vr = _a.visibleRange,\n      scale = _a.scale;\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    this.tickScale.range = scale.range = [start, start + span];\n    this.resizeTickTree();\n  };\n  GroupedCategoryAxis.prototype.resizeTickTree = function () {\n    var s = this.scale;\n    var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    var layout = this.tickTreeLayout;\n    var lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\n    }\n  };\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n    get: function () {\n      return this.label.fontSize * 1.5;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n    get: function () {\n      return this._gridLength;\n    },\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     */\n    set: function (value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n        this.labelSelection = this.labelSelection.remove().setData([]);\n      }\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  GroupedCategoryAxis.prototype.update = function () {\n    var _this = this;\n    var _a = this,\n      group = _a.group,\n      scale = _a.scale,\n      label = _a.label,\n      tickScale = _a.tickScale,\n      requestedRange = _a.requestedRange;\n    var rangeStart = scale.range[0];\n    var rangeEnd = scale.range[1];\n    var rangeLength = Math.abs(rangeEnd - rangeStart);\n    var bandwidth = rangeLength / scale.domain.length || 0;\n    var parallelLabels = label.parallel;\n    var rotation = toRadians(this.rotation);\n    var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n    group.translationX = this.translation.x;\n    group.translationY = this.translation.y;\n    group.rotation = rotation;\n    var title = this.title;\n    // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n    // The phantom root of the tree layout is used instead.\n    if (title) {\n      title.node.visible = false;\n    }\n    var lineHeight = this.lineHeight;\n    // Render ticks and labels.\n    var tickTreeLayout = this.tickTreeLayout;\n    var labels = scale.ticks();\n    var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    var ticks = tickScale.ticks();\n    // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n    var sideFlag = label.mirrored ? 1 : -1;\n    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, Ï€] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    // Flip if the axis rotation angle is in the top hemisphere.\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n    updateGridLines.exit.remove();\n    var enterGridLines = updateGridLines.enter.append(Line);\n    var gridLineSelection = updateGridLines.merge(enterGridLines);\n    var updateLabels = this.labelSelection.setData(treeLabels);\n    updateLabels.exit.remove();\n    var enterLabels = updateLabels.enter.append(Text);\n    var labelSelection = updateLabels.merge(enterLabels);\n    var labelFormatter = label.formatter;\n    var maxLeafLabelWidth = 0;\n    labelSelection.each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n      // label.textBaseline = parallelLabels && !labelRotation\n      //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n      //     : 'middle';\n      node.textAlign = 'center';\n      node.translationX = datum.screenY - label.fontSize * 0.25;\n      node.translationY = datum.screenX;\n      if (index === 0) {\n        // use the phantom root as the axis title\n        if (title && title.enabled && labels.length > 0) {\n          node.visible = true;\n          node.text = title.text;\n          node.fontSize = title.fontSize;\n          node.fontStyle = title.fontStyle;\n          node.fontWeight = title.fontWeight;\n          node.fontFamily = title.fontFamily;\n          node.textBaseline = 'hanging';\n        } else {\n          node.visible = false;\n        }\n      } else {\n        node.text = labelFormatter ? labelFormatter({\n          value: String(datum.label),\n          index: index\n        }) : String(datum.label);\n        node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];\n      }\n      var bbox = node.computeBBox();\n      if (bbox && bbox.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox.width;\n      }\n    });\n    var labelX = sideFlag * label.padding;\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    var labelGrid = this.label.grid;\n    var separatorData = [];\n    labelSelection.each(function (label, datum, index) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n      if (!datum.children.length) {\n        label.rotation = labelRotation;\n        label.textAlign = 'end';\n        label.textBaseline = 'middle';\n      } else {\n        label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n        if (isHorizontal) {\n          label.rotation = autoRotation;\n        } else {\n          label.rotation = -Math.PI / 2;\n        }\n      }\n      // Calculate positions of label separators for all nodes except the root.\n      // Each separator is placed to the top of the current label.\n      if (datum.parent && isLabelTree) {\n        var y = !datum.children.length ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (!datum.children.length) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y: y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - _this.label.padding * 2,\n              toString: function () {\n                return String(index);\n              }\n            });\n          }\n        } else {\n          var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y: y,\n            x1: x + lineHeight,\n            x2: x,\n            toString: function () {\n              return String(index);\n            }\n          });\n        }\n      }\n    });\n    // Calculate the position of the long separator on the far bottom of the axis.\n    var minX = 0;\n    separatorData.forEach(function (d) {\n      return minX = Math.min(minX, d.x2);\n    });\n    this.longestSeparatorLength = Math.abs(minX);\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX,\n      toString: function () {\n        return String(separatorData.length);\n      }\n    });\n    var updateSeparators = this.separatorSelection.setData(separatorData);\n    updateSeparators.exit.remove();\n    var enterSeparators = updateSeparators.enter.append(Line);\n    var separatorSelection = updateSeparators.merge(enterSeparators);\n    this.separatorSelection = separatorSelection;\n    var epsilon = 0.0000001;\n    separatorSelection.each(function (line, datum, i) {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n      line.stroke = _this.tick.color;\n      line.fill = undefined;\n      line.strokeWidth = 1;\n    });\n    this.gridLineSelection = gridLineSelection;\n    this.labelSelection = labelSelection;\n    // Render axis lines.\n    var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    var lines = [];\n    for (var i = 0; i < lineCount; i++) {\n      lines.push(i);\n    }\n    var updateAxisLines = this.axisLineSelection.setData(lines);\n    updateAxisLines.exit.remove();\n    var enterAxisLines = updateAxisLines.enter.append(Line);\n    var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n    this.axisLineSelection = axisLineSelection;\n    axisLineSelection.each(function (line, _, index) {\n      var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n      line.x1 = x;\n      line.x2 = x;\n      line.y1 = requestedRange[0];\n      line.y2 = requestedRange[1];\n      line.strokeWidth = _this.line.width;\n      line.stroke = _this.line.color;\n      line.visible = labels.length > 0 && (index === 0 || labelGrid && isLabelTree);\n    });\n    if (this.gridLength) {\n      var styles_1 = this.gridStyle;\n      var styleCount_1 = styles_1.length;\n      gridLineSelection.each(function (line, datum, index) {\n        var y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * _this.gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = y >= requestedRange[0] && y <= requestedRange[1] && Math.abs(line.parent.translationY - rangeStart) > 1;\n        var style = styles_1[index % styleCount_1];\n        line.stroke = style.stroke;\n        line.strokeWidth = _this.tick.width;\n        line.lineDash = style.lineDash;\n        line.fill = undefined;\n      });\n    }\n    // debug (bbox)\n    // const bbox = this.computeBBox();\n    // const bboxRect = this.bboxRect;\n    // bboxRect.x = bbox.x;\n    // bboxRect.y = bbox.y;\n    // bboxRect.width = bbox.width;\n    // bboxRect.height = bbox.height;\n  };\n\n  GroupedCategoryAxis.prototype.computeBBox = function (options) {\n    var includeTitle = !options || !options.excludeTitle;\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    this.labelSelection.each(function (label, _, index) {\n      // The label itself is rotated, but not translated, the group that\n      // contains it is. So to capture the group transform in the label bbox\n      // calculation we combine the transform matrices of the label and the group.\n      // Depending on the timing of the `axis.computeBBox()` method call, we may\n      // not have the group's and the label's transform matrices updated yet (because\n      // the transform matrix is not recalculated whenever a node's transform attributes\n      // change, instead it's marked for recalculation on the next frame by setting\n      // the node's `dirtyTransform` flag to `true`), so we force them to update\n      // right here by calling `computeTransformMatrix`.\n      if (index > 0 || includeTitle) {\n        // first node is the root (title)\n        label.computeTransformMatrix();\n        var matrix = Matrix.flyweight(label.matrix);\n        var labelBBox = label.computeBBox();\n        if (labelBBox) {\n          var bbox = matrix.transformBBox(labelBBox);\n          left = Math.min(left, bbox.x);\n          right = Math.max(right, bbox.x + bbox.width);\n          top = Math.min(top, bbox.y);\n          bottom = Math.max(bottom, bbox.y + bbox.height);\n        }\n      }\n    });\n    return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n  };\n  // debug (bbox)\n  // private bboxRect = (() => {\n  //     const rect = new Rect();\n  //     rect.fill = undefined;\n  //     rect.stroke = 'red';\n  //     rect.strokeWidth = 1;\n  //     rect.strokeOpacity = 0.7;\n  //     return rect;\n  // })();\n  GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n  GroupedCategoryAxis.type = 'groupedCategory';\n  return GroupedCategoryAxis;\n}(ChartAxis);\nexport { GroupedCategoryAxis };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Group","Selection","Line","normalizeAngle360","toRadians","Text","BBox","Matrix","BandScale","ticksToTree","treeLayout","AxisLabel","ChartAxis","createId","GroupedCategoryAxisLabel","_super","_this","apply","arguments","grid","GroupedCategoryAxis","call","id","tickScale","group","longestSeparatorLength","translation","x","y","rotation","line","width","color","label","labelColor","_a","scale","paddingOuter","paddingInner","requestedRange","range","slice","gridLineSelection","select","selectAll","axisLineSelection","separatorSelection","labelSelection","defineProperty","get","domain","set","value","tickTree","tickTreeLayout","push","resizeTickTree","enumerable","configurable","updateRange","rr","vr","visibleRange","span","shift","start","s","length","convert","layout","lineHeight","resize","Math","abs","depth","min","bandwidth","fontSize","_gridLength","remove","setData","update","rangeStart","rangeEnd","rangeLength","parallelLabels","parallel","isHorizontal","cos","labelRotation","translationX","translationY","title","node","visible","labels","ticks","treeLabels","nodes","isLabelTree","sideFlag","mirrored","parallelFlipRotation","parallelFlipFlag","PI","regularFlipRotation","regularFlipFlag","updateGridLines","gridLength","exit","enterGridLines","enter","append","merge","updateLabels","enterLabels","labelFormatter","formatter","maxLeafLabelWidth","each","datum","index","fontStyle","fontWeight","fontFamily","fill","textBaseline","textAlign","screenY","screenX","enabled","text","String","bbox","computeBBox","labelX","padding","autoRotation","labelGrid","separatorData","rotationCenterX","children","parent","leafCount","number","x1","x2","toString","minX","forEach","max","updateSeparators","enterSeparators","epsilon","i","y1","y2","stroke","tick","undefined","strokeWidth","lineCount","lines","updateAxisLines","enterAxisLines","_","styles_1","gridStyle","styleCount_1","round","style","lineDash","options","includeTitle","excludeTitle","left","Infinity","right","top","bottom","computeTransformMatrix","matrix","flyweight","labelBBox","transformBBox","height","className","type"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/chart/axis/groupedCategoryAxis.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Group } from \"../../scene/group\";\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\";\n// import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\nimport { createId } from \"../../util/id\";\nvar GroupedCategoryAxisLabel = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxisLabel, _super);\n    function GroupedCategoryAxisLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.grid = false;\n        return _this;\n    }\n    return GroupedCategoryAxisLabel;\n}(AxisLabel));\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar GroupedCategoryAxis = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxis, _super);\n    function GroupedCategoryAxis() {\n        var _this = _super.call(this, new BandScale()) || this;\n        _this.id = createId(_this);\n        _this.tickScale = new BandScale();\n        _this.group = new Group();\n        _this.longestSeparatorLength = 0;\n        _this.translation = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * Axis rotation angle in degrees.\n         */\n        _this.rotation = 0;\n        _this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        // readonly tick = new AxisTick();\n        _this.label = new GroupedCategoryAxisLabel();\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        _this.labelColor = 'rgba(87, 87, 87, 1)';\n        var _a = _this, group = _a.group, scale = _a.scale, tickScale = _a.tickScale;\n        scale.paddingOuter = 0.1;\n        scale.paddingInner = scale.paddingOuter * 2;\n        _this.requestedRange = scale.range.slice();\n        tickScale.paddingInner = 1;\n        tickScale.paddingOuter = 0;\n        _this.gridLineSelection = Selection.select(group).selectAll();\n        _this.axisLineSelection = Selection.select(group).selectAll();\n        _this.separatorSelection = Selection.select(group).selectAll();\n        _this.labelSelection = Selection.select(group).selectAll();\n        return _this;\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain;\n        },\n        set: function (value) {\n            this.scale.domain = value;\n            var tickTree = ticksToTree(value);\n            this.tickTreeLayout = treeLayout(tickTree);\n            var domain = value.slice();\n            domain.push('');\n            this.tickScale.domain = domain;\n            this.resizeTickTree();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GroupedCategoryAxis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        this.tickScale.range = scale.range = [start, start + span];\n        this.resizeTickTree();\n    };\n    GroupedCategoryAxis.prototype.resizeTickTree = function () {\n        var s = this.scale;\n        var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n        var layout = this.tickTreeLayout;\n        var lineHeight = this.lineHeight;\n        if (layout) {\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, (range[1] - range[0]) < 0);\n        }\n    };\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n        get: function () {\n            return this.label.fontSize * 1.5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         */\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n                this.labelSelection = this.labelSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    GroupedCategoryAxis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, label = _a.label, tickScale = _a.tickScale, requestedRange = _a.requestedRange;\n        var rangeStart = scale.range[0];\n        var rangeEnd = scale.range[1];\n        var rangeLength = Math.abs(rangeEnd - rangeStart);\n        var bandwidth = (rangeLength / scale.domain.length) || 0;\n        var parallelLabels = label.parallel;\n        var rotation = toRadians(this.rotation);\n        var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n        var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var title = this.title;\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n        // The phantom root of the tree layout is used instead.\n        if (title) {\n            title.node.visible = false;\n        }\n        var lineHeight = this.lineHeight;\n        // Render ticks and labels.\n        var tickTreeLayout = this.tickTreeLayout;\n        var labels = scale.ticks();\n        var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n        var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n        var ticks = tickScale.ticks();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, Ï€] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = (!labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI) ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = (!labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI) ? -1 : 1;\n        var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n        updateGridLines.exit.remove();\n        var enterGridLines = updateGridLines.enter.append(Line);\n        var gridLineSelection = updateGridLines.merge(enterGridLines);\n        var updateLabels = this.labelSelection.setData(treeLabels);\n        updateLabels.exit.remove();\n        var enterLabels = updateLabels.enter.append(Text);\n        var labelSelection = updateLabels.merge(enterLabels);\n        var labelFormatter = label.formatter;\n        var maxLeafLabelWidth = 0;\n        labelSelection\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n            // label.textBaseline = parallelLabels && !labelRotation\n            //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n            //     : 'middle';\n            node.textAlign = 'center';\n            node.translationX = datum.screenY - label.fontSize * 0.25;\n            node.translationY = datum.screenX;\n            if (index === 0) { // use the phantom root as the axis title\n                if (title && title.enabled && labels.length > 0) {\n                    node.visible = true;\n                    node.text = title.text;\n                    node.fontSize = title.fontSize;\n                    node.fontStyle = title.fontStyle;\n                    node.fontWeight = title.fontWeight;\n                    node.fontFamily = title.fontFamily;\n                    node.textBaseline = 'hanging';\n                }\n                else {\n                    node.visible = false;\n                }\n            }\n            else {\n                node.text = labelFormatter\n                    ? labelFormatter({\n                        value: String(datum.label),\n                        index: index\n                    })\n                    : String(datum.label);\n                node.visible =\n                    datum.screenX >= requestedRange[0] &&\n                        datum.screenX <= requestedRange[1];\n            }\n            var bbox = node.computeBBox();\n            if (bbox && bbox.width > maxLeafLabelWidth) {\n                maxLeafLabelWidth = bbox.width;\n            }\n        });\n        var labelX = sideFlag * label.padding;\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        var labelGrid = this.label.grid;\n        var separatorData = [];\n        labelSelection.each(function (label, datum, index) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            if (!datum.children.length) {\n                label.rotation = labelRotation;\n                label.textAlign = 'end';\n                label.textBaseline = 'middle';\n            }\n            else {\n                label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n                if (isHorizontal) {\n                    label.rotation = autoRotation;\n                }\n                else {\n                    label.rotation = -Math.PI / 2;\n                }\n            }\n            // Calculate positions of label separators for all nodes except the root.\n            // Each separator is placed to the top of the current label.\n            if (datum.parent && isLabelTree) {\n                var y = !datum.children.length\n                    ? datum.screenX - bandwidth / 2\n                    : datum.screenX - datum.leafCount * bandwidth / 2;\n                if (!datum.children.length) {\n                    if ((datum.number !== datum.children.length - 1) || labelGrid) {\n                        separatorData.push({\n                            y: y,\n                            x1: 0,\n                            x2: -maxLeafLabelWidth - _this.label.padding * 2,\n                            toString: function () { return String(index); }\n                        });\n                    }\n                }\n                else {\n                    var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n                    separatorData.push({\n                        y: y,\n                        x1: x + lineHeight,\n                        x2: x,\n                        toString: function () { return String(index); }\n                    });\n                }\n            }\n        });\n        // Calculate the position of the long separator on the far bottom of the axis.\n        var minX = 0;\n        separatorData.forEach(function (d) { return minX = Math.min(minX, d.x2); });\n        this.longestSeparatorLength = Math.abs(minX);\n        separatorData.push({\n            y: Math.max(rangeStart, rangeEnd),\n            x1: 0,\n            x2: minX,\n            toString: function () { return String(separatorData.length); }\n        });\n        var updateSeparators = this.separatorSelection.setData(separatorData);\n        updateSeparators.exit.remove();\n        var enterSeparators = updateSeparators.enter.append(Line);\n        var separatorSelection = updateSeparators.merge(enterSeparators);\n        this.separatorSelection = separatorSelection;\n        var epsilon = 0.0000001;\n        separatorSelection.each(function (line, datum, i) {\n            line.x1 = datum.x1;\n            line.x2 = datum.x2;\n            line.y1 = datum.y;\n            line.y2 = datum.y;\n            line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n            line.stroke = _this.tick.color;\n            line.fill = undefined;\n            line.strokeWidth = 1;\n        });\n        this.gridLineSelection = gridLineSelection;\n        this.labelSelection = labelSelection;\n        // Render axis lines.\n        var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n        var lines = [];\n        for (var i = 0; i < lineCount; i++) {\n            lines.push(i);\n        }\n        var updateAxisLines = this.axisLineSelection.setData(lines);\n        updateAxisLines.exit.remove();\n        var enterAxisLines = updateAxisLines.enter.append(Line);\n        var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n        this.axisLineSelection = axisLineSelection;\n        axisLineSelection.each(function (line, _, index) {\n            var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n            line.x1 = x;\n            line.x2 = x;\n            line.y1 = requestedRange[0];\n            line.y2 = requestedRange[1];\n            line.strokeWidth = _this.line.width;\n            line.stroke = _this.line.color;\n            line.visible = labels.length > 0 && (index === 0 || (labelGrid && isLabelTree));\n        });\n        if (this.gridLength) {\n            var styles_1 = this.gridStyle;\n            var styleCount_1 = styles_1.length;\n            gridLineSelection\n                .each(function (line, datum, index) {\n                var y = Math.round(tickScale.convert(datum));\n                line.x1 = 0;\n                line.x2 = -sideFlag * _this.gridLength;\n                line.y1 = y;\n                line.y2 = y;\n                line.visible = y >= requestedRange[0] && y <= requestedRange[1] &&\n                    Math.abs(line.parent.translationY - rangeStart) > 1;\n                var style = styles_1[index % styleCount_1];\n                line.stroke = style.stroke;\n                line.strokeWidth = _this.tick.width;\n                line.lineDash = style.lineDash;\n                line.fill = undefined;\n            });\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    GroupedCategoryAxis.prototype.computeBBox = function (options) {\n        var includeTitle = !options || !options.excludeTitle;\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        this.labelSelection.each(function (label, _, index) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            if (index > 0 || includeTitle) { // first node is the root (title)\n                label.computeTransformMatrix();\n                var matrix = Matrix.flyweight(label.matrix);\n                var labelBBox = label.computeBBox();\n                if (labelBBox) {\n                    var bbox = matrix.transformBBox(labelBBox);\n                    left = Math.min(left, bbox.x);\n                    right = Math.max(right, bbox.x + bbox.width);\n                    top = Math.min(top, bbox.y);\n                    bottom = Math.max(bottom, bbox.y + bbox.height);\n                }\n            }\n        });\n        return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n    };\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.7;\n    //     return rect;\n    // })();\n    GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n    GroupedCategoryAxis.type = 'groupedCategory';\n    return GroupedCategoryAxis;\n}(ChartAxis));\nexport { GroupedCategoryAxis };\n"],"mappings":"AAAA,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,aAAa,GAAG,UAAUC,CAAC,EAAEC,CAAC,EAAE;IAChCF,aAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;MAAEC,SAAS,EAAE;IAAG,CAAC,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;MAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;IAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;MAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC,EAAE,IAAIA,CAAC,CAACM,cAAc,CAACD,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IAAE,CAAC;IAC9E,OAAOP,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC9B,CAAC;EACD,OAAO,UAAUD,CAAC,EAAEC,CAAC,EAAE;IACnBF,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASO,EAAE,GAAG;MAAE,IAAI,CAACC,WAAW,GAAGT,CAAC;IAAE;IACtCA,CAAC,CAACU,SAAS,GAAGT,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACS,MAAM,CAACV,CAAC,CAAC,IAAIO,EAAE,CAACE,SAAS,GAAGT,CAAC,CAACS,SAAS,EAAE,IAAIF,EAAE,EAAE,CAAC;EACxF,CAAC;AACL,CAAC,EAAG;AACJ,SAASI,KAAK,QAAQ,mBAAmB;AACzC,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,IAAI,QAAQ,wBAAwB;AAC7C,SAASC,iBAAiB,EAAEC,SAAS,QAAQ,kBAAkB;AAC/D,SAASC,IAAI,QAAQ,wBAAwB;AAC7C,SAASC,IAAI,QAAQ,kBAAkB;AACvC,SAASC,MAAM,QAAQ,oBAAoB;AAC3C;AACA,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,WAAW,EAAEC,UAAU,QAAQ,mBAAmB;AAC3D,SAASC,SAAS,QAAQ,YAAY;AACtC,SAASC,SAAS,QAAQ,cAAc;AACxC,SAASC,QAAQ,QAAQ,eAAe;AACxC,IAAIC,wBAAwB,GAAG,aAAe,UAAUC,MAAM,EAAE;EAC5D7B,SAAS,CAAC4B,wBAAwB,EAAEC,MAAM,CAAC;EAC3C,SAASD,wBAAwB,GAAG;IAChC,IAAIE,KAAK,GAAGD,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,IAAI,IAAI;IACpEF,KAAK,CAACG,IAAI,GAAG,KAAK;IAClB,OAAOH,KAAK;EAChB;EACA,OAAOF,wBAAwB;AACnC,CAAC,CAACH,SAAS,CAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIS,mBAAmB,GAAG,aAAe,UAAUL,MAAM,EAAE;EACvD7B,SAAS,CAACkC,mBAAmB,EAAEL,MAAM,CAAC;EACtC,SAASK,mBAAmB,GAAG;IAC3B,IAAIJ,KAAK,GAAGD,MAAM,CAACM,IAAI,CAAC,IAAI,EAAE,IAAIb,SAAS,EAAE,CAAC,IAAI,IAAI;IACtDQ,KAAK,CAACM,EAAE,GAAGT,QAAQ,CAACG,KAAK,CAAC;IAC1BA,KAAK,CAACO,SAAS,GAAG,IAAIf,SAAS,EAAE;IACjCQ,KAAK,CAACQ,KAAK,GAAG,IAAIxB,KAAK,EAAE;IACzBgB,KAAK,CAACS,sBAAsB,GAAG,CAAC;IAChCT,KAAK,CAACU,WAAW,GAAG;MAChBC,CAAC,EAAE,CAAC;MACJC,CAAC,EAAE;IACP,CAAC;IACD;AACR;AACA;IACQZ,KAAK,CAACa,QAAQ,GAAG,CAAC;IAClBb,KAAK,CAACc,IAAI,GAAG;MACTC,KAAK,EAAE,CAAC;MACRC,KAAK,EAAE;IACX,CAAC;IACD;IACAhB,KAAK,CAACiB,KAAK,GAAG,IAAInB,wBAAwB,EAAE;IAC5C;AACR;AACA;AACA;IACQE,KAAK,CAACkB,UAAU,GAAG,qBAAqB;IACxC,IAAIC,EAAE,GAAGnB,KAAK;MAAEQ,KAAK,GAAGW,EAAE,CAACX,KAAK;MAAEY,KAAK,GAAGD,EAAE,CAACC,KAAK;MAAEb,SAAS,GAAGY,EAAE,CAACZ,SAAS;IAC5Ea,KAAK,CAACC,YAAY,GAAG,GAAG;IACxBD,KAAK,CAACE,YAAY,GAAGF,KAAK,CAACC,YAAY,GAAG,CAAC;IAC3CrB,KAAK,CAACuB,cAAc,GAAGH,KAAK,CAACI,KAAK,CAACC,KAAK,EAAE;IAC1ClB,SAAS,CAACe,YAAY,GAAG,CAAC;IAC1Bf,SAAS,CAACc,YAAY,GAAG,CAAC;IAC1BrB,KAAK,CAAC0B,iBAAiB,GAAGzC,SAAS,CAAC0C,MAAM,CAACnB,KAAK,CAAC,CAACoB,SAAS,EAAE;IAC7D5B,KAAK,CAAC6B,iBAAiB,GAAG5C,SAAS,CAAC0C,MAAM,CAACnB,KAAK,CAAC,CAACoB,SAAS,EAAE;IAC7D5B,KAAK,CAAC8B,kBAAkB,GAAG7C,SAAS,CAAC0C,MAAM,CAACnB,KAAK,CAAC,CAACoB,SAAS,EAAE;IAC9D5B,KAAK,CAAC+B,cAAc,GAAG9C,SAAS,CAAC0C,MAAM,CAACnB,KAAK,CAAC,CAACoB,SAAS,EAAE;IAC1D,OAAO5B,KAAK;IACZ;EACJ;;EACA1B,MAAM,CAAC0D,cAAc,CAAC5B,mBAAmB,CAACtB,SAAS,EAAE,QAAQ,EAAE;IAC3DmD,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAACb,KAAK,CAACc,MAAM;IAC5B,CAAC;IACDC,GAAG,EAAE,UAAUC,KAAK,EAAE;MAClB,IAAI,CAAChB,KAAK,CAACc,MAAM,GAAGE,KAAK;MACzB,IAAIC,QAAQ,GAAG5C,WAAW,CAAC2C,KAAK,CAAC;MACjC,IAAI,CAACE,cAAc,GAAG5C,UAAU,CAAC2C,QAAQ,CAAC;MAC1C,IAAIH,MAAM,GAAGE,KAAK,CAACX,KAAK,EAAE;MAC1BS,MAAM,CAACK,IAAI,CAAC,EAAE,CAAC;MACf,IAAI,CAAChC,SAAS,CAAC2B,MAAM,GAAGA,MAAM;MAC9B,IAAI,CAACM,cAAc,EAAE;IACzB,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFpE,MAAM,CAAC0D,cAAc,CAAC5B,mBAAmB,CAACtB,SAAS,EAAE,OAAO,EAAE;IAC1DmD,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAACV,cAAc,CAACE,KAAK,EAAE;IACtC,CAAC;IACDU,GAAG,EAAE,UAAUC,KAAK,EAAE;MAClB,IAAI,CAACb,cAAc,GAAGa,KAAK,CAACX,KAAK,EAAE;MACnC,IAAI,CAACkB,WAAW,EAAE;IACtB,CAAC;IACDF,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFtC,mBAAmB,CAACtB,SAAS,CAAC6D,WAAW,GAAG,YAAY;IACpD,IAAIxB,EAAE,GAAG,IAAI;MAAEyB,EAAE,GAAGzB,EAAE,CAACI,cAAc;MAAEsB,EAAE,GAAG1B,EAAE,CAAC2B,YAAY;MAAE1B,KAAK,GAAGD,EAAE,CAACC,KAAK;IAC7E,IAAI2B,IAAI,GAAG,CAACH,EAAE,CAAC,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,KAAKC,EAAE,CAAC,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC;IAC5C,IAAIG,KAAK,GAAGD,IAAI,GAAGF,EAAE,CAAC,CAAC,CAAC;IACxB,IAAII,KAAK,GAAGL,EAAE,CAAC,CAAC,CAAC,GAAGI,KAAK;IACzB,IAAI,CAACzC,SAAS,CAACiB,KAAK,GAAGJ,KAAK,CAACI,KAAK,GAAG,CAACyB,KAAK,EAAEA,KAAK,GAAGF,IAAI,CAAC;IAC1D,IAAI,CAACP,cAAc,EAAE;EACzB,CAAC;EACDpC,mBAAmB,CAACtB,SAAS,CAAC0D,cAAc,GAAG,YAAY;IACvD,IAAIU,CAAC,GAAG,IAAI,CAAC9B,KAAK;IAClB,IAAII,KAAK,GAAG0B,CAAC,CAAChB,MAAM,CAACiB,MAAM,GAAG,CAACD,CAAC,CAACE,OAAO,CAACF,CAAC,CAAChB,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEgB,CAAC,CAACE,OAAO,CAACF,CAAC,CAAChB,MAAM,CAACgB,CAAC,CAAChB,MAAM,CAACiB,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGD,CAAC,CAAC1B,KAAK;IAC1G,IAAI6B,MAAM,GAAG,IAAI,CAACf,cAAc;IAChC,IAAIgB,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAID,MAAM,EAAE;MACRA,MAAM,CAACE,MAAM,CAACC,IAAI,CAACC,GAAG,CAACjC,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE6B,MAAM,CAACK,KAAK,GAAGJ,UAAU,EAAE,CAACE,IAAI,CAACG,GAAG,CAACnC,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC0B,CAAC,CAACU,SAAS,IAAI,CAAC,IAAI,CAAC,EAAE,CAACP,MAAM,CAACK,KAAK,GAAGJ,UAAU,EAAG9B,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAI,CAAC,CAAC;IAChM;EACJ,CAAC;EACDlD,MAAM,CAAC0D,cAAc,CAAC5B,mBAAmB,CAACtB,SAAS,EAAE,YAAY,EAAE;IAC/DmD,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAAChB,KAAK,CAAC4C,QAAQ,GAAG,GAAG;IACpC,CAAC;IACDpB,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFpE,MAAM,CAAC0D,cAAc,CAAC5B,mBAAmB,CAACtB,SAAS,EAAE,YAAY,EAAE;IAC/DmD,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAAC6B,WAAW;IAC3B,CAAC;IACD;AACR;AACA;IACQ3B,GAAG,EAAE,UAAUC,KAAK,EAAE;MAClB;MACA,IAAI,IAAI,CAAC0B,WAAW,IAAI,CAAC1B,KAAK,IAAI,CAAC,IAAI,CAAC0B,WAAW,IAAI1B,KAAK,EAAE;QAC1D,IAAI,CAACV,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACqC,MAAM,EAAE,CAACC,OAAO,CAAC,EAAE,CAAC;QACpE,IAAI,CAACjC,cAAc,GAAG,IAAI,CAACA,cAAc,CAACgC,MAAM,EAAE,CAACC,OAAO,CAAC,EAAE,CAAC;MAClE;MACA,IAAI,CAACF,WAAW,GAAG1B,KAAK;IAC5B,CAAC;IACDK,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACItC,mBAAmB,CAACtB,SAAS,CAACmF,MAAM,GAAG,YAAY;IAC/C,IAAIjE,KAAK,GAAG,IAAI;IAChB,IAAImB,EAAE,GAAG,IAAI;MAAEX,KAAK,GAAGW,EAAE,CAACX,KAAK;MAAEY,KAAK,GAAGD,EAAE,CAACC,KAAK;MAAEH,KAAK,GAAGE,EAAE,CAACF,KAAK;MAAEV,SAAS,GAAGY,EAAE,CAACZ,SAAS;MAAEgB,cAAc,GAAGJ,EAAE,CAACI,cAAc;IACjI,IAAI2C,UAAU,GAAG9C,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC;IAC/B,IAAI2C,QAAQ,GAAG/C,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAI4C,WAAW,GAAGZ,IAAI,CAACC,GAAG,CAACU,QAAQ,GAAGD,UAAU,CAAC;IACjD,IAAIN,SAAS,GAAIQ,WAAW,GAAGhD,KAAK,CAACc,MAAM,CAACiB,MAAM,IAAK,CAAC;IACxD,IAAIkB,cAAc,GAAGpD,KAAK,CAACqD,QAAQ;IACnC,IAAIzD,QAAQ,GAAGzB,SAAS,CAAC,IAAI,CAACyB,QAAQ,CAAC;IACvC,IAAI0D,YAAY,GAAGf,IAAI,CAACC,GAAG,CAACD,IAAI,CAACgB,GAAG,CAAC3D,QAAQ,CAAC,CAAC,GAAG,IAAI;IACtD,IAAI4D,aAAa,GAAGtF,iBAAiB,CAACC,SAAS,CAAC,IAAI,CAAC6B,KAAK,CAACJ,QAAQ,CAAC,CAAC;IACrEL,KAAK,CAACkE,YAAY,GAAG,IAAI,CAAChE,WAAW,CAACC,CAAC;IACvCH,KAAK,CAACmE,YAAY,GAAG,IAAI,CAACjE,WAAW,CAACE,CAAC;IACvCJ,KAAK,CAACK,QAAQ,GAAGA,QAAQ;IACzB,IAAI+D,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB;IACA;IACA,IAAIA,KAAK,EAAE;MACPA,KAAK,CAACC,IAAI,CAACC,OAAO,GAAG,KAAK;IAC9B;IACA,IAAIxB,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC;IACA,IAAIhB,cAAc,GAAG,IAAI,CAACA,cAAc;IACxC,IAAIyC,MAAM,GAAG3D,KAAK,CAAC4D,KAAK,EAAE;IAC1B,IAAIC,UAAU,GAAG3C,cAAc,GAAGA,cAAc,CAAC4C,KAAK,GAAG,EAAE;IAC3D,IAAIC,WAAW,GAAG7C,cAAc,GAAGA,cAAc,CAACoB,KAAK,GAAG,CAAC,GAAG,KAAK;IACnE,IAAIsB,KAAK,GAAGzE,SAAS,CAACyE,KAAK,EAAE;IAC7B;IACA;IACA;IACA,IAAII,QAAQ,GAAGnE,KAAK,CAACoE,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;IACtC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,oBAAoB,GAAGnG,iBAAiB,CAAC0B,QAAQ,CAAC;IACtD,IAAI0E,gBAAgB,GAAI,CAACd,aAAa,IAAIa,oBAAoB,IAAI,CAAC,IAAIA,oBAAoB,IAAI9B,IAAI,CAACgC,EAAE,GAAI,CAAC,CAAC,GAAG,CAAC;IAChH,IAAIC,mBAAmB,GAAGtG,iBAAiB,CAAC0B,QAAQ,GAAG2C,IAAI,CAACgC,EAAE,GAAG,CAAC,CAAC;IACnE;IACA,IAAIE,eAAe,GAAI,CAACjB,aAAa,IAAIgB,mBAAmB,IAAI,CAAC,IAAIA,mBAAmB,IAAIjC,IAAI,CAACgC,EAAE,GAAI,CAAC,CAAC,GAAG,CAAC;IAC7G,IAAIG,eAAe,GAAG,IAAI,CAACjE,iBAAiB,CAACsC,OAAO,CAAC,IAAI,CAAC4B,UAAU,GAAGZ,KAAK,GAAG,EAAE,CAAC;IAClFW,eAAe,CAACE,IAAI,CAAC9B,MAAM,EAAE;IAC7B,IAAI+B,cAAc,GAAGH,eAAe,CAACI,KAAK,CAACC,MAAM,CAAC9G,IAAI,CAAC;IACvD,IAAIwC,iBAAiB,GAAGiE,eAAe,CAACM,KAAK,CAACH,cAAc,CAAC;IAC7D,IAAII,YAAY,GAAG,IAAI,CAACnE,cAAc,CAACiC,OAAO,CAACiB,UAAU,CAAC;IAC1DiB,YAAY,CAACL,IAAI,CAAC9B,MAAM,EAAE;IAC1B,IAAIoC,WAAW,GAAGD,YAAY,CAACH,KAAK,CAACC,MAAM,CAAC3G,IAAI,CAAC;IACjD,IAAI0C,cAAc,GAAGmE,YAAY,CAACD,KAAK,CAACE,WAAW,CAAC;IACpD,IAAIC,cAAc,GAAGnF,KAAK,CAACoF,SAAS;IACpC,IAAIC,iBAAiB,GAAG,CAAC;IACzBvE,cAAc,CACTwE,IAAI,CAAC,UAAU1B,IAAI,EAAE2B,KAAK,EAAEC,KAAK,EAAE;MACpC5B,IAAI,CAAC6B,SAAS,GAAGzF,KAAK,CAACyF,SAAS;MAChC7B,IAAI,CAAC8B,UAAU,GAAG1F,KAAK,CAAC0F,UAAU;MAClC9B,IAAI,CAAChB,QAAQ,GAAG5C,KAAK,CAAC4C,QAAQ;MAC9BgB,IAAI,CAAC+B,UAAU,GAAG3F,KAAK,CAAC2F,UAAU;MAClC/B,IAAI,CAACgC,IAAI,GAAG5F,KAAK,CAACD,KAAK;MACvB6D,IAAI,CAACiC,YAAY,GAAGvB,gBAAgB,KAAK,CAAC,CAAC,GAAG,QAAQ,GAAG,SAAS;MAClE;MACA;MACA;MACAV,IAAI,CAACkC,SAAS,GAAG,QAAQ;MACzBlC,IAAI,CAACH,YAAY,GAAG8B,KAAK,CAACQ,OAAO,GAAG/F,KAAK,CAAC4C,QAAQ,GAAG,IAAI;MACzDgB,IAAI,CAACF,YAAY,GAAG6B,KAAK,CAACS,OAAO;MACjC,IAAIR,KAAK,KAAK,CAAC,EAAE;QAAE;QACf,IAAI7B,KAAK,IAAIA,KAAK,CAACsC,OAAO,IAAInC,MAAM,CAAC5B,MAAM,GAAG,CAAC,EAAE;UAC7C0B,IAAI,CAACC,OAAO,GAAG,IAAI;UACnBD,IAAI,CAACsC,IAAI,GAAGvC,KAAK,CAACuC,IAAI;UACtBtC,IAAI,CAAChB,QAAQ,GAAGe,KAAK,CAACf,QAAQ;UAC9BgB,IAAI,CAAC6B,SAAS,GAAG9B,KAAK,CAAC8B,SAAS;UAChC7B,IAAI,CAAC8B,UAAU,GAAG/B,KAAK,CAAC+B,UAAU;UAClC9B,IAAI,CAAC+B,UAAU,GAAGhC,KAAK,CAACgC,UAAU;UAClC/B,IAAI,CAACiC,YAAY,GAAG,SAAS;QACjC,CAAC,MACI;UACDjC,IAAI,CAACC,OAAO,GAAG,KAAK;QACxB;MACJ,CAAC,MACI;QACDD,IAAI,CAACsC,IAAI,GAAGf,cAAc,GACpBA,cAAc,CAAC;UACbhE,KAAK,EAAEgF,MAAM,CAACZ,KAAK,CAACvF,KAAK,CAAC;UAC1BwF,KAAK,EAAEA;QACX,CAAC,CAAC,GACAW,MAAM,CAACZ,KAAK,CAACvF,KAAK,CAAC;QACzB4D,IAAI,CAACC,OAAO,GACR0B,KAAK,CAACS,OAAO,IAAI1F,cAAc,CAAC,CAAC,CAAC,IAC9BiF,KAAK,CAACS,OAAO,IAAI1F,cAAc,CAAC,CAAC,CAAC;MAC9C;MACA,IAAI8F,IAAI,GAAGxC,IAAI,CAACyC,WAAW,EAAE;MAC7B,IAAID,IAAI,IAAIA,IAAI,CAACtG,KAAK,GAAGuF,iBAAiB,EAAE;QACxCA,iBAAiB,GAAGe,IAAI,CAACtG,KAAK;MAClC;IACJ,CAAC,CAAC;IACF,IAAIwG,MAAM,GAAGnC,QAAQ,GAAGnE,KAAK,CAACuG,OAAO;IACrC,IAAIC,YAAY,GAAGpD,cAAc,GAC3BkB,gBAAgB,GAAG/B,IAAI,CAACgC,EAAE,GAAG,CAAC,GAC7BE,eAAe,KAAK,CAAC,CAAC,GAAGlC,IAAI,CAACgC,EAAE,GAAG,CAAE;IAC5C,IAAIkC,SAAS,GAAG,IAAI,CAACzG,KAAK,CAACd,IAAI;IAC/B,IAAIwH,aAAa,GAAG,EAAE;IACtB5F,cAAc,CAACwE,IAAI,CAAC,UAAUtF,KAAK,EAAEuF,KAAK,EAAEC,KAAK,EAAE;MAC/CxF,KAAK,CAACN,CAAC,GAAG4G,MAAM;MAChBtG,KAAK,CAAC2G,eAAe,GAAGL,MAAM;MAC9B,IAAI,CAACf,KAAK,CAACqB,QAAQ,CAAC1E,MAAM,EAAE;QACxBlC,KAAK,CAACJ,QAAQ,GAAG4D,aAAa;QAC9BxD,KAAK,CAAC8F,SAAS,GAAG,KAAK;QACvB9F,KAAK,CAAC6F,YAAY,GAAG,QAAQ;MACjC,CAAC,MACI;QACD7F,KAAK,CAACyD,YAAY,IAAI4B,iBAAiB,GAAGhD,UAAU,GAAGtD,KAAK,CAACiB,KAAK,CAACuG,OAAO;QAC1E,IAAIjD,YAAY,EAAE;UACdtD,KAAK,CAACJ,QAAQ,GAAG4G,YAAY;QACjC,CAAC,MACI;UACDxG,KAAK,CAACJ,QAAQ,GAAG,CAAC2C,IAAI,CAACgC,EAAE,GAAG,CAAC;QACjC;MACJ;MACA;MACA;MACA,IAAIgB,KAAK,CAACsB,MAAM,IAAI3C,WAAW,EAAE;QAC7B,IAAIvE,CAAC,GAAG,CAAC4F,KAAK,CAACqB,QAAQ,CAAC1E,MAAM,GACxBqD,KAAK,CAACS,OAAO,GAAGrD,SAAS,GAAG,CAAC,GAC7B4C,KAAK,CAACS,OAAO,GAAGT,KAAK,CAACuB,SAAS,GAAGnE,SAAS,GAAG,CAAC;QACrD,IAAI,CAAC4C,KAAK,CAACqB,QAAQ,CAAC1E,MAAM,EAAE;UACxB,IAAKqD,KAAK,CAACwB,MAAM,KAAKxB,KAAK,CAACqB,QAAQ,CAAC1E,MAAM,GAAG,CAAC,IAAKuE,SAAS,EAAE;YAC3DC,aAAa,CAACpF,IAAI,CAAC;cACf3B,CAAC,EAAEA,CAAC;cACJqH,EAAE,EAAE,CAAC;cACLC,EAAE,EAAE,CAAC5B,iBAAiB,GAAGtG,KAAK,CAACiB,KAAK,CAACuG,OAAO,GAAG,CAAC;cAChDW,QAAQ,EAAE,YAAY;gBAAE,OAAOf,MAAM,CAACX,KAAK,CAAC;cAAE;YAClD,CAAC,CAAC;UACN;QACJ,CAAC,MACI;UACD,IAAI9F,CAAC,GAAG,CAAC2F,iBAAiB,GAAGtG,KAAK,CAACiB,KAAK,CAACuG,OAAO,GAAG,CAAC,GAAGhB,KAAK,CAACQ,OAAO;UACpEW,aAAa,CAACpF,IAAI,CAAC;YACf3B,CAAC,EAAEA,CAAC;YACJqH,EAAE,EAAEtH,CAAC,GAAG2C,UAAU;YAClB4E,EAAE,EAAEvH,CAAC;YACLwH,QAAQ,EAAE,YAAY;cAAE,OAAOf,MAAM,CAACX,KAAK,CAAC;YAAE;UAClD,CAAC,CAAC;QACN;MACJ;IACJ,CAAC,CAAC;IACF;IACA,IAAI2B,IAAI,GAAG,CAAC;IACZT,aAAa,CAACU,OAAO,CAAC,UAAUjK,CAAC,EAAE;MAAE,OAAOgK,IAAI,GAAG5E,IAAI,CAACG,GAAG,CAACyE,IAAI,EAAEhK,CAAC,CAAC8J,EAAE,CAAC;IAAE,CAAC,CAAC;IAC3E,IAAI,CAACzH,sBAAsB,GAAG+C,IAAI,CAACC,GAAG,CAAC2E,IAAI,CAAC;IAC5CT,aAAa,CAACpF,IAAI,CAAC;MACf3B,CAAC,EAAE4C,IAAI,CAAC8E,GAAG,CAACpE,UAAU,EAAEC,QAAQ,CAAC;MACjC8D,EAAE,EAAE,CAAC;MACLC,EAAE,EAAEE,IAAI;MACRD,QAAQ,EAAE,YAAY;QAAE,OAAOf,MAAM,CAACO,aAAa,CAACxE,MAAM,CAAC;MAAE;IACjE,CAAC,CAAC;IACF,IAAIoF,gBAAgB,GAAG,IAAI,CAACzG,kBAAkB,CAACkC,OAAO,CAAC2D,aAAa,CAAC;IACrEY,gBAAgB,CAAC1C,IAAI,CAAC9B,MAAM,EAAE;IAC9B,IAAIyE,eAAe,GAAGD,gBAAgB,CAACxC,KAAK,CAACC,MAAM,CAAC9G,IAAI,CAAC;IACzD,IAAI4C,kBAAkB,GAAGyG,gBAAgB,CAACtC,KAAK,CAACuC,eAAe,CAAC;IAChE,IAAI,CAAC1G,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI2G,OAAO,GAAG,SAAS;IACvB3G,kBAAkB,CAACyE,IAAI,CAAC,UAAUzF,IAAI,EAAE0F,KAAK,EAAEkC,CAAC,EAAE;MAC9C5H,IAAI,CAACmH,EAAE,GAAGzB,KAAK,CAACyB,EAAE;MAClBnH,IAAI,CAACoH,EAAE,GAAG1B,KAAK,CAAC0B,EAAE;MAClBpH,IAAI,CAAC6H,EAAE,GAAGnC,KAAK,CAAC5F,CAAC;MACjBE,IAAI,CAAC8H,EAAE,GAAGpC,KAAK,CAAC5F,CAAC;MACjBE,IAAI,CAACgE,OAAO,GAAG0B,KAAK,CAAC5F,CAAC,IAAIW,cAAc,CAAC,CAAC,CAAC,GAAGkH,OAAO,IAAIjC,KAAK,CAAC5F,CAAC,IAAIW,cAAc,CAAC,CAAC,CAAC,GAAGkH,OAAO;MAC/F3H,IAAI,CAAC+H,MAAM,GAAG7I,KAAK,CAAC8I,IAAI,CAAC9H,KAAK;MAC9BF,IAAI,CAAC+F,IAAI,GAAGkC,SAAS;MACrBjI,IAAI,CAACkI,WAAW,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,IAAI,CAACtH,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACK,cAAc,GAAGA,cAAc;IACpC;IACA,IAAIkH,SAAS,GAAG3G,cAAc,GAAGA,cAAc,CAACoB,KAAK,GAAG,CAAC,GAAG,CAAC;IAC7D,IAAIwF,KAAK,GAAG,EAAE;IACd,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,SAAS,EAAEP,CAAC,EAAE,EAAE;MAChCQ,KAAK,CAAC3G,IAAI,CAACmG,CAAC,CAAC;IACjB;IACA,IAAIS,eAAe,GAAG,IAAI,CAACtH,iBAAiB,CAACmC,OAAO,CAACkF,KAAK,CAAC;IAC3DC,eAAe,CAACtD,IAAI,CAAC9B,MAAM,EAAE;IAC7B,IAAIqF,cAAc,GAAGD,eAAe,CAACpD,KAAK,CAACC,MAAM,CAAC9G,IAAI,CAAC;IACvD,IAAI2C,iBAAiB,GAAGsH,eAAe,CAAClD,KAAK,CAACmD,cAAc,CAAC;IAC7D,IAAI,CAACvH,iBAAiB,GAAGA,iBAAiB;IAC1CA,iBAAiB,CAAC0E,IAAI,CAAC,UAAUzF,IAAI,EAAEuI,CAAC,EAAE5C,KAAK,EAAE;MAC7C,IAAI9F,CAAC,GAAG8F,KAAK,GAAG,CAAC,GAAG,CAACH,iBAAiB,GAAGtG,KAAK,CAACiB,KAAK,CAACuG,OAAO,GAAG,CAAC,GAAG,CAACf,KAAK,GAAG,CAAC,IAAInD,UAAU,GAAG,CAAC;MAC/FxC,IAAI,CAACmH,EAAE,GAAGtH,CAAC;MACXG,IAAI,CAACoH,EAAE,GAAGvH,CAAC;MACXG,IAAI,CAAC6H,EAAE,GAAGpH,cAAc,CAAC,CAAC,CAAC;MAC3BT,IAAI,CAAC8H,EAAE,GAAGrH,cAAc,CAAC,CAAC,CAAC;MAC3BT,IAAI,CAACkI,WAAW,GAAGhJ,KAAK,CAACc,IAAI,CAACC,KAAK;MACnCD,IAAI,CAAC+H,MAAM,GAAG7I,KAAK,CAACc,IAAI,CAACE,KAAK;MAC9BF,IAAI,CAACgE,OAAO,GAAGC,MAAM,CAAC5B,MAAM,GAAG,CAAC,KAAKsD,KAAK,KAAK,CAAC,IAAKiB,SAAS,IAAIvC,WAAY,CAAC;IACnF,CAAC,CAAC;IACF,IAAI,IAAI,CAACS,UAAU,EAAE;MACjB,IAAI0D,QAAQ,GAAG,IAAI,CAACC,SAAS;MAC7B,IAAIC,YAAY,GAAGF,QAAQ,CAACnG,MAAM;MAClCzB,iBAAiB,CACZ6E,IAAI,CAAC,UAAUzF,IAAI,EAAE0F,KAAK,EAAEC,KAAK,EAAE;QACpC,IAAI7F,CAAC,GAAG4C,IAAI,CAACiG,KAAK,CAAClJ,SAAS,CAAC6C,OAAO,CAACoD,KAAK,CAAC,CAAC;QAC5C1F,IAAI,CAACmH,EAAE,GAAG,CAAC;QACXnH,IAAI,CAACoH,EAAE,GAAG,CAAC9C,QAAQ,GAAGpF,KAAK,CAAC4F,UAAU;QACtC9E,IAAI,CAAC6H,EAAE,GAAG/H,CAAC;QACXE,IAAI,CAAC8H,EAAE,GAAGhI,CAAC;QACXE,IAAI,CAACgE,OAAO,GAAGlE,CAAC,IAAIW,cAAc,CAAC,CAAC,CAAC,IAAIX,CAAC,IAAIW,cAAc,CAAC,CAAC,CAAC,IAC3DiC,IAAI,CAACC,GAAG,CAAC3C,IAAI,CAACgH,MAAM,CAACnD,YAAY,GAAGT,UAAU,CAAC,GAAG,CAAC;QACvD,IAAIwF,KAAK,GAAGJ,QAAQ,CAAC7C,KAAK,GAAG+C,YAAY,CAAC;QAC1C1I,IAAI,CAAC+H,MAAM,GAAGa,KAAK,CAACb,MAAM;QAC1B/H,IAAI,CAACkI,WAAW,GAAGhJ,KAAK,CAAC8I,IAAI,CAAC/H,KAAK;QACnCD,IAAI,CAAC6I,QAAQ,GAAGD,KAAK,CAACC,QAAQ;QAC9B7I,IAAI,CAAC+F,IAAI,GAAGkC,SAAS;MACzB,CAAC,CAAC;IACN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACJ,CAAC;;EACD3I,mBAAmB,CAACtB,SAAS,CAACwI,WAAW,GAAG,UAAUsC,OAAO,EAAE;IAC3D,IAAIC,YAAY,GAAG,CAACD,OAAO,IAAI,CAACA,OAAO,CAACE,YAAY;IACpD,IAAIC,IAAI,GAAGC,QAAQ;IACnB,IAAIC,KAAK,GAAG,CAACD,QAAQ;IACrB,IAAIE,GAAG,GAAGF,QAAQ;IAClB,IAAIG,MAAM,GAAG,CAACH,QAAQ;IACtB,IAAI,CAACjI,cAAc,CAACwE,IAAI,CAAC,UAAUtF,KAAK,EAAEoI,CAAC,EAAE5C,KAAK,EAAE;MAChD;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIA,KAAK,GAAG,CAAC,IAAIoD,YAAY,EAAE;QAAE;QAC7B5I,KAAK,CAACmJ,sBAAsB,EAAE;QAC9B,IAAIC,MAAM,GAAG9K,MAAM,CAAC+K,SAAS,CAACrJ,KAAK,CAACoJ,MAAM,CAAC;QAC3C,IAAIE,SAAS,GAAGtJ,KAAK,CAACqG,WAAW,EAAE;QACnC,IAAIiD,SAAS,EAAE;UACX,IAAIlD,IAAI,GAAGgD,MAAM,CAACG,aAAa,CAACD,SAAS,CAAC;UAC1CR,IAAI,GAAGvG,IAAI,CAACG,GAAG,CAACoG,IAAI,EAAE1C,IAAI,CAAC1G,CAAC,CAAC;UAC7BsJ,KAAK,GAAGzG,IAAI,CAAC8E,GAAG,CAAC2B,KAAK,EAAE5C,IAAI,CAAC1G,CAAC,GAAG0G,IAAI,CAACtG,KAAK,CAAC;UAC5CmJ,GAAG,GAAG1G,IAAI,CAACG,GAAG,CAACuG,GAAG,EAAE7C,IAAI,CAACzG,CAAC,CAAC;UAC3BuJ,MAAM,GAAG3G,IAAI,CAAC8E,GAAG,CAAC6B,MAAM,EAAE9C,IAAI,CAACzG,CAAC,GAAGyG,IAAI,CAACoD,MAAM,CAAC;QACnD;MACJ;IACJ,CAAC,CAAC;IACF,OAAO,IAAInL,IAAI,CAACyK,IAAI,EAAEG,GAAG,EAAE1G,IAAI,CAAC8E,GAAG,CAAC2B,KAAK,GAAGF,IAAI,EAAE,IAAI,CAACtJ,sBAAsB,CAAC,EAAE0J,MAAM,GAAGD,GAAG,CAAC;EACjG,CAAC;EACD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA9J,mBAAmB,CAACsK,SAAS,GAAG,qBAAqB;EACrDtK,mBAAmB,CAACuK,IAAI,GAAG,iBAAiB;EAC5C,OAAOvK,mBAAmB;AAC9B,CAAC,CAACR,SAAS,CAAE;AACb,SAASQ,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}