{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Group } from \"../../scene/group\";\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\"; // import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\n\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\nimport { createId } from \"../../util/id\";\n\nvar GroupedCategoryAxisLabel =\n/** @class */\nfunction (_super) {\n  __extends(GroupedCategoryAxisLabel, _super);\n\n  function GroupedCategoryAxisLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.grid = false;\n    return _this;\n  }\n\n  return GroupedCategoryAxisLabel;\n}(AxisLabel);\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\n\n\nvar GroupedCategoryAxis =\n/** @class */\nfunction (_super) {\n  __extends(GroupedCategoryAxis, _super);\n\n  function GroupedCategoryAxis() {\n    var _this = _super.call(this, new BandScale()) || this;\n\n    _this.id = createId(_this);\n    _this.tickScale = new BandScale();\n    _this.group = new Group();\n    _this.longestSeparatorLength = 0;\n    _this.translation = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Axis rotation angle in degrees.\n     */\n\n    _this.rotation = 0;\n    _this.line = {\n      width: 1,\n      color: 'rgba(195, 195, 195, 1)'\n    }; // readonly tick = new AxisTick();\n\n    _this.label = new GroupedCategoryAxisLabel();\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n\n    _this.labelColor = 'rgba(87, 87, 87, 1)';\n    var _a = _this,\n        group = _a.group,\n        scale = _a.scale,\n        tickScale = _a.tickScale;\n    scale.paddingOuter = 0.1;\n    scale.paddingInner = scale.paddingOuter * 2;\n    _this.requestedRange = scale.range.slice();\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    _this.gridLineSelection = Selection.select(group).selectAll();\n    _this.axisLineSelection = Selection.select(group).selectAll();\n    _this.separatorSelection = Selection.select(group).selectAll();\n    _this.labelSelection = Selection.select(group).selectAll();\n    return _this; // this.group.append(this.bboxRect); // debug (bbox)\n  }\n\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n    get: function () {\n      return this.scale.domain;\n    },\n    set: function (value) {\n      this.scale.domain = value;\n      var tickTree = ticksToTree(value);\n      this.tickTreeLayout = treeLayout(tickTree);\n      var domain = value.slice();\n      domain.push('');\n      this.tickScale.domain = domain;\n      this.resizeTickTree();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n    get: function () {\n      return this.requestedRange.slice();\n    },\n    set: function (value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GroupedCategoryAxis.prototype.updateRange = function () {\n    var _a = this,\n        rr = _a.requestedRange,\n        vr = _a.visibleRange,\n        scale = _a.scale;\n\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    this.tickScale.range = scale.range = [start, start + span];\n    this.resizeTickTree();\n  };\n\n  GroupedCategoryAxis.prototype.resizeTickTree = function () {\n    var s = this.scale;\n    var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    var layout = this.tickTreeLayout;\n    var lineHeight = this.lineHeight;\n\n    if (layout) {\n      layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\n    }\n  };\n\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n    get: function () {\n      return this.label.fontSize * 1.5;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n    get: function () {\n      return this._gridLength;\n    },\n\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     */\n    set: function (value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n        this.labelSelection = this.labelSelection.remove().setData([]);\n      }\n\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n\n  GroupedCategoryAxis.prototype.update = function () {\n    var _this = this;\n\n    var _a = this,\n        group = _a.group,\n        scale = _a.scale,\n        label = _a.label,\n        tickScale = _a.tickScale,\n        requestedRange = _a.requestedRange;\n\n    var rangeStart = scale.range[0];\n    var rangeEnd = scale.range[1];\n    var rangeLength = Math.abs(rangeEnd - rangeStart);\n    var bandwidth = rangeLength / scale.domain.length || 0;\n    var parallelLabels = label.parallel;\n    var rotation = toRadians(this.rotation);\n    var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n    group.translationX = this.translation.x;\n    group.translationY = this.translation.y;\n    group.rotation = rotation;\n    var title = this.title; // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n    // The phantom root of the tree layout is used instead.\n\n    if (title) {\n      title.node.visible = false;\n    }\n\n    var lineHeight = this.lineHeight; // Render ticks and labels.\n\n    var tickTreeLayout = this.tickTreeLayout;\n    var labels = scale.ticks();\n    var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    var ticks = tickScale.ticks(); // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n\n    var sideFlag = label.mirrored ? 1 : -1; // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, Ï€] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2); // Flip if the axis rotation angle is in the top hemisphere.\n\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n    updateGridLines.exit.remove();\n    var enterGridLines = updateGridLines.enter.append(Line);\n    var gridLineSelection = updateGridLines.merge(enterGridLines);\n    var updateLabels = this.labelSelection.setData(treeLabels);\n    updateLabels.exit.remove();\n    var enterLabels = updateLabels.enter.append(Text);\n    var labelSelection = updateLabels.merge(enterLabels);\n    var labelFormatter = label.formatter;\n    var maxLeafLabelWidth = 0;\n    labelSelection.each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging'; // label.textBaseline = parallelLabels && !labelRotation\n      //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n      //     : 'middle';\n\n      node.textAlign = 'center';\n      node.translationX = datum.screenY - label.fontSize * 0.25;\n      node.translationY = datum.screenX;\n\n      if (index === 0) {\n        // use the phantom root as the axis title\n        if (title && title.enabled && labels.length > 0) {\n          node.visible = true;\n          node.text = title.text;\n          node.fontSize = title.fontSize;\n          node.fontStyle = title.fontStyle;\n          node.fontWeight = title.fontWeight;\n          node.fontFamily = title.fontFamily;\n          node.textBaseline = 'hanging';\n        } else {\n          node.visible = false;\n        }\n      } else {\n        node.text = labelFormatter ? labelFormatter({\n          value: String(datum.label),\n          index: index\n        }) : String(datum.label);\n        node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];\n      }\n\n      var bbox = node.computeBBox();\n\n      if (bbox && bbox.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox.width;\n      }\n    });\n    var labelX = sideFlag * label.padding;\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    var labelGrid = this.label.grid;\n    var separatorData = [];\n    labelSelection.each(function (label, datum, index) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n\n      if (!datum.children.length) {\n        label.rotation = labelRotation;\n        label.textAlign = 'end';\n        label.textBaseline = 'middle';\n      } else {\n        label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n\n        if (isHorizontal) {\n          label.rotation = autoRotation;\n        } else {\n          label.rotation = -Math.PI / 2;\n        }\n      } // Calculate positions of label separators for all nodes except the root.\n      // Each separator is placed to the top of the current label.\n\n\n      if (datum.parent && isLabelTree) {\n        var y = !datum.children.length ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n\n        if (!datum.children.length) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y: y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - _this.label.padding * 2,\n              toString: function () {\n                return String(index);\n              }\n            });\n          }\n        } else {\n          var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y: y,\n            x1: x + lineHeight,\n            x2: x,\n            toString: function () {\n              return String(index);\n            }\n          });\n        }\n      }\n    }); // Calculate the position of the long separator on the far bottom of the axis.\n\n    var minX = 0;\n    separatorData.forEach(function (d) {\n      return minX = Math.min(minX, d.x2);\n    });\n    this.longestSeparatorLength = Math.abs(minX);\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX,\n      toString: function () {\n        return String(separatorData.length);\n      }\n    });\n    var updateSeparators = this.separatorSelection.setData(separatorData);\n    updateSeparators.exit.remove();\n    var enterSeparators = updateSeparators.enter.append(Line);\n    var separatorSelection = updateSeparators.merge(enterSeparators);\n    this.separatorSelection = separatorSelection;\n    var epsilon = 0.0000001;\n    separatorSelection.each(function (line, datum, i) {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n      line.stroke = _this.tick.color;\n      line.fill = undefined;\n      line.strokeWidth = 1;\n    });\n    this.gridLineSelection = gridLineSelection;\n    this.labelSelection = labelSelection; // Render axis lines.\n\n    var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    var lines = [];\n\n    for (var i = 0; i < lineCount; i++) {\n      lines.push(i);\n    }\n\n    var updateAxisLines = this.axisLineSelection.setData(lines);\n    updateAxisLines.exit.remove();\n    var enterAxisLines = updateAxisLines.enter.append(Line);\n    var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n    this.axisLineSelection = axisLineSelection;\n    axisLineSelection.each(function (line, _, index) {\n      var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n      line.x1 = x;\n      line.x2 = x;\n      line.y1 = requestedRange[0];\n      line.y2 = requestedRange[1];\n      line.strokeWidth = _this.line.width;\n      line.stroke = _this.line.color;\n      line.visible = labels.length > 0 && (index === 0 || labelGrid && isLabelTree);\n    });\n\n    if (this.gridLength) {\n      var styles_1 = this.gridStyle;\n      var styleCount_1 = styles_1.length;\n      gridLineSelection.each(function (line, datum, index) {\n        var y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * _this.gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = y >= requestedRange[0] && y <= requestedRange[1] && Math.abs(line.parent.translationY - rangeStart) > 1;\n        var style = styles_1[index % styleCount_1];\n        line.stroke = style.stroke;\n        line.strokeWidth = _this.tick.width;\n        line.lineDash = style.lineDash;\n        line.fill = undefined;\n      });\n    } // debug (bbox)\n    // const bbox = this.computeBBox();\n    // const bboxRect = this.bboxRect;\n    // bboxRect.x = bbox.x;\n    // bboxRect.y = bbox.y;\n    // bboxRect.width = bbox.width;\n    // bboxRect.height = bbox.height;\n\n  };\n\n  GroupedCategoryAxis.prototype.computeBBox = function (options) {\n    var includeTitle = !options || !options.excludeTitle;\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    this.labelSelection.each(function (label, _, index) {\n      // The label itself is rotated, but not translated, the group that\n      // contains it is. So to capture the group transform in the label bbox\n      // calculation we combine the transform matrices of the label and the group.\n      // Depending on the timing of the `axis.computeBBox()` method call, we may\n      // not have the group's and the label's transform matrices updated yet (because\n      // the transform matrix is not recalculated whenever a node's transform attributes\n      // change, instead it's marked for recalculation on the next frame by setting\n      // the node's `dirtyTransform` flag to `true`), so we force them to update\n      // right here by calling `computeTransformMatrix`.\n      if (index > 0 || includeTitle) {\n        // first node is the root (title)\n        label.computeTransformMatrix();\n        var matrix = Matrix.flyweight(label.matrix);\n        var labelBBox = label.computeBBox();\n\n        if (labelBBox) {\n          var bbox = matrix.transformBBox(labelBBox);\n          left = Math.min(left, bbox.x);\n          right = Math.max(right, bbox.x + bbox.width);\n          top = Math.min(top, bbox.y);\n          bottom = Math.max(bottom, bbox.y + bbox.height);\n        }\n      }\n    });\n    return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n  }; // debug (bbox)\n  // private bboxRect = (() => {\n  //     const rect = new Rect();\n  //     rect.fill = undefined;\n  //     rect.stroke = 'red';\n  //     rect.strokeWidth = 1;\n  //     rect.strokeOpacity = 0.7;\n  //     return rect;\n  // })();\n\n\n  GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n  GroupedCategoryAxis.type = 'groupedCategory';\n  return GroupedCategoryAxis;\n}(ChartAxis);\n\nexport { GroupedCategoryAxis };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/chart/axis/groupedCategoryAxis.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Group","Selection","Line","normalizeAngle360","toRadians","Text","BBox","Matrix","BandScale","ticksToTree","treeLayout","AxisLabel","ChartAxis","createId","GroupedCategoryAxisLabel","_super","_this","apply","arguments","grid","GroupedCategoryAxis","call","id","tickScale","group","longestSeparatorLength","translation","x","y","rotation","line","width","color","label","labelColor","_a","scale","paddingOuter","paddingInner","requestedRange","range","slice","gridLineSelection","select","selectAll","axisLineSelection","separatorSelection","labelSelection","defineProperty","get","domain","set","value","tickTree","tickTreeLayout","push","resizeTickTree","enumerable","configurable","updateRange","rr","vr","visibleRange","span","shift","start","s","length","convert","layout","lineHeight","resize","Math","abs","depth","min","bandwidth","fontSize","_gridLength","remove","setData","update","rangeStart","rangeEnd","rangeLength","parallelLabels","parallel","isHorizontal","cos","labelRotation","translationX","translationY","title","node","visible","labels","ticks","treeLabels","nodes","isLabelTree","sideFlag","mirrored","parallelFlipRotation","parallelFlipFlag","PI","regularFlipRotation","regularFlipFlag","updateGridLines","gridLength","exit","enterGridLines","enter","append","merge","updateLabels","enterLabels","labelFormatter","formatter","maxLeafLabelWidth","each","datum","index","fontStyle","fontWeight","fontFamily","fill","textBaseline","textAlign","screenY","screenX","enabled","text","String","bbox","computeBBox","labelX","padding","autoRotation","labelGrid","separatorData","rotationCenterX","children","parent","leafCount","number","x1","x2","toString","minX","forEach","max","updateSeparators","enterSeparators","epsilon","i","y1","y2","stroke","tick","undefined","strokeWidth","lineCount","lines","updateAxisLines","enterAxisLines","_","styles_1","gridStyle","styleCount_1","round","style","lineDash","options","includeTitle","excludeTitle","left","Infinity","right","top","bottom","computeTransformMatrix","matrix","flyweight","labelBBox","transformBBox","height","className","type"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,SAASI,KAAT,QAAsB,mBAAtB;AACA,SAASC,SAAT,QAA0B,uBAA1B;AACA,SAASC,IAAT,QAAqB,wBAArB;AACA,SAASC,iBAAT,EAA4BC,SAA5B,QAA6C,kBAA7C;AACA,SAASC,IAAT,QAAqB,wBAArB;AACA,SAASC,IAAT,QAAqB,kBAArB;AACA,SAASC,MAAT,QAAuB,oBAAvB,C,CACA;;AACA,SAASC,SAAT,QAA0B,uBAA1B;AACA,SAASC,WAAT,EAAsBC,UAAtB,QAAwC,mBAAxC;AACA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAASC,SAAT,QAA0B,cAA1B;AACA,SAASC,QAAT,QAAyB,eAAzB;;AACA,IAAIC,wBAAwB;AAAG;AAAe,UAAUC,MAAV,EAAkB;AAC5D7B,EAAAA,SAAS,CAAC4B,wBAAD,EAA2BC,MAA3B,CAAT;;AACA,WAASD,wBAAT,GAAoC;AAChC,QAAIE,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AACAF,IAAAA,KAAK,CAACG,IAAN,GAAa,KAAb;AACA,WAAOH,KAAP;AACH;;AACD,SAAOF,wBAAP;AACH,CAR6C,CAQ5CH,SAR4C,CAA9C;AASA;;;;;;;;;;;AASA,IAAIS,mBAAmB;AAAG;AAAe,UAAUL,MAAV,EAAkB;AACvD7B,EAAAA,SAAS,CAACkC,mBAAD,EAAsBL,MAAtB,CAAT;;AACA,WAASK,mBAAT,GAA+B;AAC3B,QAAIJ,KAAK,GAAGD,MAAM,CAACM,IAAP,CAAY,IAAZ,EAAkB,IAAIb,SAAJ,EAAlB,KAAsC,IAAlD;;AACAQ,IAAAA,KAAK,CAACM,EAAN,GAAWT,QAAQ,CAACG,KAAD,CAAnB;AACAA,IAAAA,KAAK,CAACO,SAAN,GAAkB,IAAIf,SAAJ,EAAlB;AACAQ,IAAAA,KAAK,CAACQ,KAAN,GAAc,IAAIxB,KAAJ,EAAd;AACAgB,IAAAA,KAAK,CAACS,sBAAN,GAA+B,CAA/B;AACAT,IAAAA,KAAK,CAACU,WAAN,GAAoB;AAChBC,MAAAA,CAAC,EAAE,CADa;AAEhBC,MAAAA,CAAC,EAAE;AAFa,KAApB;AAIA;;;;AAGAZ,IAAAA,KAAK,CAACa,QAAN,GAAiB,CAAjB;AACAb,IAAAA,KAAK,CAACc,IAAN,GAAa;AACTC,MAAAA,KAAK,EAAE,CADE;AAETC,MAAAA,KAAK,EAAE;AAFE,KAAb,CAd2B,CAkB3B;;AACAhB,IAAAA,KAAK,CAACiB,KAAN,GAAc,IAAInB,wBAAJ,EAAd;AACA;;;;;AAIAE,IAAAA,KAAK,CAACkB,UAAN,GAAmB,qBAAnB;AACA,QAAIC,EAAE,GAAGnB,KAAT;AAAA,QAAgBQ,KAAK,GAAGW,EAAE,CAACX,KAA3B;AAAA,QAAkCY,KAAK,GAAGD,EAAE,CAACC,KAA7C;AAAA,QAAoDb,SAAS,GAAGY,EAAE,CAACZ,SAAnE;AACAa,IAAAA,KAAK,CAACC,YAAN,GAAqB,GAArB;AACAD,IAAAA,KAAK,CAACE,YAAN,GAAqBF,KAAK,CAACC,YAAN,GAAqB,CAA1C;AACArB,IAAAA,KAAK,CAACuB,cAAN,GAAuBH,KAAK,CAACI,KAAN,CAAYC,KAAZ,EAAvB;AACAlB,IAAAA,SAAS,CAACe,YAAV,GAAyB,CAAzB;AACAf,IAAAA,SAAS,CAACc,YAAV,GAAyB,CAAzB;AACArB,IAAAA,KAAK,CAAC0B,iBAAN,GAA0BzC,SAAS,CAAC0C,MAAV,CAAiBnB,KAAjB,EAAwBoB,SAAxB,EAA1B;AACA5B,IAAAA,KAAK,CAAC6B,iBAAN,GAA0B5C,SAAS,CAAC0C,MAAV,CAAiBnB,KAAjB,EAAwBoB,SAAxB,EAA1B;AACA5B,IAAAA,KAAK,CAAC8B,kBAAN,GAA2B7C,SAAS,CAAC0C,MAAV,CAAiBnB,KAAjB,EAAwBoB,SAAxB,EAA3B;AACA5B,IAAAA,KAAK,CAAC+B,cAAN,GAAuB9C,SAAS,CAAC0C,MAAV,CAAiBnB,KAAjB,EAAwBoB,SAAxB,EAAvB;AACA,WAAO5B,KAAP,CAnC2B,CAoC3B;AACH;;AACD1B,EAAAA,MAAM,CAAC0D,cAAP,CAAsB5B,mBAAmB,CAACtB,SAA1C,EAAqD,QAArD,EAA+D;AAC3DmD,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,KAAKb,KAAL,CAAWc,MAAlB;AACH,KAH0D;AAI3DC,IAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AAClB,WAAKhB,KAAL,CAAWc,MAAX,GAAoBE,KAApB;AACA,UAAIC,QAAQ,GAAG5C,WAAW,CAAC2C,KAAD,CAA1B;AACA,WAAKE,cAAL,GAAsB5C,UAAU,CAAC2C,QAAD,CAAhC;AACA,UAAIH,MAAM,GAAGE,KAAK,CAACX,KAAN,EAAb;AACAS,MAAAA,MAAM,CAACK,IAAP,CAAY,EAAZ;AACA,WAAKhC,SAAL,CAAe2B,MAAf,GAAwBA,MAAxB;AACA,WAAKM,cAAL;AACH,KAZ0D;AAa3DC,IAAAA,UAAU,EAAE,IAb+C;AAc3DC,IAAAA,YAAY,EAAE;AAd6C,GAA/D;AAgBApE,EAAAA,MAAM,CAAC0D,cAAP,CAAsB5B,mBAAmB,CAACtB,SAA1C,EAAqD,OAArD,EAA8D;AAC1DmD,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,KAAKV,cAAL,CAAoBE,KAApB,EAAP;AACH,KAHyD;AAI1DU,IAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AAClB,WAAKb,cAAL,GAAsBa,KAAK,CAACX,KAAN,EAAtB;AACA,WAAKkB,WAAL;AACH,KAPyD;AAQ1DF,IAAAA,UAAU,EAAE,IAR8C;AAS1DC,IAAAA,YAAY,EAAE;AAT4C,GAA9D;;AAWAtC,EAAAA,mBAAmB,CAACtB,SAApB,CAA8B6D,WAA9B,GAA4C,YAAY;AACpD,QAAIxB,EAAE,GAAG,IAAT;AAAA,QAAeyB,EAAE,GAAGzB,EAAE,CAACI,cAAvB;AAAA,QAAuCsB,EAAE,GAAG1B,EAAE,CAAC2B,YAA/C;AAAA,QAA6D1B,KAAK,GAAGD,EAAE,CAACC,KAAxE;;AACA,QAAI2B,IAAI,GAAG,CAACH,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAAX,KAAmBC,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAA7B,CAAX;AACA,QAAIG,KAAK,GAAGD,IAAI,GAAGF,EAAE,CAAC,CAAD,CAArB;AACA,QAAII,KAAK,GAAGL,EAAE,CAAC,CAAD,CAAF,GAAQI,KAApB;AACA,SAAKzC,SAAL,CAAeiB,KAAf,GAAuBJ,KAAK,CAACI,KAAN,GAAc,CAACyB,KAAD,EAAQA,KAAK,GAAGF,IAAhB,CAArC;AACA,SAAKP,cAAL;AACH,GAPD;;AAQApC,EAAAA,mBAAmB,CAACtB,SAApB,CAA8B0D,cAA9B,GAA+C,YAAY;AACvD,QAAIU,CAAC,GAAG,KAAK9B,KAAb;AACA,QAAII,KAAK,GAAG0B,CAAC,CAAChB,MAAF,CAASiB,MAAT,GAAkB,CAACD,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAChB,MAAF,CAAS,CAAT,CAAV,CAAD,EAAyBgB,CAAC,CAACE,OAAF,CAAUF,CAAC,CAAChB,MAAF,CAASgB,CAAC,CAAChB,MAAF,CAASiB,MAAT,GAAkB,CAA3B,CAAV,CAAzB,CAAlB,GAAuFD,CAAC,CAAC1B,KAArG;AACA,QAAI6B,MAAM,GAAG,KAAKf,cAAlB;AACA,QAAIgB,UAAU,GAAG,KAAKA,UAAtB;;AACA,QAAID,MAAJ,EAAY;AACRA,MAAAA,MAAM,CAACE,MAAP,CAAcC,IAAI,CAACC,GAAL,CAASjC,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAzB,CAAd,EAA6C6B,MAAM,CAACK,KAAP,GAAeJ,UAA5D,EAAwE,CAACE,IAAI,CAACG,GAAL,CAASnC,KAAK,CAAC,CAAD,CAAd,EAAmBA,KAAK,CAAC,CAAD,CAAxB,KAAgC,CAAjC,IAAsC,CAAC0B,CAAC,CAACU,SAAF,IAAe,CAAhB,IAAqB,CAAnI,EAAsI,CAACP,MAAM,CAACK,KAAR,GAAgBJ,UAAtJ,EAAmK9B,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAjB,GAAwB,CAA1L;AACH;AACJ,GARD;;AASAlD,EAAAA,MAAM,CAAC0D,cAAP,CAAsB5B,mBAAmB,CAACtB,SAA1C,EAAqD,YAArD,EAAmE;AAC/DmD,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,KAAKhB,KAAL,CAAW4C,QAAX,GAAsB,GAA7B;AACH,KAH8D;AAI/DpB,IAAAA,UAAU,EAAE,IAJmD;AAK/DC,IAAAA,YAAY,EAAE;AALiD,GAAnE;AAOApE,EAAAA,MAAM,CAAC0D,cAAP,CAAsB5B,mBAAmB,CAACtB,SAA1C,EAAqD,YAArD,EAAmE;AAC/DmD,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,KAAK6B,WAAZ;AACH,KAH8D;;AAI/D;;;AAGA3B,IAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AAClB;AACA,UAAI,KAAK0B,WAAL,IAAoB,CAAC1B,KAArB,IAA8B,CAAC,KAAK0B,WAAN,IAAqB1B,KAAvD,EAA8D;AAC1D,aAAKV,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBqC,MAAvB,GAAgCC,OAAhC,CAAwC,EAAxC,CAAzB;AACA,aAAKjC,cAAL,GAAsB,KAAKA,cAAL,CAAoBgC,MAApB,GAA6BC,OAA7B,CAAqC,EAArC,CAAtB;AACH;;AACD,WAAKF,WAAL,GAAmB1B,KAAnB;AACH,KAd8D;AAe/DK,IAAAA,UAAU,EAAE,IAfmD;AAgB/DC,IAAAA,YAAY,EAAE;AAhBiD,GAAnE;AAkBA;;;;;;;;;;;;;;AAaAtC,EAAAA,mBAAmB,CAACtB,SAApB,CAA8BmF,MAA9B,GAAuC,YAAY;AAC/C,QAAIjE,KAAK,GAAG,IAAZ;;AACA,QAAImB,EAAE,GAAG,IAAT;AAAA,QAAeX,KAAK,GAAGW,EAAE,CAACX,KAA1B;AAAA,QAAiCY,KAAK,GAAGD,EAAE,CAACC,KAA5C;AAAA,QAAmDH,KAAK,GAAGE,EAAE,CAACF,KAA9D;AAAA,QAAqEV,SAAS,GAAGY,EAAE,CAACZ,SAApF;AAAA,QAA+FgB,cAAc,GAAGJ,EAAE,CAACI,cAAnH;;AACA,QAAI2C,UAAU,GAAG9C,KAAK,CAACI,KAAN,CAAY,CAAZ,CAAjB;AACA,QAAI2C,QAAQ,GAAG/C,KAAK,CAACI,KAAN,CAAY,CAAZ,CAAf;AACA,QAAI4C,WAAW,GAAGZ,IAAI,CAACC,GAAL,CAASU,QAAQ,GAAGD,UAApB,CAAlB;AACA,QAAIN,SAAS,GAAIQ,WAAW,GAAGhD,KAAK,CAACc,MAAN,CAAaiB,MAA5B,IAAuC,CAAvD;AACA,QAAIkB,cAAc,GAAGpD,KAAK,CAACqD,QAA3B;AACA,QAAIzD,QAAQ,GAAGzB,SAAS,CAAC,KAAKyB,QAAN,CAAxB;AACA,QAAI0D,YAAY,GAAGf,IAAI,CAACC,GAAL,CAASD,IAAI,CAACgB,GAAL,CAAS3D,QAAT,CAAT,IAA+B,IAAlD;AACA,QAAI4D,aAAa,GAAGtF,iBAAiB,CAACC,SAAS,CAAC,KAAK6B,KAAL,CAAWJ,QAAZ,CAAV,CAArC;AACAL,IAAAA,KAAK,CAACkE,YAAN,GAAqB,KAAKhE,WAAL,CAAiBC,CAAtC;AACAH,IAAAA,KAAK,CAACmE,YAAN,GAAqB,KAAKjE,WAAL,CAAiBE,CAAtC;AACAJ,IAAAA,KAAK,CAACK,QAAN,GAAiBA,QAAjB;AACA,QAAI+D,KAAK,GAAG,KAAKA,KAAjB,CAd+C,CAe/C;AACA;;AACA,QAAIA,KAAJ,EAAW;AACPA,MAAAA,KAAK,CAACC,IAAN,CAAWC,OAAX,GAAqB,KAArB;AACH;;AACD,QAAIxB,UAAU,GAAG,KAAKA,UAAtB,CApB+C,CAqB/C;;AACA,QAAIhB,cAAc,GAAG,KAAKA,cAA1B;AACA,QAAIyC,MAAM,GAAG3D,KAAK,CAAC4D,KAAN,EAAb;AACA,QAAIC,UAAU,GAAG3C,cAAc,GAAGA,cAAc,CAAC4C,KAAlB,GAA0B,EAAzD;AACA,QAAIC,WAAW,GAAG7C,cAAc,GAAGA,cAAc,CAACoB,KAAf,GAAuB,CAA1B,GAA8B,KAA9D;AACA,QAAIsB,KAAK,GAAGzE,SAAS,CAACyE,KAAV,EAAZ,CA1B+C,CA2B/C;AACA;AACA;;AACA,QAAII,QAAQ,GAAGnE,KAAK,CAACoE,QAAN,GAAiB,CAAjB,GAAqB,CAAC,CAArC,CA9B+C,CA+B/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIC,oBAAoB,GAAGnG,iBAAiB,CAAC0B,QAAD,CAA5C;AACA,QAAI0E,gBAAgB,GAAI,CAACd,aAAD,IAAkBa,oBAAoB,IAAI,CAA1C,IAA+CA,oBAAoB,IAAI9B,IAAI,CAACgC,EAA7E,GAAmF,CAAC,CAApF,GAAwF,CAA/G;AACA,QAAIC,mBAAmB,GAAGtG,iBAAiB,CAAC0B,QAAQ,GAAG2C,IAAI,CAACgC,EAAL,GAAU,CAAtB,CAA3C,CA1C+C,CA2C/C;;AACA,QAAIE,eAAe,GAAI,CAACjB,aAAD,IAAkBgB,mBAAmB,IAAI,CAAzC,IAA8CA,mBAAmB,IAAIjC,IAAI,CAACgC,EAA3E,GAAiF,CAAC,CAAlF,GAAsF,CAA5G;AACA,QAAIG,eAAe,GAAG,KAAKjE,iBAAL,CAAuBsC,OAAvB,CAA+B,KAAK4B,UAAL,GAAkBZ,KAAlB,GAA0B,EAAzD,CAAtB;AACAW,IAAAA,eAAe,CAACE,IAAhB,CAAqB9B,MAArB;AACA,QAAI+B,cAAc,GAAGH,eAAe,CAACI,KAAhB,CAAsBC,MAAtB,CAA6B9G,IAA7B,CAArB;AACA,QAAIwC,iBAAiB,GAAGiE,eAAe,CAACM,KAAhB,CAAsBH,cAAtB,CAAxB;AACA,QAAII,YAAY,GAAG,KAAKnE,cAAL,CAAoBiC,OAApB,CAA4BiB,UAA5B,CAAnB;AACAiB,IAAAA,YAAY,CAACL,IAAb,CAAkB9B,MAAlB;AACA,QAAIoC,WAAW,GAAGD,YAAY,CAACH,KAAb,CAAmBC,MAAnB,CAA0B3G,IAA1B,CAAlB;AACA,QAAI0C,cAAc,GAAGmE,YAAY,CAACD,KAAb,CAAmBE,WAAnB,CAArB;AACA,QAAIC,cAAc,GAAGnF,KAAK,CAACoF,SAA3B;AACA,QAAIC,iBAAiB,GAAG,CAAxB;AACAvE,IAAAA,cAAc,CACTwE,IADL,CACU,UAAU1B,IAAV,EAAgB2B,KAAhB,EAAuBC,KAAvB,EAA8B;AACpC5B,MAAAA,IAAI,CAAC6B,SAAL,GAAiBzF,KAAK,CAACyF,SAAvB;AACA7B,MAAAA,IAAI,CAAC8B,UAAL,GAAkB1F,KAAK,CAAC0F,UAAxB;AACA9B,MAAAA,IAAI,CAAChB,QAAL,GAAgB5C,KAAK,CAAC4C,QAAtB;AACAgB,MAAAA,IAAI,CAAC+B,UAAL,GAAkB3F,KAAK,CAAC2F,UAAxB;AACA/B,MAAAA,IAAI,CAACgC,IAAL,GAAY5F,KAAK,CAACD,KAAlB;AACA6D,MAAAA,IAAI,CAACiC,YAAL,GAAoBvB,gBAAgB,KAAK,CAAC,CAAtB,GAA0B,QAA1B,GAAqC,SAAzD,CANoC,CAOpC;AACA;AACA;;AACAV,MAAAA,IAAI,CAACkC,SAAL,GAAiB,QAAjB;AACAlC,MAAAA,IAAI,CAACH,YAAL,GAAoB8B,KAAK,CAACQ,OAAN,GAAgB/F,KAAK,CAAC4C,QAAN,GAAiB,IAArD;AACAgB,MAAAA,IAAI,CAACF,YAAL,GAAoB6B,KAAK,CAACS,OAA1B;;AACA,UAAIR,KAAK,KAAK,CAAd,EAAiB;AAAE;AACf,YAAI7B,KAAK,IAAIA,KAAK,CAACsC,OAAf,IAA0BnC,MAAM,CAAC5B,MAAP,GAAgB,CAA9C,EAAiD;AAC7C0B,UAAAA,IAAI,CAACC,OAAL,GAAe,IAAf;AACAD,UAAAA,IAAI,CAACsC,IAAL,GAAYvC,KAAK,CAACuC,IAAlB;AACAtC,UAAAA,IAAI,CAAChB,QAAL,GAAgBe,KAAK,CAACf,QAAtB;AACAgB,UAAAA,IAAI,CAAC6B,SAAL,GAAiB9B,KAAK,CAAC8B,SAAvB;AACA7B,UAAAA,IAAI,CAAC8B,UAAL,GAAkB/B,KAAK,CAAC+B,UAAxB;AACA9B,UAAAA,IAAI,CAAC+B,UAAL,GAAkBhC,KAAK,CAACgC,UAAxB;AACA/B,UAAAA,IAAI,CAACiC,YAAL,GAAoB,SAApB;AACH,SARD,MASK;AACDjC,UAAAA,IAAI,CAACC,OAAL,GAAe,KAAf;AACH;AACJ,OAbD,MAcK;AACDD,QAAAA,IAAI,CAACsC,IAAL,GAAYf,cAAc,GACpBA,cAAc,CAAC;AACbhE,UAAAA,KAAK,EAAEgF,MAAM,CAACZ,KAAK,CAACvF,KAAP,CADA;AAEbwF,UAAAA,KAAK,EAAEA;AAFM,SAAD,CADM,GAKpBW,MAAM,CAACZ,KAAK,CAACvF,KAAP,CALZ;AAMA4D,QAAAA,IAAI,CAACC,OAAL,GACI0B,KAAK,CAACS,OAAN,IAAiB1F,cAAc,CAAC,CAAD,CAA/B,IACIiF,KAAK,CAACS,OAAN,IAAiB1F,cAAc,CAAC,CAAD,CAFvC;AAGH;;AACD,UAAI8F,IAAI,GAAGxC,IAAI,CAACyC,WAAL,EAAX;;AACA,UAAID,IAAI,IAAIA,IAAI,CAACtG,KAAL,GAAauF,iBAAzB,EAA4C;AACxCA,QAAAA,iBAAiB,GAAGe,IAAI,CAACtG,KAAzB;AACH;AACJ,KA3CD;AA4CA,QAAIwG,MAAM,GAAGnC,QAAQ,GAAGnE,KAAK,CAACuG,OAA9B;AACA,QAAIC,YAAY,GAAGpD,cAAc,GAC3BkB,gBAAgB,GAAG/B,IAAI,CAACgC,EAAxB,GAA6B,CADF,GAE1BE,eAAe,KAAK,CAAC,CAArB,GAAyBlC,IAAI,CAACgC,EAA9B,GAAmC,CAF1C;AAGA,QAAIkC,SAAS,GAAG,KAAKzG,KAAL,CAAWd,IAA3B;AACA,QAAIwH,aAAa,GAAG,EAApB;AACA5F,IAAAA,cAAc,CAACwE,IAAf,CAAoB,UAAUtF,KAAV,EAAiBuF,KAAjB,EAAwBC,KAAxB,EAA+B;AAC/CxF,MAAAA,KAAK,CAACN,CAAN,GAAU4G,MAAV;AACAtG,MAAAA,KAAK,CAAC2G,eAAN,GAAwBL,MAAxB;;AACA,UAAI,CAACf,KAAK,CAACqB,QAAN,CAAe1E,MAApB,EAA4B;AACxBlC,QAAAA,KAAK,CAACJ,QAAN,GAAiB4D,aAAjB;AACAxD,QAAAA,KAAK,CAAC8F,SAAN,GAAkB,KAAlB;AACA9F,QAAAA,KAAK,CAAC6F,YAAN,GAAqB,QAArB;AACH,OAJD,MAKK;AACD7F,QAAAA,KAAK,CAACyD,YAAN,IAAsB4B,iBAAiB,GAAGhD,UAApB,GAAiCtD,KAAK,CAACiB,KAAN,CAAYuG,OAAnE;;AACA,YAAIjD,YAAJ,EAAkB;AACdtD,UAAAA,KAAK,CAACJ,QAAN,GAAiB4G,YAAjB;AACH,SAFD,MAGK;AACDxG,UAAAA,KAAK,CAACJ,QAAN,GAAiB,CAAC2C,IAAI,CAACgC,EAAN,GAAW,CAA5B;AACH;AACJ,OAhB8C,CAiB/C;AACA;;;AACA,UAAIgB,KAAK,CAACsB,MAAN,IAAgB3C,WAApB,EAAiC;AAC7B,YAAIvE,CAAC,GAAG,CAAC4F,KAAK,CAACqB,QAAN,CAAe1E,MAAhB,GACFqD,KAAK,CAACS,OAAN,GAAgBrD,SAAS,GAAG,CAD1B,GAEF4C,KAAK,CAACS,OAAN,GAAgBT,KAAK,CAACuB,SAAN,GAAkBnE,SAAlB,GAA8B,CAFpD;;AAGA,YAAI,CAAC4C,KAAK,CAACqB,QAAN,CAAe1E,MAApB,EAA4B;AACxB,cAAKqD,KAAK,CAACwB,MAAN,KAAiBxB,KAAK,CAACqB,QAAN,CAAe1E,MAAf,GAAwB,CAA1C,IAAgDuE,SAApD,EAA+D;AAC3DC,YAAAA,aAAa,CAACpF,IAAd,CAAmB;AACf3B,cAAAA,CAAC,EAAEA,CADY;AAEfqH,cAAAA,EAAE,EAAE,CAFW;AAGfC,cAAAA,EAAE,EAAE,CAAC5B,iBAAD,GAAqBtG,KAAK,CAACiB,KAAN,CAAYuG,OAAZ,GAAsB,CAHhC;AAIfW,cAAAA,QAAQ,EAAE,YAAY;AAAE,uBAAOf,MAAM,CAACX,KAAD,CAAb;AAAuB;AAJhC,aAAnB;AAMH;AACJ,SATD,MAUK;AACD,cAAI9F,CAAC,GAAG,CAAC2F,iBAAD,GAAqBtG,KAAK,CAACiB,KAAN,CAAYuG,OAAZ,GAAsB,CAA3C,GAA+ChB,KAAK,CAACQ,OAA7D;AACAW,UAAAA,aAAa,CAACpF,IAAd,CAAmB;AACf3B,YAAAA,CAAC,EAAEA,CADY;AAEfqH,YAAAA,EAAE,EAAEtH,CAAC,GAAG2C,UAFO;AAGf4E,YAAAA,EAAE,EAAEvH,CAHW;AAIfwH,YAAAA,QAAQ,EAAE,YAAY;AAAE,qBAAOf,MAAM,CAACX,KAAD,CAAb;AAAuB;AAJhC,WAAnB;AAMH;AACJ;AACJ,KA3CD,EAzG+C,CAqJ/C;;AACA,QAAI2B,IAAI,GAAG,CAAX;AACAT,IAAAA,aAAa,CAACU,OAAd,CAAsB,UAAUjK,CAAV,EAAa;AAAE,aAAOgK,IAAI,GAAG5E,IAAI,CAACG,GAAL,CAASyE,IAAT,EAAehK,CAAC,CAAC8J,EAAjB,CAAd;AAAqC,KAA1E;AACA,SAAKzH,sBAAL,GAA8B+C,IAAI,CAACC,GAAL,CAAS2E,IAAT,CAA9B;AACAT,IAAAA,aAAa,CAACpF,IAAd,CAAmB;AACf3B,MAAAA,CAAC,EAAE4C,IAAI,CAAC8E,GAAL,CAASpE,UAAT,EAAqBC,QAArB,CADY;AAEf8D,MAAAA,EAAE,EAAE,CAFW;AAGfC,MAAAA,EAAE,EAAEE,IAHW;AAIfD,MAAAA,QAAQ,EAAE,YAAY;AAAE,eAAOf,MAAM,CAACO,aAAa,CAACxE,MAAf,CAAb;AAAsC;AAJ/C,KAAnB;AAMA,QAAIoF,gBAAgB,GAAG,KAAKzG,kBAAL,CAAwBkC,OAAxB,CAAgC2D,aAAhC,CAAvB;AACAY,IAAAA,gBAAgB,CAAC1C,IAAjB,CAAsB9B,MAAtB;AACA,QAAIyE,eAAe,GAAGD,gBAAgB,CAACxC,KAAjB,CAAuBC,MAAvB,CAA8B9G,IAA9B,CAAtB;AACA,QAAI4C,kBAAkB,GAAGyG,gBAAgB,CAACtC,KAAjB,CAAuBuC,eAAvB,CAAzB;AACA,SAAK1G,kBAAL,GAA0BA,kBAA1B;AACA,QAAI2G,OAAO,GAAG,SAAd;AACA3G,IAAAA,kBAAkB,CAACyE,IAAnB,CAAwB,UAAUzF,IAAV,EAAgB0F,KAAhB,EAAuBkC,CAAvB,EAA0B;AAC9C5H,MAAAA,IAAI,CAACmH,EAAL,GAAUzB,KAAK,CAACyB,EAAhB;AACAnH,MAAAA,IAAI,CAACoH,EAAL,GAAU1B,KAAK,CAAC0B,EAAhB;AACApH,MAAAA,IAAI,CAAC6H,EAAL,GAAUnC,KAAK,CAAC5F,CAAhB;AACAE,MAAAA,IAAI,CAAC8H,EAAL,GAAUpC,KAAK,CAAC5F,CAAhB;AACAE,MAAAA,IAAI,CAACgE,OAAL,GAAe0B,KAAK,CAAC5F,CAAN,IAAWW,cAAc,CAAC,CAAD,CAAd,GAAoBkH,OAA/B,IAA0CjC,KAAK,CAAC5F,CAAN,IAAWW,cAAc,CAAC,CAAD,CAAd,GAAoBkH,OAAxF;AACA3H,MAAAA,IAAI,CAAC+H,MAAL,GAAc7I,KAAK,CAAC8I,IAAN,CAAW9H,KAAzB;AACAF,MAAAA,IAAI,CAAC+F,IAAL,GAAYkC,SAAZ;AACAjI,MAAAA,IAAI,CAACkI,WAAL,GAAmB,CAAnB;AACH,KATD;AAUA,SAAKtH,iBAAL,GAAyBA,iBAAzB;AACA,SAAKK,cAAL,GAAsBA,cAAtB,CAhL+C,CAiL/C;;AACA,QAAIkH,SAAS,GAAG3G,cAAc,GAAGA,cAAc,CAACoB,KAAf,GAAuB,CAA1B,GAA8B,CAA5D;AACA,QAAIwF,KAAK,GAAG,EAAZ;;AACA,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,SAApB,EAA+BP,CAAC,EAAhC,EAAoC;AAChCQ,MAAAA,KAAK,CAAC3G,IAAN,CAAWmG,CAAX;AACH;;AACD,QAAIS,eAAe,GAAG,KAAKtH,iBAAL,CAAuBmC,OAAvB,CAA+BkF,KAA/B,CAAtB;AACAC,IAAAA,eAAe,CAACtD,IAAhB,CAAqB9B,MAArB;AACA,QAAIqF,cAAc,GAAGD,eAAe,CAACpD,KAAhB,CAAsBC,MAAtB,CAA6B9G,IAA7B,CAArB;AACA,QAAI2C,iBAAiB,GAAGsH,eAAe,CAAClD,KAAhB,CAAsBmD,cAAtB,CAAxB;AACA,SAAKvH,iBAAL,GAAyBA,iBAAzB;AACAA,IAAAA,iBAAiB,CAAC0E,IAAlB,CAAuB,UAAUzF,IAAV,EAAgBuI,CAAhB,EAAmB5C,KAAnB,EAA0B;AAC7C,UAAI9F,CAAC,GAAG8F,KAAK,GAAG,CAAR,GAAY,CAACH,iBAAD,GAAqBtG,KAAK,CAACiB,KAAN,CAAYuG,OAAZ,GAAsB,CAA3C,GAA+C,CAACf,KAAK,GAAG,CAAT,IAAcnD,UAAzE,GAAsF,CAA9F;AACAxC,MAAAA,IAAI,CAACmH,EAAL,GAAUtH,CAAV;AACAG,MAAAA,IAAI,CAACoH,EAAL,GAAUvH,CAAV;AACAG,MAAAA,IAAI,CAAC6H,EAAL,GAAUpH,cAAc,CAAC,CAAD,CAAxB;AACAT,MAAAA,IAAI,CAAC8H,EAAL,GAAUrH,cAAc,CAAC,CAAD,CAAxB;AACAT,MAAAA,IAAI,CAACkI,WAAL,GAAmBhJ,KAAK,CAACc,IAAN,CAAWC,KAA9B;AACAD,MAAAA,IAAI,CAAC+H,MAAL,GAAc7I,KAAK,CAACc,IAAN,CAAWE,KAAzB;AACAF,MAAAA,IAAI,CAACgE,OAAL,GAAeC,MAAM,CAAC5B,MAAP,GAAgB,CAAhB,KAAsBsD,KAAK,KAAK,CAAV,IAAgBiB,SAAS,IAAIvC,WAAnD,CAAf;AACH,KATD;;AAUA,QAAI,KAAKS,UAAT,EAAqB;AACjB,UAAI0D,QAAQ,GAAG,KAAKC,SAApB;AACA,UAAIC,YAAY,GAAGF,QAAQ,CAACnG,MAA5B;AACAzB,MAAAA,iBAAiB,CACZ6E,IADL,CACU,UAAUzF,IAAV,EAAgB0F,KAAhB,EAAuBC,KAAvB,EAA8B;AACpC,YAAI7F,CAAC,GAAG4C,IAAI,CAACiG,KAAL,CAAWlJ,SAAS,CAAC6C,OAAV,CAAkBoD,KAAlB,CAAX,CAAR;AACA1F,QAAAA,IAAI,CAACmH,EAAL,GAAU,CAAV;AACAnH,QAAAA,IAAI,CAACoH,EAAL,GAAU,CAAC9C,QAAD,GAAYpF,KAAK,CAAC4F,UAA5B;AACA9E,QAAAA,IAAI,CAAC6H,EAAL,GAAU/H,CAAV;AACAE,QAAAA,IAAI,CAAC8H,EAAL,GAAUhI,CAAV;AACAE,QAAAA,IAAI,CAACgE,OAAL,GAAelE,CAAC,IAAIW,cAAc,CAAC,CAAD,CAAnB,IAA0BX,CAAC,IAAIW,cAAc,CAAC,CAAD,CAA7C,IACXiC,IAAI,CAACC,GAAL,CAAS3C,IAAI,CAACgH,MAAL,CAAYnD,YAAZ,GAA2BT,UAApC,IAAkD,CADtD;AAEA,YAAIwF,KAAK,GAAGJ,QAAQ,CAAC7C,KAAK,GAAG+C,YAAT,CAApB;AACA1I,QAAAA,IAAI,CAAC+H,MAAL,GAAca,KAAK,CAACb,MAApB;AACA/H,QAAAA,IAAI,CAACkI,WAAL,GAAmBhJ,KAAK,CAAC8I,IAAN,CAAW/H,KAA9B;AACAD,QAAAA,IAAI,CAAC6I,QAAL,GAAgBD,KAAK,CAACC,QAAtB;AACA7I,QAAAA,IAAI,CAAC+F,IAAL,GAAYkC,SAAZ;AACH,OAdD;AAeH,KAxN8C,CAyN/C;AACA;AACA;AACA;AACA;AACA;AACA;;AACH,GAhOD;;AAiOA3I,EAAAA,mBAAmB,CAACtB,SAApB,CAA8BwI,WAA9B,GAA4C,UAAUsC,OAAV,EAAmB;AAC3D,QAAIC,YAAY,GAAG,CAACD,OAAD,IAAY,CAACA,OAAO,CAACE,YAAxC;AACA,QAAIC,IAAI,GAAGC,QAAX;AACA,QAAIC,KAAK,GAAG,CAACD,QAAb;AACA,QAAIE,GAAG,GAAGF,QAAV;AACA,QAAIG,MAAM,GAAG,CAACH,QAAd;AACA,SAAKjI,cAAL,CAAoBwE,IAApB,CAAyB,UAAUtF,KAAV,EAAiBoI,CAAjB,EAAoB5C,KAApB,EAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIA,KAAK,GAAG,CAAR,IAAaoD,YAAjB,EAA+B;AAAE;AAC7B5I,QAAAA,KAAK,CAACmJ,sBAAN;AACA,YAAIC,MAAM,GAAG9K,MAAM,CAAC+K,SAAP,CAAiBrJ,KAAK,CAACoJ,MAAvB,CAAb;AACA,YAAIE,SAAS,GAAGtJ,KAAK,CAACqG,WAAN,EAAhB;;AACA,YAAIiD,SAAJ,EAAe;AACX,cAAIlD,IAAI,GAAGgD,MAAM,CAACG,aAAP,CAAqBD,SAArB,CAAX;AACAR,UAAAA,IAAI,GAAGvG,IAAI,CAACG,GAAL,CAASoG,IAAT,EAAe1C,IAAI,CAAC1G,CAApB,CAAP;AACAsJ,UAAAA,KAAK,GAAGzG,IAAI,CAAC8E,GAAL,CAAS2B,KAAT,EAAgB5C,IAAI,CAAC1G,CAAL,GAAS0G,IAAI,CAACtG,KAA9B,CAAR;AACAmJ,UAAAA,GAAG,GAAG1G,IAAI,CAACG,GAAL,CAASuG,GAAT,EAAc7C,IAAI,CAACzG,CAAnB,CAAN;AACAuJ,UAAAA,MAAM,GAAG3G,IAAI,CAAC8E,GAAL,CAAS6B,MAAT,EAAiB9C,IAAI,CAACzG,CAAL,GAASyG,IAAI,CAACoD,MAA/B,CAAT;AACH;AACJ;AACJ,KAtBD;AAuBA,WAAO,IAAInL,IAAJ,CAASyK,IAAT,EAAeG,GAAf,EAAoB1G,IAAI,CAAC8E,GAAL,CAAS2B,KAAK,GAAGF,IAAjB,EAAuB,KAAKtJ,sBAA5B,CAApB,EAAyE0J,MAAM,GAAGD,GAAlF,CAAP;AACH,GA9BD,CA3VuD,CA0XvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9J,EAAAA,mBAAmB,CAACsK,SAApB,GAAgC,qBAAhC;AACAtK,EAAAA,mBAAmB,CAACuK,IAApB,GAA2B,iBAA3B;AACA,SAAOvK,mBAAP;AACH,CAtYwC,CAsYvCR,SAtYuC,CAAzC;;AAuYA,SAASQ,mBAAT","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Group } from \"../../scene/group\";\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\";\n// import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\nimport { createId } from \"../../util/id\";\nvar GroupedCategoryAxisLabel = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxisLabel, _super);\n    function GroupedCategoryAxisLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.grid = false;\n        return _this;\n    }\n    return GroupedCategoryAxisLabel;\n}(AxisLabel));\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar GroupedCategoryAxis = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxis, _super);\n    function GroupedCategoryAxis() {\n        var _this = _super.call(this, new BandScale()) || this;\n        _this.id = createId(_this);\n        _this.tickScale = new BandScale();\n        _this.group = new Group();\n        _this.longestSeparatorLength = 0;\n        _this.translation = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * Axis rotation angle in degrees.\n         */\n        _this.rotation = 0;\n        _this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        // readonly tick = new AxisTick();\n        _this.label = new GroupedCategoryAxisLabel();\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        _this.labelColor = 'rgba(87, 87, 87, 1)';\n        var _a = _this, group = _a.group, scale = _a.scale, tickScale = _a.tickScale;\n        scale.paddingOuter = 0.1;\n        scale.paddingInner = scale.paddingOuter * 2;\n        _this.requestedRange = scale.range.slice();\n        tickScale.paddingInner = 1;\n        tickScale.paddingOuter = 0;\n        _this.gridLineSelection = Selection.select(group).selectAll();\n        _this.axisLineSelection = Selection.select(group).selectAll();\n        _this.separatorSelection = Selection.select(group).selectAll();\n        _this.labelSelection = Selection.select(group).selectAll();\n        return _this;\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain;\n        },\n        set: function (value) {\n            this.scale.domain = value;\n            var tickTree = ticksToTree(value);\n            this.tickTreeLayout = treeLayout(tickTree);\n            var domain = value.slice();\n            domain.push('');\n            this.tickScale.domain = domain;\n            this.resizeTickTree();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GroupedCategoryAxis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        this.tickScale.range = scale.range = [start, start + span];\n        this.resizeTickTree();\n    };\n    GroupedCategoryAxis.prototype.resizeTickTree = function () {\n        var s = this.scale;\n        var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n        var layout = this.tickTreeLayout;\n        var lineHeight = this.lineHeight;\n        if (layout) {\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, (range[1] - range[0]) < 0);\n        }\n    };\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n        get: function () {\n            return this.label.fontSize * 1.5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         */\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n                this.labelSelection = this.labelSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    GroupedCategoryAxis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, label = _a.label, tickScale = _a.tickScale, requestedRange = _a.requestedRange;\n        var rangeStart = scale.range[0];\n        var rangeEnd = scale.range[1];\n        var rangeLength = Math.abs(rangeEnd - rangeStart);\n        var bandwidth = (rangeLength / scale.domain.length) || 0;\n        var parallelLabels = label.parallel;\n        var rotation = toRadians(this.rotation);\n        var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n        var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var title = this.title;\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n        // The phantom root of the tree layout is used instead.\n        if (title) {\n            title.node.visible = false;\n        }\n        var lineHeight = this.lineHeight;\n        // Render ticks and labels.\n        var tickTreeLayout = this.tickTreeLayout;\n        var labels = scale.ticks();\n        var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n        var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n        var ticks = tickScale.ticks();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, Ï€] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = (!labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI) ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = (!labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI) ? -1 : 1;\n        var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n        updateGridLines.exit.remove();\n        var enterGridLines = updateGridLines.enter.append(Line);\n        var gridLineSelection = updateGridLines.merge(enterGridLines);\n        var updateLabels = this.labelSelection.setData(treeLabels);\n        updateLabels.exit.remove();\n        var enterLabels = updateLabels.enter.append(Text);\n        var labelSelection = updateLabels.merge(enterLabels);\n        var labelFormatter = label.formatter;\n        var maxLeafLabelWidth = 0;\n        labelSelection\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n            // label.textBaseline = parallelLabels && !labelRotation\n            //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n            //     : 'middle';\n            node.textAlign = 'center';\n            node.translationX = datum.screenY - label.fontSize * 0.25;\n            node.translationY = datum.screenX;\n            if (index === 0) { // use the phantom root as the axis title\n                if (title && title.enabled && labels.length > 0) {\n                    node.visible = true;\n                    node.text = title.text;\n                    node.fontSize = title.fontSize;\n                    node.fontStyle = title.fontStyle;\n                    node.fontWeight = title.fontWeight;\n                    node.fontFamily = title.fontFamily;\n                    node.textBaseline = 'hanging';\n                }\n                else {\n                    node.visible = false;\n                }\n            }\n            else {\n                node.text = labelFormatter\n                    ? labelFormatter({\n                        value: String(datum.label),\n                        index: index\n                    })\n                    : String(datum.label);\n                node.visible =\n                    datum.screenX >= requestedRange[0] &&\n                        datum.screenX <= requestedRange[1];\n            }\n            var bbox = node.computeBBox();\n            if (bbox && bbox.width > maxLeafLabelWidth) {\n                maxLeafLabelWidth = bbox.width;\n            }\n        });\n        var labelX = sideFlag * label.padding;\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        var labelGrid = this.label.grid;\n        var separatorData = [];\n        labelSelection.each(function (label, datum, index) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            if (!datum.children.length) {\n                label.rotation = labelRotation;\n                label.textAlign = 'end';\n                label.textBaseline = 'middle';\n            }\n            else {\n                label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n                if (isHorizontal) {\n                    label.rotation = autoRotation;\n                }\n                else {\n                    label.rotation = -Math.PI / 2;\n                }\n            }\n            // Calculate positions of label separators for all nodes except the root.\n            // Each separator is placed to the top of the current label.\n            if (datum.parent && isLabelTree) {\n                var y = !datum.children.length\n                    ? datum.screenX - bandwidth / 2\n                    : datum.screenX - datum.leafCount * bandwidth / 2;\n                if (!datum.children.length) {\n                    if ((datum.number !== datum.children.length - 1) || labelGrid) {\n                        separatorData.push({\n                            y: y,\n                            x1: 0,\n                            x2: -maxLeafLabelWidth - _this.label.padding * 2,\n                            toString: function () { return String(index); }\n                        });\n                    }\n                }\n                else {\n                    var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n                    separatorData.push({\n                        y: y,\n                        x1: x + lineHeight,\n                        x2: x,\n                        toString: function () { return String(index); }\n                    });\n                }\n            }\n        });\n        // Calculate the position of the long separator on the far bottom of the axis.\n        var minX = 0;\n        separatorData.forEach(function (d) { return minX = Math.min(minX, d.x2); });\n        this.longestSeparatorLength = Math.abs(minX);\n        separatorData.push({\n            y: Math.max(rangeStart, rangeEnd),\n            x1: 0,\n            x2: minX,\n            toString: function () { return String(separatorData.length); }\n        });\n        var updateSeparators = this.separatorSelection.setData(separatorData);\n        updateSeparators.exit.remove();\n        var enterSeparators = updateSeparators.enter.append(Line);\n        var separatorSelection = updateSeparators.merge(enterSeparators);\n        this.separatorSelection = separatorSelection;\n        var epsilon = 0.0000001;\n        separatorSelection.each(function (line, datum, i) {\n            line.x1 = datum.x1;\n            line.x2 = datum.x2;\n            line.y1 = datum.y;\n            line.y2 = datum.y;\n            line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n            line.stroke = _this.tick.color;\n            line.fill = undefined;\n            line.strokeWidth = 1;\n        });\n        this.gridLineSelection = gridLineSelection;\n        this.labelSelection = labelSelection;\n        // Render axis lines.\n        var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n        var lines = [];\n        for (var i = 0; i < lineCount; i++) {\n            lines.push(i);\n        }\n        var updateAxisLines = this.axisLineSelection.setData(lines);\n        updateAxisLines.exit.remove();\n        var enterAxisLines = updateAxisLines.enter.append(Line);\n        var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n        this.axisLineSelection = axisLineSelection;\n        axisLineSelection.each(function (line, _, index) {\n            var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n            line.x1 = x;\n            line.x2 = x;\n            line.y1 = requestedRange[0];\n            line.y2 = requestedRange[1];\n            line.strokeWidth = _this.line.width;\n            line.stroke = _this.line.color;\n            line.visible = labels.length > 0 && (index === 0 || (labelGrid && isLabelTree));\n        });\n        if (this.gridLength) {\n            var styles_1 = this.gridStyle;\n            var styleCount_1 = styles_1.length;\n            gridLineSelection\n                .each(function (line, datum, index) {\n                var y = Math.round(tickScale.convert(datum));\n                line.x1 = 0;\n                line.x2 = -sideFlag * _this.gridLength;\n                line.y1 = y;\n                line.y2 = y;\n                line.visible = y >= requestedRange[0] && y <= requestedRange[1] &&\n                    Math.abs(line.parent.translationY - rangeStart) > 1;\n                var style = styles_1[index % styleCount_1];\n                line.stroke = style.stroke;\n                line.strokeWidth = _this.tick.width;\n                line.lineDash = style.lineDash;\n                line.fill = undefined;\n            });\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    GroupedCategoryAxis.prototype.computeBBox = function (options) {\n        var includeTitle = !options || !options.excludeTitle;\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        this.labelSelection.each(function (label, _, index) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            if (index > 0 || includeTitle) { // first node is the root (title)\n                label.computeTransformMatrix();\n                var matrix = Matrix.flyweight(label.matrix);\n                var labelBBox = label.computeBBox();\n                if (labelBBox) {\n                    var bbox = matrix.transformBBox(labelBBox);\n                    left = Math.min(left, bbox.x);\n                    right = Math.max(right, bbox.x + bbox.width);\n                    top = Math.min(top, bbox.y);\n                    bottom = Math.max(bottom, bbox.y + bbox.height);\n                }\n            }\n        });\n        return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n    };\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.7;\n    //     return rect;\n    // })();\n    GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n    GroupedCategoryAxis.type = 'groupedCategory';\n    return GroupedCategoryAxis;\n}(ChartAxis));\nexport { GroupedCategoryAxis };\n"]},"metadata":{},"sourceType":"module"}