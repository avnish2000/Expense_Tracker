{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Group } from \"../../../scene/group\";\nimport { Selection } from \"../../../scene/selection\";\nimport { PointerEvents } from \"../../../scene/node\";\nimport { Path } from \"../../../scene/shape/path\";\nimport { CartesianSeries, CartesianSeriesMarker } from \"./cartesianSeries\";\nimport { ChartAxisDirection } from \"../../chartAxis\";\nimport { getMarker } from \"../../marker/util\";\nimport { toTooltipHtml } from \"../../chart\";\nimport { findLargestMinMax, findMinMax } from \"../../../util/array\";\nimport { toFixed } from \"../../../util/number\";\nimport { equal } from \"../../../util/equal\";\nimport { reactive } from \"../../../util/observable\";\nimport { interpolate } from \"../../../util/string\";\n\nvar AreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(AreaSeries, _super);\n\n  function AreaSeries() {\n    var _this = _super.call(this) || this;\n\n    _this.areaGroup = _this.group.appendChild(new Group());\n    _this.strokeGroup = _this.group.appendChild(new Group());\n    _this.markerGroup = _this.group.appendChild(new Group());\n    _this.areaSelection = Selection.select(_this.areaGroup).selectAll();\n    _this.strokeSelection = Selection.select(_this.strokeGroup).selectAll();\n    _this.markerSelection = Selection.select(_this.markerGroup).selectAll();\n    _this.markerSelectionData = [];\n    /**\n     * The assumption is that the values will be reset (to `true`)\n     * in the {@link yKeys} setter.\n     */\n\n    _this.seriesItemEnabled = new Map();\n    _this.xData = [];\n    _this.yData = [];\n    _this.yDomain = [];\n    _this.directionKeys = {\n      x: ['xKey'],\n      y: ['yKeys']\n    };\n    _this.marker = new CartesianSeriesMarker();\n    _this.fills = ['#c16068', '#a2bf8a', '#ebcc87', '#80a0c3', '#b58dae', '#85c0d1'];\n    _this.strokes = ['#874349', '#718661', '#a48f5f', '#5a7088', '#7f637a', '#5d8692'];\n    _this.fillOpacity = 1;\n    _this.strokeOpacity = 1;\n    _this.lineDash = undefined;\n    _this.lineDashOffset = 0;\n    _this._xKey = '';\n    _this.xName = '';\n    _this._yKeys = [];\n    _this.yNames = [];\n    _this.strokeWidth = 2;\n    _this.highlightStyle = {\n      fill: 'yellow'\n    };\n\n    _this.addEventListener('update', _this.update);\n\n    _this.marker.enabled = false;\n\n    _this.marker.addPropertyListener('shape', _this.onMarkerShapeChange, _this);\n\n    _this.marker.addEventListener('change', _this.update, _this);\n\n    return _this;\n  }\n\n  AreaSeries.prototype.onMarkerShapeChange = function () {\n    this.markerSelection = this.markerSelection.setData([]);\n    this.markerSelection.exit.remove();\n    this.update();\n    this.fireEvent({\n      type: 'legendChange'\n    });\n  };\n\n  Object.defineProperty(AreaSeries.prototype, \"xKey\", {\n    get: function () {\n      return this._xKey;\n    },\n    set: function (value) {\n      if (this._xKey !== value) {\n        this._xKey = value;\n        this.xData = [];\n        this.scheduleData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AreaSeries.prototype, \"yKeys\", {\n    get: function () {\n      return this._yKeys;\n    },\n    set: function (values) {\n      if (!equal(this._yKeys, values)) {\n        this._yKeys = values;\n        this.yData = [];\n        var seriesItemEnabled_1 = this.seriesItemEnabled;\n        seriesItemEnabled_1.clear();\n        values.forEach(function (key) {\n          return seriesItemEnabled_1.set(key, true);\n        });\n        this.scheduleData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AreaSeries.prototype.setColors = function (fills, strokes) {\n    this.fills = fills;\n    this.strokes = strokes;\n  };\n\n  Object.defineProperty(AreaSeries.prototype, \"normalizedTo\", {\n    get: function () {\n      return this._normalizedTo;\n    },\n    set: function (value) {\n      var absValue = value ? Math.abs(value) : undefined;\n\n      if (this._normalizedTo !== absValue) {\n        this._normalizedTo = absValue;\n        this.scheduleData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AreaSeries.prototype.onHighlightChange = function () {\n    this.updateMarkerNodes();\n  };\n\n  AreaSeries.prototype.processData = function () {\n    var _a = this,\n        xKey = _a.xKey,\n        yKeys = _a.yKeys,\n        seriesItemEnabled = _a.seriesItemEnabled;\n\n    var data = xKey && yKeys.length && this.data ? this.data : []; // if (!(chart && chart.xAxis && chart.yAxis)) {\n    //     return false;\n    // }\n    // If the data is an array of rows like so:\n    //\n    // [{\n    //   xKy: 'Jan',\n    //   yKey1: 5,\n    //   yKey2: 7,\n    //   yKey3: -9,\n    // }, {\n    //   xKey: 'Feb',\n    //   yKey1: 10,\n    //   yKey2: -15,\n    //   yKey3: 20\n    // }]\n    //\n\n    var keysFound = true; // only warn once\n\n    this.xData = data.map(function (datum) {\n      if (keysFound && !(xKey in datum)) {\n        keysFound = false;\n        console.warn(\"The key '\" + xKey + \"' was not found in the data: \", datum);\n      }\n\n      return datum[xKey];\n    });\n    this.yData = data.map(function (datum) {\n      return yKeys.map(function (yKey) {\n        if (keysFound && !(yKey in datum)) {\n          keysFound = false;\n          console.warn(\"The key '\" + yKey + \"' was not found in the data: \", datum);\n        }\n\n        var value = datum[yKey];\n        return isFinite(value) && seriesItemEnabled.get(yKey) ? value : 0;\n      });\n    }); // xData: ['Jan', 'Feb']\n    //\n    // yData: [\n    //   [5, 7, -9],\n    //   [10, -15, 20]\n    // ]\n\n    var _b = this,\n        yData = _b.yData,\n        normalizedTo = _b.normalizedTo;\n\n    var yMinMax = yData.map(function (values) {\n      return findMinMax(values);\n    }); // used for normalization\n\n    var yLargestMinMax = findLargestMinMax(yMinMax);\n    var yMin;\n    var yMax;\n\n    if (normalizedTo && isFinite(normalizedTo)) {\n      yMin = yLargestMinMax.min < 0 ? -normalizedTo : 0;\n      yMax = normalizedTo;\n      yData.forEach(function (stack, i) {\n        return stack.forEach(function (y, j) {\n          if (y < 0) {\n            stack[j] = -y / yMinMax[i].min * normalizedTo;\n          } else {\n            stack[j] = y / yMinMax[i].max * normalizedTo;\n          }\n        });\n      });\n    } else {\n      yMin = yLargestMinMax.min;\n      yMax = yLargestMinMax.max;\n    }\n\n    if (yMin === 0 && yMax === 0) {\n      yMax = 1;\n    }\n\n    this.yDomain = this.fixNumericExtent([yMin, yMax], 'y');\n    this.fireEvent({\n      type: 'dataProcessed'\n    });\n    return true;\n  };\n\n  AreaSeries.prototype.getDomain = function (direction) {\n    if (direction === ChartAxisDirection.X) {\n      return this.xData;\n    } else {\n      return this.yDomain;\n    }\n  };\n\n  AreaSeries.prototype.update = function () {\n    var _a = this,\n        visible = _a.visible,\n        chart = _a.chart,\n        xAxis = _a.xAxis,\n        yAxis = _a.yAxis,\n        xData = _a.xData,\n        yData = _a.yData;\n\n    this.group.visible = visible && !!(xData.length && yData.length);\n\n    if (!xAxis || !yAxis || !visible || !chart || chart.layoutPending || chart.dataPending || !xData.length || !yData.length) {\n      return;\n    }\n\n    var selectionData = this.generateSelectionData();\n\n    if (!selectionData) {\n      return;\n    }\n\n    var areaSelectionData = selectionData.areaSelectionData,\n        markerSelectionData = selectionData.markerSelectionData;\n    this.updateAreaSelection(areaSelectionData);\n    this.updateStrokeSelection(areaSelectionData);\n    this.updateMarkerSelection(markerSelectionData);\n    this.updateMarkerNodes();\n    this.markerSelectionData = markerSelectionData;\n  };\n\n  AreaSeries.prototype.generateSelectionData = function () {\n    var _this = this;\n\n    if (!this.data) {\n      return;\n    }\n\n    var _a = this,\n        yKeys = _a.yKeys,\n        data = _a.data,\n        xData = _a.xData,\n        yData = _a.yData,\n        marker = _a.marker,\n        fills = _a.fills,\n        strokes = _a.strokes,\n        xScale = _a.xAxis.scale,\n        yScale = _a.yAxis.scale;\n\n    var xOffset = (xScale.bandwidth || 0) / 2;\n    var yOffset = (yScale.bandwidth || 0) / 2;\n    var areaSelectionData = [];\n    var markerSelectionData = [];\n    var last = xData.length * 2 - 1;\n    xData.forEach(function (xDatum, i) {\n      var yDatum = yData[i];\n      var seriesDatum = data[i];\n      var x = xScale.convert(xDatum) + xOffset;\n      var prevMin = 0;\n      var prevMax = 0;\n      yDatum.forEach(function (curr, j) {\n        var prev = curr < 0 ? prevMin : prevMax;\n        var y = yScale.convert(prev + curr) + yOffset;\n        var yKey = yKeys[j];\n        var yValue = seriesDatum[yKey];\n\n        if (marker) {\n          markerSelectionData.push({\n            series: _this,\n            seriesDatum: seriesDatum,\n            yValue: yValue,\n            yKey: yKey,\n            point: {\n              x: x,\n              y: y\n            },\n            fill: fills[j % fills.length],\n            stroke: strokes[j % strokes.length]\n          });\n        }\n\n        var areaDatum = areaSelectionData[j] || (areaSelectionData[j] = {\n          yKey: yKey,\n          points: []\n        });\n        var areaPoints = areaDatum.points;\n        areaPoints[i] = {\n          x: x,\n          y: y\n        };\n        areaPoints[last - i] = {\n          x: x,\n          y: yScale.convert(prev) + yOffset\n        }; // bottom y\n\n        if (curr < 0) {\n          prevMin += curr;\n        } else {\n          prevMax += curr;\n        }\n      });\n    });\n    return {\n      areaSelectionData: areaSelectionData,\n      markerSelectionData: markerSelectionData\n    };\n  };\n\n  AreaSeries.prototype.updateAreaSelection = function (areaSelectionData) {\n    var _this = this;\n\n    var _a = this,\n        fills = _a.fills,\n        fillOpacity = _a.fillOpacity,\n        strokes = _a.strokes,\n        strokeOpacity = _a.strokeOpacity,\n        strokeWidth = _a.strokeWidth,\n        seriesItemEnabled = _a.seriesItemEnabled,\n        shadow = _a.shadow;\n\n    var updateAreas = this.areaSelection.setData(areaSelectionData);\n    updateAreas.exit.remove();\n    var enterAreas = updateAreas.enter.append(Path).each(function (path) {\n      path.lineJoin = 'round';\n      path.stroke = undefined;\n      path.pointerEvents = PointerEvents.None;\n    });\n    var areaSelection = updateAreas.merge(enterAreas);\n    areaSelection.each(function (shape, datum, index) {\n      var path = shape.path;\n      shape.fill = fills[index % fills.length];\n      shape.fillOpacity = fillOpacity;\n      shape.stroke = strokes[index % strokes.length];\n      shape.strokeOpacity = strokeOpacity;\n      shape.strokeWidth = strokeWidth;\n      shape.lineDash = _this.lineDash;\n      shape.lineDashOffset = _this.lineDashOffset;\n      shape.fillShadow = shadow;\n      shape.visible = !!seriesItemEnabled.get(datum.yKey);\n      path.clear();\n      var points = datum.points;\n      points.forEach(function (_a, i) {\n        var x = _a.x,\n            y = _a.y;\n\n        if (i > 0) {\n          path.lineTo(x, y);\n        } else {\n          path.moveTo(x, y);\n        }\n      });\n      path.closePath();\n    });\n    this.areaSelection = areaSelection;\n  };\n\n  AreaSeries.prototype.updateStrokeSelection = function (areaSelectionData) {\n    var _this = this;\n\n    if (!this.data) {\n      return;\n    }\n\n    var _a = this,\n        strokes = _a.strokes,\n        strokeWidth = _a.strokeWidth,\n        strokeOpacity = _a.strokeOpacity,\n        data = _a.data,\n        seriesItemEnabled = _a.seriesItemEnabled;\n\n    var updateStrokes = this.strokeSelection.setData(areaSelectionData);\n    updateStrokes.exit.remove();\n    var enterStrokes = updateStrokes.enter.append(Path).each(function (path) {\n      path.fill = undefined;\n      path.lineJoin = path.lineCap = 'round';\n      path.pointerEvents = PointerEvents.None;\n    });\n    var strokeSelection = updateStrokes.merge(enterStrokes);\n    strokeSelection.each(function (shape, datum, index) {\n      var path = shape.path;\n      shape.stroke = strokes[index % strokes.length];\n      shape.strokeWidth = strokeWidth;\n      shape.visible = !!seriesItemEnabled.get(datum.yKey);\n      shape.strokeOpacity = strokeOpacity;\n      shape.lineDash = _this.lineDash;\n      shape.lineDashOffset = _this.lineDashOffset;\n      path.clear();\n      var points = datum.points; // The stroke doesn't go all the way around the fill, only on top,\n      // that's why we iterate until `data.length` (rather than `points.length`) and stop.\n\n      for (var i = 0; i < data.length; i++) {\n        var _a = points[i],\n            x = _a.x,\n            y = _a.y;\n\n        if (i > 0) {\n          path.lineTo(x, y);\n        } else {\n          path.moveTo(x, y);\n        }\n      }\n    });\n    this.strokeSelection = strokeSelection;\n  };\n\n  AreaSeries.prototype.updateMarkerSelection = function (markerSelectionData) {\n    var marker = this.marker;\n    var data = marker.shape ? markerSelectionData : [];\n    var MarkerShape = getMarker(marker.shape);\n    var updateMarkers = this.markerSelection.setData(data);\n    updateMarkers.exit.remove();\n    var enterMarkers = updateMarkers.enter.append(MarkerShape);\n    this.markerSelection = updateMarkers.merge(enterMarkers);\n  };\n\n  AreaSeries.prototype.updateMarkerNodes = function () {\n    if (!this.chart) {\n      return;\n    }\n\n    var marker = this.marker;\n    var markerFormatter = marker.formatter;\n    var markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : this.strokeWidth;\n    var markerSize = marker.size;\n\n    var _a = this,\n        xKey = _a.xKey,\n        seriesItemEnabled = _a.seriesItemEnabled;\n\n    var highlightedDatum = this.chart.highlightedDatum;\n    var _b = this.highlightStyle,\n        highlightFill = _b.fill,\n        highlightStroke = _b.stroke;\n    this.markerSelection.each(function (node, datum) {\n      var highlighted = datum === highlightedDatum;\n      var markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill || datum.fill;\n      var markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || datum.stroke;\n      var markerFormat = undefined;\n\n      if (markerFormatter) {\n        markerFormat = markerFormatter({\n          datum: datum.seriesDatum,\n          xKey: xKey,\n          yKey: datum.yKey,\n          fill: markerFill,\n          stroke: markerStroke,\n          strokeWidth: markerStrokeWidth,\n          size: markerSize,\n          highlighted: highlighted\n        });\n      }\n\n      node.fill = markerFormat && markerFormat.fill || markerFill;\n      node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n      node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined ? markerFormat.strokeWidth : markerStrokeWidth;\n      node.size = markerFormat && markerFormat.size !== undefined ? markerFormat.size : markerSize;\n      node.translationX = datum.point.x;\n      node.translationY = datum.point.y;\n      node.visible = marker.enabled && node.size > 0 && !!seriesItemEnabled.get(datum.yKey);\n    });\n  };\n\n  AreaSeries.prototype.getNodeData = function () {\n    return this.markerSelectionData;\n  };\n\n  AreaSeries.prototype.fireNodeClickEvent = function (datum) {\n    this.fireEvent({\n      type: 'nodeClick',\n      series: this,\n      datum: datum.seriesDatum,\n      xKey: this.xKey,\n      yKey: datum.yKey\n    });\n  };\n\n  AreaSeries.prototype.getTooltipHtml = function (nodeDatum) {\n    var xKey = this.xKey;\n    var yKey = nodeDatum.yKey;\n\n    if (!xKey || !yKey) {\n      return '';\n    }\n\n    var _a = this,\n        xName = _a.xName,\n        yKeys = _a.yKeys,\n        yNames = _a.yNames,\n        fills = _a.fills,\n        tooltipFormat = _a.tooltipFormat,\n        tooltipRenderer = _a.tooltipRenderer;\n\n    var datum = nodeDatum.seriesDatum;\n    var xValue = datum[xKey];\n    var yValue = datum[yKey];\n    var yKeyIndex = yKeys.indexOf(yKey);\n    var yName = yNames[yKeyIndex];\n    var color = fills[yKeyIndex % fills.length];\n    var xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n    var yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n    var title = yName;\n    var content = xString + ': ' + yString;\n    var defaults = {\n      title: title,\n      titleBackgroundColor: color,\n      content: content\n    };\n\n    if (tooltipFormat || tooltipRenderer) {\n      var params = {\n        datum: datum,\n        xKey: xKey,\n        xName: xName,\n        xValue: xValue,\n        yKey: yKey,\n        yValue: yValue,\n        yName: yName,\n        color: color\n      };\n\n      if (tooltipFormat) {\n        return toTooltipHtml({\n          content: interpolate(tooltipFormat, params)\n        }, defaults);\n      }\n\n      if (tooltipRenderer) {\n        return toTooltipHtml(tooltipRenderer(params), defaults);\n      }\n    }\n\n    return toTooltipHtml(defaults);\n  };\n\n  AreaSeries.prototype.listSeriesItems = function (legendData) {\n    var _a = this,\n        data = _a.data,\n        id = _a.id,\n        xKey = _a.xKey,\n        yKeys = _a.yKeys,\n        yNames = _a.yNames,\n        seriesItemEnabled = _a.seriesItemEnabled,\n        marker = _a.marker,\n        fills = _a.fills,\n        strokes = _a.strokes,\n        fillOpacity = _a.fillOpacity,\n        strokeOpacity = _a.strokeOpacity;\n\n    if (data && data.length && xKey && yKeys.length) {\n      yKeys.forEach(function (yKey, index) {\n        legendData.push({\n          id: id,\n          itemId: yKey,\n          enabled: seriesItemEnabled.get(yKey) || false,\n          label: {\n            text: yNames[index] || yKeys[index]\n          },\n          marker: {\n            shape: marker.shape,\n            fill: marker.fill || fills[index % fills.length],\n            stroke: marker.stroke || strokes[index % strokes.length],\n            fillOpacity: fillOpacity,\n            strokeOpacity: strokeOpacity\n          }\n        });\n      });\n    }\n  };\n\n  AreaSeries.prototype.toggleSeriesItem = function (itemId, enabled) {\n    this.seriesItemEnabled.set(itemId, enabled);\n    this.scheduleData();\n  };\n\n  AreaSeries.className = 'AreaSeries';\n  AreaSeries.type = 'area';\n\n  __decorate([reactive('dataChange')], AreaSeries.prototype, \"fills\", void 0);\n\n  __decorate([reactive('dataChange')], AreaSeries.prototype, \"strokes\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"fillOpacity\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"strokeOpacity\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"lineDash\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"lineDashOffset\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"xName\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"yNames\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"strokeWidth\", void 0);\n\n  __decorate([reactive('update')], AreaSeries.prototype, \"shadow\", void 0);\n\n  return AreaSeries;\n}(CartesianSeries);\n\nexport { AreaSeries };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/chart/series/cartesian/areaSeries.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Group","Selection","PointerEvents","Path","CartesianSeries","CartesianSeriesMarker","ChartAxisDirection","getMarker","toTooltipHtml","findLargestMinMax","findMinMax","toFixed","equal","reactive","interpolate","AreaSeries","_super","_this","call","areaGroup","group","appendChild","strokeGroup","markerGroup","areaSelection","select","selectAll","strokeSelection","markerSelection","markerSelectionData","seriesItemEnabled","Map","xData","yData","yDomain","directionKeys","x","y","marker","fills","strokes","fillOpacity","strokeOpacity","lineDash","undefined","lineDashOffset","_xKey","xName","_yKeys","yNames","strokeWidth","highlightStyle","fill","addEventListener","update","enabled","addPropertyListener","onMarkerShapeChange","setData","exit","remove","fireEvent","type","get","set","value","scheduleData","enumerable","configurable","values","seriesItemEnabled_1","clear","forEach","setColors","_normalizedTo","absValue","Math","abs","onHighlightChange","updateMarkerNodes","processData","_a","xKey","yKeys","data","keysFound","map","datum","console","warn","yKey","isFinite","_b","normalizedTo","yMinMax","yLargestMinMax","yMin","yMax","min","stack","j","max","fixNumericExtent","getDomain","direction","X","visible","chart","xAxis","yAxis","layoutPending","dataPending","selectionData","generateSelectionData","areaSelectionData","updateAreaSelection","updateStrokeSelection","updateMarkerSelection","xScale","scale","yScale","xOffset","bandwidth","yOffset","last","xDatum","yDatum","seriesDatum","convert","prevMin","prevMax","curr","prev","yValue","push","series","point","stroke","areaDatum","points","areaPoints","shadow","updateAreas","enterAreas","enter","append","each","path","lineJoin","pointerEvents","None","merge","shape","index","fillShadow","lineTo","moveTo","closePath","updateStrokes","enterStrokes","lineCap","MarkerShape","updateMarkers","enterMarkers","markerFormatter","formatter","markerStrokeWidth","markerSize","size","highlightedDatum","highlightFill","highlightStroke","node","highlighted","markerFill","markerStroke","markerFormat","translationX","translationY","getNodeData","fireNodeClickEvent","getTooltipHtml","nodeDatum","tooltipFormat","tooltipRenderer","xValue","yKeyIndex","indexOf","yName","color","xString","String","yString","title","content","defaults","titleBackgroundColor","params","listSeriesItems","legendData","id","itemId","label","text","toggleSeriesItem","className"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Group } from \"../../../scene/group\";\nimport { Selection } from \"../../../scene/selection\";\nimport { PointerEvents } from \"../../../scene/node\";\nimport { Path } from \"../../../scene/shape/path\";\nimport { CartesianSeries, CartesianSeriesMarker } from \"./cartesianSeries\";\nimport { ChartAxisDirection } from \"../../chartAxis\";\nimport { getMarker } from \"../../marker/util\";\nimport { toTooltipHtml } from \"../../chart\";\nimport { findLargestMinMax, findMinMax } from \"../../../util/array\";\nimport { toFixed } from \"../../../util/number\";\nimport { equal } from \"../../../util/equal\";\nimport { reactive } from \"../../../util/observable\";\nimport { interpolate } from \"../../../util/string\";\nvar AreaSeries = /** @class */ (function (_super) {\n    __extends(AreaSeries, _super);\n    function AreaSeries() {\n        var _this = _super.call(this) || this;\n        _this.areaGroup = _this.group.appendChild(new Group);\n        _this.strokeGroup = _this.group.appendChild(new Group);\n        _this.markerGroup = _this.group.appendChild(new Group);\n        _this.areaSelection = Selection.select(_this.areaGroup).selectAll();\n        _this.strokeSelection = Selection.select(_this.strokeGroup).selectAll();\n        _this.markerSelection = Selection.select(_this.markerGroup).selectAll();\n        _this.markerSelectionData = [];\n        /**\n         * The assumption is that the values will be reset (to `true`)\n         * in the {@link yKeys} setter.\n         */\n        _this.seriesItemEnabled = new Map();\n        _this.xData = [];\n        _this.yData = [];\n        _this.yDomain = [];\n        _this.directionKeys = {\n            x: ['xKey'],\n            y: ['yKeys']\n        };\n        _this.marker = new CartesianSeriesMarker();\n        _this.fills = [\n            '#c16068',\n            '#a2bf8a',\n            '#ebcc87',\n            '#80a0c3',\n            '#b58dae',\n            '#85c0d1'\n        ];\n        _this.strokes = [\n            '#874349',\n            '#718661',\n            '#a48f5f',\n            '#5a7088',\n            '#7f637a',\n            '#5d8692'\n        ];\n        _this.fillOpacity = 1;\n        _this.strokeOpacity = 1;\n        _this.lineDash = undefined;\n        _this.lineDashOffset = 0;\n        _this._xKey = '';\n        _this.xName = '';\n        _this._yKeys = [];\n        _this.yNames = [];\n        _this.strokeWidth = 2;\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.addEventListener('update', _this.update);\n        _this.marker.enabled = false;\n        _this.marker.addPropertyListener('shape', _this.onMarkerShapeChange, _this);\n        _this.marker.addEventListener('change', _this.update, _this);\n        return _this;\n    }\n    AreaSeries.prototype.onMarkerShapeChange = function () {\n        this.markerSelection = this.markerSelection.setData([]);\n        this.markerSelection.exit.remove();\n        this.update();\n        this.fireEvent({ type: 'legendChange' });\n    };\n    Object.defineProperty(AreaSeries.prototype, \"xKey\", {\n        get: function () {\n            return this._xKey;\n        },\n        set: function (value) {\n            if (this._xKey !== value) {\n                this._xKey = value;\n                this.xData = [];\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AreaSeries.prototype, \"yKeys\", {\n        get: function () {\n            return this._yKeys;\n        },\n        set: function (values) {\n            if (!equal(this._yKeys, values)) {\n                this._yKeys = values;\n                this.yData = [];\n                var seriesItemEnabled_1 = this.seriesItemEnabled;\n                seriesItemEnabled_1.clear();\n                values.forEach(function (key) { return seriesItemEnabled_1.set(key, true); });\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AreaSeries.prototype.setColors = function (fills, strokes) {\n        this.fills = fills;\n        this.strokes = strokes;\n    };\n    Object.defineProperty(AreaSeries.prototype, \"normalizedTo\", {\n        get: function () {\n            return this._normalizedTo;\n        },\n        set: function (value) {\n            var absValue = value ? Math.abs(value) : undefined;\n            if (this._normalizedTo !== absValue) {\n                this._normalizedTo = absValue;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AreaSeries.prototype.onHighlightChange = function () {\n        this.updateMarkerNodes();\n    };\n    AreaSeries.prototype.processData = function () {\n        var _a = this, xKey = _a.xKey, yKeys = _a.yKeys, seriesItemEnabled = _a.seriesItemEnabled;\n        var data = xKey && yKeys.length && this.data ? this.data : [];\n        // if (!(chart && chart.xAxis && chart.yAxis)) {\n        //     return false;\n        // }\n        // If the data is an array of rows like so:\n        //\n        // [{\n        //   xKy: 'Jan',\n        //   yKey1: 5,\n        //   yKey2: 7,\n        //   yKey3: -9,\n        // }, {\n        //   xKey: 'Feb',\n        //   yKey1: 10,\n        //   yKey2: -15,\n        //   yKey3: 20\n        // }]\n        //\n        var keysFound = true; // only warn once\n        this.xData = data.map(function (datum) {\n            if (keysFound && !(xKey in datum)) {\n                keysFound = false;\n                console.warn(\"The key '\" + xKey + \"' was not found in the data: \", datum);\n            }\n            return datum[xKey];\n        });\n        this.yData = data.map(function (datum) { return yKeys.map(function (yKey) {\n            if (keysFound && !(yKey in datum)) {\n                keysFound = false;\n                console.warn(\"The key '\" + yKey + \"' was not found in the data: \", datum);\n            }\n            var value = datum[yKey];\n            return isFinite(value) && seriesItemEnabled.get(yKey) ? value : 0;\n        }); });\n        // xData: ['Jan', 'Feb']\n        //\n        // yData: [\n        //   [5, 7, -9],\n        //   [10, -15, 20]\n        // ]\n        var _b = this, yData = _b.yData, normalizedTo = _b.normalizedTo;\n        var yMinMax = yData.map(function (values) { return findMinMax(values); }); // used for normalization\n        var yLargestMinMax = findLargestMinMax(yMinMax);\n        var yMin;\n        var yMax;\n        if (normalizedTo && isFinite(normalizedTo)) {\n            yMin = yLargestMinMax.min < 0 ? -normalizedTo : 0;\n            yMax = normalizedTo;\n            yData.forEach(function (stack, i) { return stack.forEach(function (y, j) {\n                if (y < 0) {\n                    stack[j] = -y / yMinMax[i].min * normalizedTo;\n                }\n                else {\n                    stack[j] = y / yMinMax[i].max * normalizedTo;\n                }\n            }); });\n        }\n        else {\n            yMin = yLargestMinMax.min;\n            yMax = yLargestMinMax.max;\n        }\n        if (yMin === 0 && yMax === 0) {\n            yMax = 1;\n        }\n        this.yDomain = this.fixNumericExtent([yMin, yMax], 'y');\n        this.fireEvent({ type: 'dataProcessed' });\n        return true;\n    };\n    AreaSeries.prototype.getDomain = function (direction) {\n        if (direction === ChartAxisDirection.X) {\n            return this.xData;\n        }\n        else {\n            return this.yDomain;\n        }\n    };\n    AreaSeries.prototype.update = function () {\n        var _a = this, visible = _a.visible, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis, xData = _a.xData, yData = _a.yData;\n        this.group.visible = visible && !!(xData.length && yData.length);\n        if (!xAxis || !yAxis || !visible || !chart || chart.layoutPending || chart.dataPending || !xData.length || !yData.length) {\n            return;\n        }\n        var selectionData = this.generateSelectionData();\n        if (!selectionData) {\n            return;\n        }\n        var areaSelectionData = selectionData.areaSelectionData, markerSelectionData = selectionData.markerSelectionData;\n        this.updateAreaSelection(areaSelectionData);\n        this.updateStrokeSelection(areaSelectionData);\n        this.updateMarkerSelection(markerSelectionData);\n        this.updateMarkerNodes();\n        this.markerSelectionData = markerSelectionData;\n    };\n    AreaSeries.prototype.generateSelectionData = function () {\n        var _this = this;\n        if (!this.data) {\n            return;\n        }\n        var _a = this, yKeys = _a.yKeys, data = _a.data, xData = _a.xData, yData = _a.yData, marker = _a.marker, fills = _a.fills, strokes = _a.strokes, xScale = _a.xAxis.scale, yScale = _a.yAxis.scale;\n        var xOffset = (xScale.bandwidth || 0) / 2;\n        var yOffset = (yScale.bandwidth || 0) / 2;\n        var areaSelectionData = [];\n        var markerSelectionData = [];\n        var last = xData.length * 2 - 1;\n        xData.forEach(function (xDatum, i) {\n            var yDatum = yData[i];\n            var seriesDatum = data[i];\n            var x = xScale.convert(xDatum) + xOffset;\n            var prevMin = 0;\n            var prevMax = 0;\n            yDatum.forEach(function (curr, j) {\n                var prev = curr < 0 ? prevMin : prevMax;\n                var y = yScale.convert(prev + curr) + yOffset;\n                var yKey = yKeys[j];\n                var yValue = seriesDatum[yKey];\n                if (marker) {\n                    markerSelectionData.push({\n                        series: _this,\n                        seriesDatum: seriesDatum,\n                        yValue: yValue,\n                        yKey: yKey,\n                        point: { x: x, y: y },\n                        fill: fills[j % fills.length],\n                        stroke: strokes[j % strokes.length]\n                    });\n                }\n                var areaDatum = areaSelectionData[j] || (areaSelectionData[j] = { yKey: yKey, points: [] });\n                var areaPoints = areaDatum.points;\n                areaPoints[i] = { x: x, y: y };\n                areaPoints[last - i] = { x: x, y: yScale.convert(prev) + yOffset }; // bottom y\n                if (curr < 0) {\n                    prevMin += curr;\n                }\n                else {\n                    prevMax += curr;\n                }\n            });\n        });\n        return { areaSelectionData: areaSelectionData, markerSelectionData: markerSelectionData };\n    };\n    AreaSeries.prototype.updateAreaSelection = function (areaSelectionData) {\n        var _this = this;\n        var _a = this, fills = _a.fills, fillOpacity = _a.fillOpacity, strokes = _a.strokes, strokeOpacity = _a.strokeOpacity, strokeWidth = _a.strokeWidth, seriesItemEnabled = _a.seriesItemEnabled, shadow = _a.shadow;\n        var updateAreas = this.areaSelection.setData(areaSelectionData);\n        updateAreas.exit.remove();\n        var enterAreas = updateAreas.enter.append(Path)\n            .each(function (path) {\n            path.lineJoin = 'round';\n            path.stroke = undefined;\n            path.pointerEvents = PointerEvents.None;\n        });\n        var areaSelection = updateAreas.merge(enterAreas);\n        areaSelection.each(function (shape, datum, index) {\n            var path = shape.path;\n            shape.fill = fills[index % fills.length];\n            shape.fillOpacity = fillOpacity;\n            shape.stroke = strokes[index % strokes.length];\n            shape.strokeOpacity = strokeOpacity;\n            shape.strokeWidth = strokeWidth;\n            shape.lineDash = _this.lineDash;\n            shape.lineDashOffset = _this.lineDashOffset;\n            shape.fillShadow = shadow;\n            shape.visible = !!seriesItemEnabled.get(datum.yKey);\n            path.clear();\n            var points = datum.points;\n            points.forEach(function (_a, i) {\n                var x = _a.x, y = _a.y;\n                if (i > 0) {\n                    path.lineTo(x, y);\n                }\n                else {\n                    path.moveTo(x, y);\n                }\n            });\n            path.closePath();\n        });\n        this.areaSelection = areaSelection;\n    };\n    AreaSeries.prototype.updateStrokeSelection = function (areaSelectionData) {\n        var _this = this;\n        if (!this.data) {\n            return;\n        }\n        var _a = this, strokes = _a.strokes, strokeWidth = _a.strokeWidth, strokeOpacity = _a.strokeOpacity, data = _a.data, seriesItemEnabled = _a.seriesItemEnabled;\n        var updateStrokes = this.strokeSelection.setData(areaSelectionData);\n        updateStrokes.exit.remove();\n        var enterStrokes = updateStrokes.enter.append(Path)\n            .each(function (path) {\n            path.fill = undefined;\n            path.lineJoin = path.lineCap = 'round';\n            path.pointerEvents = PointerEvents.None;\n        });\n        var strokeSelection = updateStrokes.merge(enterStrokes);\n        strokeSelection.each(function (shape, datum, index) {\n            var path = shape.path;\n            shape.stroke = strokes[index % strokes.length];\n            shape.strokeWidth = strokeWidth;\n            shape.visible = !!seriesItemEnabled.get(datum.yKey);\n            shape.strokeOpacity = strokeOpacity;\n            shape.lineDash = _this.lineDash;\n            shape.lineDashOffset = _this.lineDashOffset;\n            path.clear();\n            var points = datum.points;\n            // The stroke doesn't go all the way around the fill, only on top,\n            // that's why we iterate until `data.length` (rather than `points.length`) and stop.\n            for (var i = 0; i < data.length; i++) {\n                var _a = points[i], x = _a.x, y = _a.y;\n                if (i > 0) {\n                    path.lineTo(x, y);\n                }\n                else {\n                    path.moveTo(x, y);\n                }\n            }\n        });\n        this.strokeSelection = strokeSelection;\n    };\n    AreaSeries.prototype.updateMarkerSelection = function (markerSelectionData) {\n        var marker = this.marker;\n        var data = marker.shape ? markerSelectionData : [];\n        var MarkerShape = getMarker(marker.shape);\n        var updateMarkers = this.markerSelection.setData(data);\n        updateMarkers.exit.remove();\n        var enterMarkers = updateMarkers.enter.append(MarkerShape);\n        this.markerSelection = updateMarkers.merge(enterMarkers);\n    };\n    AreaSeries.prototype.updateMarkerNodes = function () {\n        if (!this.chart) {\n            return;\n        }\n        var marker = this.marker;\n        var markerFormatter = marker.formatter;\n        var markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : this.strokeWidth;\n        var markerSize = marker.size;\n        var _a = this, xKey = _a.xKey, seriesItemEnabled = _a.seriesItemEnabled;\n        var highlightedDatum = this.chart.highlightedDatum;\n        var _b = this.highlightStyle, highlightFill = _b.fill, highlightStroke = _b.stroke;\n        this.markerSelection.each(function (node, datum) {\n            var highlighted = datum === highlightedDatum;\n            var markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill || datum.fill;\n            var markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || datum.stroke;\n            var markerFormat = undefined;\n            if (markerFormatter) {\n                markerFormat = markerFormatter({\n                    datum: datum.seriesDatum,\n                    xKey: xKey,\n                    yKey: datum.yKey,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: markerSize,\n                    highlighted: highlighted\n                });\n            }\n            node.fill = markerFormat && markerFormat.fill || markerFill;\n            node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n            node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                ? markerFormat.strokeWidth\n                : markerStrokeWidth;\n            node.size = markerFormat && markerFormat.size !== undefined\n                ? markerFormat.size\n                : markerSize;\n            node.translationX = datum.point.x;\n            node.translationY = datum.point.y;\n            node.visible = marker.enabled && node.size > 0 && !!seriesItemEnabled.get(datum.yKey);\n        });\n    };\n    AreaSeries.prototype.getNodeData = function () {\n        return this.markerSelectionData;\n    };\n    AreaSeries.prototype.fireNodeClickEvent = function (datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: datum.yKey\n        });\n    };\n    AreaSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var xKey = this.xKey;\n        var yKey = nodeDatum.yKey;\n        if (!xKey || !yKey) {\n            return '';\n        }\n        var _a = this, xName = _a.xName, yKeys = _a.yKeys, yNames = _a.yNames, fills = _a.fills, tooltipFormat = _a.tooltipFormat, tooltipRenderer = _a.tooltipRenderer;\n        var datum = nodeDatum.seriesDatum;\n        var xValue = datum[xKey];\n        var yValue = datum[yKey];\n        var yKeyIndex = yKeys.indexOf(yKey);\n        var yName = yNames[yKeyIndex];\n        var color = fills[yKeyIndex % fills.length];\n        var xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        var yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        var title = yName;\n        var content = xString + ': ' + yString;\n        var defaults = {\n            title: title,\n            titleBackgroundColor: color,\n            content: content\n        };\n        if (tooltipFormat || tooltipRenderer) {\n            var params = {\n                datum: datum,\n                xKey: xKey,\n                xName: xName,\n                xValue: xValue,\n                yKey: yKey,\n                yValue: yValue,\n                yName: yName,\n                color: color\n            };\n            if (tooltipFormat) {\n                return toTooltipHtml({\n                    content: interpolate(tooltipFormat, params)\n                }, defaults);\n            }\n            if (tooltipRenderer) {\n                return toTooltipHtml(tooltipRenderer(params), defaults);\n            }\n        }\n        return toTooltipHtml(defaults);\n    };\n    AreaSeries.prototype.listSeriesItems = function (legendData) {\n        var _a = this, data = _a.data, id = _a.id, xKey = _a.xKey, yKeys = _a.yKeys, yNames = _a.yNames, seriesItemEnabled = _a.seriesItemEnabled, marker = _a.marker, fills = _a.fills, strokes = _a.strokes, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity;\n        if (data && data.length && xKey && yKeys.length) {\n            yKeys.forEach(function (yKey, index) {\n                legendData.push({\n                    id: id,\n                    itemId: yKey,\n                    enabled: seriesItemEnabled.get(yKey) || false,\n                    label: {\n                        text: yNames[index] || yKeys[index]\n                    },\n                    marker: {\n                        shape: marker.shape,\n                        fill: marker.fill || fills[index % fills.length],\n                        stroke: marker.stroke || strokes[index % strokes.length],\n                        fillOpacity: fillOpacity,\n                        strokeOpacity: strokeOpacity\n                    }\n                });\n            });\n        }\n    };\n    AreaSeries.prototype.toggleSeriesItem = function (itemId, enabled) {\n        this.seriesItemEnabled.set(itemId, enabled);\n        this.scheduleData();\n    };\n    AreaSeries.className = 'AreaSeries';\n    AreaSeries.type = 'area';\n    __decorate([\n        reactive('dataChange')\n    ], AreaSeries.prototype, \"fills\", void 0);\n    __decorate([\n        reactive('dataChange')\n    ], AreaSeries.prototype, \"strokes\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"fillOpacity\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"strokeOpacity\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"lineDash\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"lineDashOffset\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"xName\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"yNames\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"strokeWidth\", void 0);\n    __decorate([\n        reactive('update')\n    ], AreaSeries.prototype, \"shadow\", void 0);\n    return AreaSeries;\n}(CartesianSeries));\nexport { AreaSeries };\n"]},"metadata":{},"sourceType":"module"}