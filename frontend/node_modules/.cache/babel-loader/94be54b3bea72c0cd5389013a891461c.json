{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Shape } from \"./shape\";\nimport { Path2D } from \"../path2D\";\n\nvar Path =\n/** @class */\nfunction (_super) {\n  __extends(Path, _super);\n\n  function Path() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n\n\n    _this.path = new Path2D();\n    /**\n    * The path only has to be updated when certain attributes change.\n    * For example, if transform attributes (such as `translationX`)\n    * are changed, we don't have to update the path. The `dirtyPath` flag\n    * is how we keep track if the path has to be updated or not.\n    */\n\n    _this._dirtyPath = true;\n    /**\n     * Path definition in SVG path syntax:\n     * https://www.w3.org/TR/SVG11/paths.html#DAttribute\n     */\n\n    _this._svgPath = '';\n    return _this;\n  }\n\n  Object.defineProperty(Path.prototype, \"dirtyPath\", {\n    get: function () {\n      return this._dirtyPath;\n    },\n    set: function (value) {\n      if (this._dirtyPath !== value) {\n        this._dirtyPath = value;\n\n        if (value) {\n          this.dirty = true;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Path.prototype, \"svgPath\", {\n    get: function () {\n      return this._svgPath;\n    },\n    set: function (value) {\n      if (this._svgPath !== value) {\n        this._svgPath = value;\n        this.path.setFromString(value);\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Path.prototype.isPointInPath = function (x, y) {\n    var point = this.transformPoint(x, y);\n    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n  };\n\n  Path.prototype.isPointInStroke = function (x, y) {\n    return false;\n  };\n\n  Path.prototype.updatePath = function () {};\n\n  Path.prototype.render = function (ctx) {\n    var scene = this.scene;\n\n    if (this.dirtyTransform) {\n      this.computeTransformMatrix();\n    } // if (scene.debug.renderBoundingBoxes) {\n    //     const bbox = this.computeBBox();\n    //     if (bbox) {\n    //         this.matrix.transformBBox(bbox).render(ctx);\n    //     }\n    // }\n\n\n    this.matrix.toContext(ctx);\n\n    if (this.dirtyPath) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n\n    scene.appendPath(this.path);\n    this.fillStroke(ctx);\n    this.dirty = false;\n  };\n\n  Path.className = 'Path';\n  return Path;\n}(Shape);\n\nexport { Path };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/shape/path.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Shape","Path2D","Path","_super","_this","apply","arguments","path","_dirtyPath","_svgPath","defineProperty","get","set","value","dirty","enumerable","configurable","setFromString","isPointInPath","x","y","point","transformPoint","closedPath","isPointInStroke","updatePath","render","ctx","scene","dirtyTransform","computeTransformMatrix","matrix","toContext","dirtyPath","appendPath","fillStroke","className"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Shape } from \"./shape\";\nimport { Path2D } from \"../path2D\";\nvar Path = /** @class */ (function (_super) {\n    __extends(Path, _super);\n    function Path() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * Declare a path to retain for later rendering and hit testing\n         * using custom Path2D class. Think of it as a TypeScript version\n         * of the native Path2D (with some differences) that works in all browsers.\n         */\n        _this.path = new Path2D();\n        /**\n        * The path only has to be updated when certain attributes change.\n        * For example, if transform attributes (such as `translationX`)\n        * are changed, we don't have to update the path. The `dirtyPath` flag\n        * is how we keep track if the path has to be updated or not.\n        */\n        _this._dirtyPath = true;\n        /**\n         * Path definition in SVG path syntax:\n         * https://www.w3.org/TR/SVG11/paths.html#DAttribute\n         */\n        _this._svgPath = '';\n        return _this;\n    }\n    Object.defineProperty(Path.prototype, \"dirtyPath\", {\n        get: function () {\n            return this._dirtyPath;\n        },\n        set: function (value) {\n            if (this._dirtyPath !== value) {\n                this._dirtyPath = value;\n                if (value) {\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Path.prototype, \"svgPath\", {\n        get: function () {\n            return this._svgPath;\n        },\n        set: function (value) {\n            if (this._svgPath !== value) {\n                this._svgPath = value;\n                this.path.setFromString(value);\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n    };\n    Path.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Path.prototype.updatePath = function () { };\n    Path.prototype.render = function (ctx) {\n        var scene = this.scene;\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        // if (scene.debug.renderBoundingBoxes) {\n        //     const bbox = this.computeBBox();\n        //     if (bbox) {\n        //         this.matrix.transformBBox(bbox).render(ctx);\n        //     }\n        // }\n        this.matrix.toContext(ctx);\n        if (this.dirtyPath) {\n            this.updatePath();\n            this.dirtyPath = false;\n        }\n        scene.appendPath(this.path);\n        this.fillStroke(ctx);\n        this.dirty = false;\n    };\n    Path.className = 'Path';\n    return Path;\n}(Shape));\nexport { Path };\n"]},"metadata":{},"sourceType":"module"}