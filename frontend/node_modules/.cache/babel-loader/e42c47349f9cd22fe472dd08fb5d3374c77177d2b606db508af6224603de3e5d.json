{"ast":null,"code":"import { ascending } from \"./compare\";\n/**\n * Returns the insertion point for `x` in array to maintain sorted order.\n * The arguments `lo` and `hi` may be used to specify a subset of the array which should be considered;\n * by default the entire array is used. If `x` is already present in array, the insertion point will be before\n * (to the left of) any existing entries. The return value is suitable for use as the first argument to `splice`\n * assuming that array is already sorted. The returned insertion point `i` partitions the array into two halves\n * so that all `v < x` for `v` in `array.slice(lo, i)` for the left side and all `v >= x` for `v` in `array.slice(i, hi)`\n * for the right side.\n * @param list\n * @param x\n * @param comparator\n * @param lo\n * @param hi\n */\nexport function bisectLeft(list, x, comparator, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n  if (hi === void 0) {\n    hi = list.length;\n  }\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (comparator(list[mid], x) < 0) {\n      // list[mid] < x\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n}\nexport function bisectRight(list, x, comparator, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n  if (hi === void 0) {\n    hi = list.length;\n  }\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (comparator(list[mid], x) > 0) {\n      // list[mid] > x\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n/**\n * A specialized version of `bisectLeft` that works with the arrays whose elements cannot be compared directly.\n * The map function is used instead to produce a comparable value for a given array element, then the values\n * returned by the map are compared using the `ascendingComparator`.\n * @param list\n * @param x\n * @param map\n * @param lo\n * @param hi\n */\nexport function complexBisectLeft(list, x, map, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n  if (hi === void 0) {\n    hi = list.length;\n  }\n  var comparator = ascendingComparator(map);\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (comparator(list[mid], x) < 0) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n}\nexport function complexBisectRight(list, x, map, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n  if (hi === void 0) {\n    hi = list.length;\n  }\n  var comparator = ascendingComparator(map);\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (comparator(list[mid], x) < 0) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n}\nfunction ascendingComparator(map) {\n  return function (item, x) {\n    return ascending(map(item), x);\n  };\n}","map":{"version":3,"names":["ascending","bisectLeft","list","x","comparator","lo","hi","length","mid","bisectRight","complexBisectLeft","map","ascendingComparator","complexBisectRight","item"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/util/bisect.js"],"sourcesContent":["import { ascending } from \"./compare\";\n/**\n * Returns the insertion point for `x` in array to maintain sorted order.\n * The arguments `lo` and `hi` may be used to specify a subset of the array which should be considered;\n * by default the entire array is used. If `x` is already present in array, the insertion point will be before\n * (to the left of) any existing entries. The return value is suitable for use as the first argument to `splice`\n * assuming that array is already sorted. The returned insertion point `i` partitions the array into two halves\n * so that all `v < x` for `v` in `array.slice(lo, i)` for the left side and all `v >= x` for `v` in `array.slice(i, hi)`\n * for the right side.\n * @param list\n * @param x\n * @param comparator\n * @param lo\n * @param hi\n */\nexport function bisectLeft(list, x, comparator, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) { // list[mid] < x\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nexport function bisectRight(list, x, comparator, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) > 0) { // list[mid] > x\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    return lo;\n}\n/**\n * A specialized version of `bisectLeft` that works with the arrays whose elements cannot be compared directly.\n * The map function is used instead to produce a comparable value for a given array element, then the values\n * returned by the map are compared using the `ascendingComparator`.\n * @param list\n * @param x\n * @param map\n * @param lo\n * @param hi\n */\nexport function complexBisectLeft(list, x, map, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    var comparator = ascendingComparator(map);\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) {\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nexport function complexBisectRight(list, x, map, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    var comparator = ascendingComparator(map);\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) {\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nfunction ascendingComparator(map) {\n    return function (item, x) {\n        return ascending(map(item), x);\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}