{"ast":null,"code":"import { find } from \"../util/array\";\n/**\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\n * and the tree grows downward from the root.\n */\nvar TreeNode = /** @class */function () {\n  function TreeNode(label, parent, number) {\n    if (label === void 0) {\n      label = '';\n    }\n    if (number === void 0) {\n      number = 0;\n    }\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    // screenX and screenY are meant to be recomputed from (layout) x and y\n    // when the tree is resized (without performing another layout)\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number;\n  }\n  TreeNode.prototype.getLeftSibling = function () {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\n  };\n  TreeNode.prototype.getLeftmostSibling = function () {\n    return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n  };\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  TreeNode.prototype.nextLeft = function () {\n    return this.children ? this.children[0] : this.thread;\n  };\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  TreeNode.prototype.nextRight = function () {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  };\n  TreeNode.prototype.getSiblings = function () {\n    var _this = this;\n    return this.parent ? this.parent.children.filter(function (_, i) {\n      return i !== _this.number;\n    }) : [];\n  };\n  return TreeNode;\n}();\n/**\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\n * creating empty labels.\n */\nexport function ticksToTree(ticks, pad) {\n  if (pad === void 0) {\n    pad = true;\n  }\n  var root = new TreeNode();\n  var depth = 0;\n  if (pad) {\n    ticks.forEach(function (tick) {\n      return depth = Math.max(depth, tick.labels.length);\n    });\n  }\n  ticks.forEach(function (tick) {\n    if (pad) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift('');\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  var pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n  var lastPartIndex = pathParts.length - 1;\n  pathParts.forEach(function (pathPart, partIndex) {\n    var children = root.children;\n    var existingNode = find(children, function (child) {\n      return child.label === pathPart;\n    });\n    var isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      // the isNotLeaf check is to allow duplicate leafs\n      root = existingNode;\n    } else {\n      var node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\n// Shift the subtree.\nfunction moveSubtree(wm, wp, shift) {\n  var subtrees = wp.number - wm.number;\n  var ratio = shift / subtrees;\n  wp.change -= ratio;\n  wp.shift += shift;\n  wm.change += ratio;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\n// Spaces out the children.\nfunction executeShifts(v) {\n  var children = v.children;\n  if (children) {\n    var shift = 0;\n    var change = 0;\n    for (var i = children.length - 1; i >= 0; i--) {\n      var w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\n// Moves current subtree with v as the root if some nodes are conflicting in space.\nfunction apportion(v, defaultAncestor, distance) {\n  var w = v.getLeftSibling();\n  if (w) {\n    var vop = v;\n    var vip = v;\n    var vim = w;\n    var vom = vip.getLeftmostSibling();\n    var sip = vip.mod;\n    var sop = vop.mod;\n    var sim = vim.mod;\n    var som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      var shift = vim.prelim + sim - (vip.prelim + sip) + distance;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\n// Compute the preliminary x-coordinate of node and its children (recursively).\nfunction firstWalk(node, distance) {\n  var children = node.children;\n  if (children.length) {\n    var defaultAncestor_1 = children[0];\n    children.forEach(function (child) {\n      firstWalk(child, distance);\n      defaultAncestor_1 = apportion(child, defaultAncestor_1, distance);\n    });\n    executeShifts(node);\n    var midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n    var leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    var leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n  }\n}\nvar Dimensions = /** @class */function () {\n  function Dimensions() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  Dimensions.prototype.update = function (node, xy) {\n    var _a = xy(node),\n      x = _a.x,\n      y = _a.y;\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  };\n  return Dimensions;\n}();\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach(function (w) {\n    return secondWalk(w, m + v.mod, layout);\n  });\n}\n// After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\nfunction thirdWalk(v) {\n  var children = v.children;\n  var leafCount = 0;\n  children.forEach(function (w) {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nexport function treeLayout(root) {\n  var layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = /** @class */function () {\n  function TreeLayout() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  TreeLayout.prototype.update = function (node) {\n    this.dimensions.update(node, function (node) {\n      return {\n        x: node.x,\n        y: node.y\n      };\n    });\n    if (!node.children.length) {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    } else {\n      this.nonLeafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  };\n  TreeLayout.prototype.resize = function (width, height, shiftX, shiftY, flipX) {\n    if (shiftX === void 0) {\n      shiftX = 0;\n    }\n    if (shiftY === void 0) {\n      shiftY = 0;\n    }\n    if (flipX === void 0) {\n      flipX = false;\n    }\n    var xSteps = this.leafCount - 1;\n    var ySteps = this.depth;\n    var dimensions = this.dimensions;\n    var scalingX = 1;\n    var scalingY = 1;\n    if (width > 0 && xSteps) {\n      var existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      var desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height > 0 && ySteps) {\n      var existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      var desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    var screenDimensions = new Dimensions();\n    this.nodes.forEach(function (node) {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, function (node) {\n        return {\n          x: node.screenX,\n          y: node.screenY\n        };\n      });\n    });\n    // Normalize so that root top and leftmost leaf left start at zero.\n    var offsetX = -screenDimensions.left;\n    var offsetY = -screenDimensions.top;\n    this.nodes.forEach(function (node) {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  };\n  return TreeLayout;\n}();\nexport { TreeLayout };\nfunction logTree(root, formatter) {\n  root.children.forEach(function (child) {\n    return logTree(child, formatter);\n  });\n  if (formatter) {\n    console.log(formatter(root));\n  } else {\n    console.log(root);\n  }\n}","map":{"version":3,"names":["find","TreeNode","label","parent","number","x","y","subtreeLeft","NaN","subtreeRight","screenX","screenY","children","leafCount","prelim","mod","ancestor","change","shift","depth","prototype","getLeftSibling","undefined","getLeftmostSibling","nextLeft","thread","nextRight","length","getSiblings","_this","filter","_","i","ticksToTree","ticks","pad","root","forEach","tick","Math","max","labels","unshift","insertTick","pathParts","slice","reverse","lastPartIndex","pathPart","partIndex","existingNode","child","isNotLeaf","node","push","moveSubtree","wm","wp","subtrees","ratio","vim","v","defaultAncestor","indexOf","executeShifts","w","apportion","distance","vop","vip","vom","sip","sop","sim","som","firstWalk","defaultAncestor_1","midpoint","leftSibling","Dimensions","top","Infinity","right","bottom","left","update","xy","_a","secondWalk","m","layout","thirdWalk","treeLayout","TreeLayout","dimensions","nodes","leafNodes","nonLeafNodes","resize","width","height","shiftX","shiftY","flipX","xSteps","ySteps","scalingX","scalingY","existingSpacingX","desiredSpacingX","existingSpacingY","desiredSpacingY","screenDimensions","offsetX","offsetY","logTree","formatter","console","log"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/layout/tree.js"],"sourcesContent":["import { find } from \"../util/array\";\n/**\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\n * and the tree grows downward from the root.\n */\nvar TreeNode = /** @class */ (function () {\n    function TreeNode(label, parent, number) {\n        if (label === void 0) { label = ''; }\n        if (number === void 0) { number = 0; }\n        this.x = 0;\n        this.y = 0;\n        this.subtreeLeft = NaN;\n        this.subtreeRight = NaN;\n        this.screenX = 0;\n        this.screenY = 0;\n        this.children = [];\n        this.leafCount = 0;\n        this.prelim = 0;\n        this.mod = 0;\n        this.ancestor = this;\n        this.change = 0;\n        this.shift = 0;\n        this.label = label;\n        // screenX and screenY are meant to be recomputed from (layout) x and y\n        // when the tree is resized (without performing another layout)\n        this.parent = parent;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.number = number;\n    }\n    TreeNode.prototype.getLeftSibling = function () {\n        return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\n    };\n    TreeNode.prototype.getLeftmostSibling = function () {\n        return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n    };\n    // traverse the left contour of a subtree, return the successor of v on this contour\n    TreeNode.prototype.nextLeft = function () {\n        return this.children ? this.children[0] : this.thread;\n    };\n    // traverse the right contour of a subtree, return the successor of v on this contour\n    TreeNode.prototype.nextRight = function () {\n        return this.children ? this.children[this.children.length - 1] : this.thread;\n    };\n    TreeNode.prototype.getSiblings = function () {\n        var _this = this;\n        return this.parent ? this.parent.children.filter(function (_, i) { return i !== _this.number; }) : [];\n    };\n    return TreeNode;\n}());\n/**\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\n * creating empty labels.\n */\nexport function ticksToTree(ticks, pad) {\n    if (pad === void 0) { pad = true; }\n    var root = new TreeNode();\n    var depth = 0;\n    if (pad) {\n        ticks.forEach(function (tick) { return depth = Math.max(depth, tick.labels.length); });\n    }\n    ticks.forEach(function (tick) {\n        if (pad) {\n            while (tick.labels.length < depth) {\n                tick.labels.unshift('');\n            }\n        }\n        insertTick(root, tick);\n    });\n    return root;\n}\nfunction insertTick(root, tick) {\n    var pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n    var lastPartIndex = pathParts.length - 1;\n    pathParts.forEach(function (pathPart, partIndex) {\n        var children = root.children;\n        var existingNode = find(children, function (child) { return child.label === pathPart; });\n        var isNotLeaf = partIndex !== lastPartIndex;\n        if (existingNode && isNotLeaf) { // the isNotLeaf check is to allow duplicate leafs\n            root = existingNode;\n        }\n        else {\n            var node = new TreeNode(pathPart, root);\n            node.number = children.length;\n            children.push(node);\n            if (isNotLeaf) {\n                root = node;\n            }\n        }\n    });\n}\n// Shift the subtree.\nfunction moveSubtree(wm, wp, shift) {\n    var subtrees = wp.number - wm.number;\n    var ratio = shift / subtrees;\n    wp.change -= ratio;\n    wp.shift += shift;\n    wm.change += ratio;\n    wp.prelim += shift;\n    wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\n// Spaces out the children.\nfunction executeShifts(v) {\n    var children = v.children;\n    if (children) {\n        var shift = 0;\n        var change = 0;\n        for (var i = children.length - 1; i >= 0; i--) {\n            var w = children[i];\n            w.prelim += shift;\n            w.mod += shift;\n            change += w.change;\n            shift += w.shift + change;\n        }\n    }\n}\n// Moves current subtree with v as the root if some nodes are conflicting in space.\nfunction apportion(v, defaultAncestor, distance) {\n    var w = v.getLeftSibling();\n    if (w) {\n        var vop = v;\n        var vip = v;\n        var vim = w;\n        var vom = vip.getLeftmostSibling();\n        var sip = vip.mod;\n        var sop = vop.mod;\n        var sim = vim.mod;\n        var som = vom.mod;\n        while (vim.nextRight() && vip.nextLeft()) {\n            vim = vim.nextRight();\n            vip = vip.nextLeft();\n            vom = vom.nextLeft();\n            vop = vop.nextRight();\n            vop.ancestor = v;\n            var shift = (vim.prelim + sim) - (vip.prelim + sip) + distance;\n            if (shift > 0) {\n                moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n                sip += shift;\n                sop += shift;\n            }\n            sim += vim.mod;\n            sip += vip.mod;\n            som += vom.mod;\n            sop += vop.mod;\n        }\n        if (vim.nextRight() && !vop.nextRight()) {\n            vop.thread = vim.nextRight();\n            vop.mod += sim - sop;\n        }\n        else {\n            if (vip.nextLeft() && !vom.nextLeft()) {\n                vom.thread = vip.nextLeft();\n                vom.mod += sip - som;\n            }\n            defaultAncestor = v;\n        }\n    }\n    return defaultAncestor;\n}\n// Compute the preliminary x-coordinate of node and its children (recursively).\nfunction firstWalk(node, distance) {\n    var children = node.children;\n    if (children.length) {\n        var defaultAncestor_1 = children[0];\n        children.forEach(function (child) {\n            firstWalk(child, distance);\n            defaultAncestor_1 = apportion(child, defaultAncestor_1, distance);\n        });\n        executeShifts(node);\n        var midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n        var leftSibling = node.getLeftSibling();\n        if (leftSibling) {\n            node.prelim = leftSibling.prelim + distance;\n            node.mod = node.prelim - midpoint;\n        }\n        else {\n            node.prelim = midpoint;\n        }\n    }\n    else {\n        var leftSibling = node.getLeftSibling();\n        node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n    }\n}\nvar Dimensions = /** @class */ (function () {\n    function Dimensions() {\n        this.top = Infinity;\n        this.right = -Infinity;\n        this.bottom = -Infinity;\n        this.left = Infinity;\n    }\n    Dimensions.prototype.update = function (node, xy) {\n        var _a = xy(node), x = _a.x, y = _a.y;\n        if (x > this.right) {\n            this.right = x;\n        }\n        if (x < this.left) {\n            this.left = x;\n        }\n        if (y > this.bottom) {\n            this.bottom = y;\n        }\n        if (y < this.top) {\n            this.top = y;\n        }\n    };\n    return Dimensions;\n}());\nfunction secondWalk(v, m, layout) {\n    v.x = v.prelim + m;\n    v.y = v.depth;\n    layout.update(v);\n    v.children.forEach(function (w) { return secondWalk(w, m + v.mod, layout); });\n}\n// After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\nfunction thirdWalk(v) {\n    var children = v.children;\n    var leafCount = 0;\n    children.forEach(function (w) {\n        thirdWalk(w);\n        if (w.children.length) {\n            leafCount += w.leafCount;\n        }\n        else {\n            leafCount++;\n        }\n    });\n    v.leafCount = leafCount;\n    if (children.length) {\n        v.subtreeLeft = children[0].subtreeLeft;\n        v.subtreeRight = children[v.children.length - 1].subtreeRight;\n        v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n    }\n    else {\n        v.subtreeLeft = v.x;\n        v.subtreeRight = v.x;\n    }\n}\nexport function treeLayout(root) {\n    var layout = new TreeLayout;\n    firstWalk(root, 1);\n    secondWalk(root, -root.prelim, layout);\n    thirdWalk(root);\n    return layout;\n}\nvar TreeLayout = /** @class */ (function () {\n    function TreeLayout() {\n        this.dimensions = new Dimensions;\n        this.leafCount = 0;\n        this.nodes = [];\n        // One might want to process leaf nodes separately from the rest of the tree.\n        // For example, position labels corresponding to leafs vertically, rather than horizontally.\n        this.leafNodes = [];\n        this.nonLeafNodes = [];\n        this.depth = 0;\n    }\n    TreeLayout.prototype.update = function (node) {\n        this.dimensions.update(node, function (node) { return ({ x: node.x, y: node.y }); });\n        if (!node.children.length) {\n            this.leafCount++;\n            this.leafNodes.push(node);\n        }\n        else {\n            this.nonLeafNodes.push(node);\n        }\n        if (node.depth > this.depth) {\n            this.depth = node.depth;\n        }\n        this.nodes.push(node);\n    };\n    TreeLayout.prototype.resize = function (width, height, shiftX, shiftY, flipX) {\n        if (shiftX === void 0) { shiftX = 0; }\n        if (shiftY === void 0) { shiftY = 0; }\n        if (flipX === void 0) { flipX = false; }\n        var xSteps = this.leafCount - 1;\n        var ySteps = this.depth;\n        var dimensions = this.dimensions;\n        var scalingX = 1;\n        var scalingY = 1;\n        if (width > 0 && xSteps) {\n            var existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n            var desiredSpacingX = width / xSteps;\n            scalingX = desiredSpacingX / existingSpacingX;\n            if (flipX) {\n                scalingX = -scalingX;\n            }\n        }\n        if (height > 0 && ySteps) {\n            var existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n            var desiredSpacingY = height / ySteps;\n            scalingY = desiredSpacingY / existingSpacingY;\n        }\n        var screenDimensions = new Dimensions();\n        this.nodes.forEach(function (node) {\n            node.screenX = node.x * scalingX;\n            node.screenY = node.y * scalingY;\n            screenDimensions.update(node, function (node) { return ({ x: node.screenX, y: node.screenY }); });\n        });\n        // Normalize so that root top and leftmost leaf left start at zero.\n        var offsetX = -screenDimensions.left;\n        var offsetY = -screenDimensions.top;\n        this.nodes.forEach(function (node) {\n            node.screenX += offsetX + shiftX;\n            node.screenY += offsetY + shiftY;\n        });\n    };\n    return TreeLayout;\n}());\nexport { TreeLayout };\nfunction logTree(root, formatter) {\n    root.children.forEach(function (child) { return logTree(child, formatter); });\n    if (formatter) {\n        console.log(formatter(root));\n    }\n    else {\n        console.log(root);\n    }\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,eAAe;AACpC;AACA;AACA;AACA;AACA,IAAIC,QAAQ,GAAG,aAAe,YAAY;EACtC,SAASA,QAAQ,CAACC,KAAK,EAAEC,MAAM,EAAEC,MAAM,EAAE;IACrC,IAAIF,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,EAAE;IAAE;IACpC,IAAIE,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAG,CAAC;IAAE;IACrC,IAAI,CAACC,CAAC,GAAG,CAAC;IACV,IAAI,CAACC,CAAC,GAAG,CAAC;IACV,IAAI,CAACC,WAAW,GAAGC,GAAG;IACtB,IAAI,CAACC,YAAY,GAAGD,GAAG;IACvB,IAAI,CAACE,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAAChB,KAAK,GAAGA,KAAK;IAClB;IACA;IACA,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACgB,KAAK,GAAGhB,MAAM,GAAGA,MAAM,CAACgB,KAAK,GAAG,CAAC,GAAG,CAAC;IAC1C,IAAI,CAACf,MAAM,GAAGA,MAAM;EACxB;EACAH,QAAQ,CAACmB,SAAS,CAACC,cAAc,GAAG,YAAY;IAC5C,OAAO,IAAI,CAACjB,MAAM,GAAG,CAAC,IAAI,IAAI,CAACD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACS,QAAQ,CAAC,IAAI,CAACR,MAAM,GAAG,CAAC,CAAC,GAAGkB,SAAS;EAC7F,CAAC;EACDrB,QAAQ,CAACmB,SAAS,CAACG,kBAAkB,GAAG,YAAY;IAChD,OAAO,IAAI,CAACnB,MAAM,GAAG,CAAC,IAAI,IAAI,CAACD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACS,QAAQ,CAAC,CAAC,CAAC,GAAGU,SAAS;EAC/E,CAAC;EACD;EACArB,QAAQ,CAACmB,SAAS,CAACI,QAAQ,GAAG,YAAY;IACtC,OAAO,IAAI,CAACZ,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAACa,MAAM;EACzD,CAAC;EACD;EACAxB,QAAQ,CAACmB,SAAS,CAACM,SAAS,GAAG,YAAY;IACvC,OAAO,IAAI,CAACd,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACe,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACF,MAAM;EAChF,CAAC;EACDxB,QAAQ,CAACmB,SAAS,CAACQ,WAAW,GAAG,YAAY;IACzC,IAAIC,KAAK,GAAG,IAAI;IAChB,OAAO,IAAI,CAAC1B,MAAM,GAAG,IAAI,CAACA,MAAM,CAACS,QAAQ,CAACkB,MAAM,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAOA,CAAC,KAAKH,KAAK,CAACzB,MAAM;IAAE,CAAC,CAAC,GAAG,EAAE;EACzG,CAAC;EACD,OAAOH,QAAQ;AACnB,CAAC,EAAG;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgC,WAAW,CAACC,KAAK,EAAEC,GAAG,EAAE;EACpC,IAAIA,GAAG,KAAK,KAAK,CAAC,EAAE;IAAEA,GAAG,GAAG,IAAI;EAAE;EAClC,IAAIC,IAAI,GAAG,IAAInC,QAAQ,EAAE;EACzB,IAAIkB,KAAK,GAAG,CAAC;EACb,IAAIgB,GAAG,EAAE;IACLD,KAAK,CAACG,OAAO,CAAC,UAAUC,IAAI,EAAE;MAAE,OAAOnB,KAAK,GAAGoB,IAAI,CAACC,GAAG,CAACrB,KAAK,EAAEmB,IAAI,CAACG,MAAM,CAACd,MAAM,CAAC;IAAE,CAAC,CAAC;EAC1F;EACAO,KAAK,CAACG,OAAO,CAAC,UAAUC,IAAI,EAAE;IAC1B,IAAIH,GAAG,EAAE;MACL,OAAOG,IAAI,CAACG,MAAM,CAACd,MAAM,GAAGR,KAAK,EAAE;QAC/BmB,IAAI,CAACG,MAAM,CAACC,OAAO,CAAC,EAAE,CAAC;MAC3B;IACJ;IACAC,UAAU,CAACP,IAAI,EAAEE,IAAI,CAAC;EAC1B,CAAC,CAAC;EACF,OAAOF,IAAI;AACf;AACA,SAASO,UAAU,CAACP,IAAI,EAAEE,IAAI,EAAE;EAC5B,IAAIM,SAAS,GAAGN,IAAI,CAACG,MAAM,CAACI,KAAK,EAAE,CAACC,OAAO,EAAE,CAAC,CAAC;EAC/C,IAAIC,aAAa,GAAGH,SAAS,CAACjB,MAAM,GAAG,CAAC;EACxCiB,SAAS,CAACP,OAAO,CAAC,UAAUW,QAAQ,EAAEC,SAAS,EAAE;IAC7C,IAAIrC,QAAQ,GAAGwB,IAAI,CAACxB,QAAQ;IAC5B,IAAIsC,YAAY,GAAGlD,IAAI,CAACY,QAAQ,EAAE,UAAUuC,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACjD,KAAK,KAAK8C,QAAQ;IAAE,CAAC,CAAC;IACxF,IAAII,SAAS,GAAGH,SAAS,KAAKF,aAAa;IAC3C,IAAIG,YAAY,IAAIE,SAAS,EAAE;MAAE;MAC7BhB,IAAI,GAAGc,YAAY;IACvB,CAAC,MACI;MACD,IAAIG,IAAI,GAAG,IAAIpD,QAAQ,CAAC+C,QAAQ,EAAEZ,IAAI,CAAC;MACvCiB,IAAI,CAACjD,MAAM,GAAGQ,QAAQ,CAACe,MAAM;MAC7Bf,QAAQ,CAAC0C,IAAI,CAACD,IAAI,CAAC;MACnB,IAAID,SAAS,EAAE;QACXhB,IAAI,GAAGiB,IAAI;MACf;IACJ;EACJ,CAAC,CAAC;AACN;AACA;AACA,SAASE,WAAW,CAACC,EAAE,EAAEC,EAAE,EAAEvC,KAAK,EAAE;EAChC,IAAIwC,QAAQ,GAAGD,EAAE,CAACrD,MAAM,GAAGoD,EAAE,CAACpD,MAAM;EACpC,IAAIuD,KAAK,GAAGzC,KAAK,GAAGwC,QAAQ;EAC5BD,EAAE,CAACxC,MAAM,IAAI0C,KAAK;EAClBF,EAAE,CAACvC,KAAK,IAAIA,KAAK;EACjBsC,EAAE,CAACvC,MAAM,IAAI0C,KAAK;EAClBF,EAAE,CAAC3C,MAAM,IAAII,KAAK;EAClBuC,EAAE,CAAC1C,GAAG,IAAIG,KAAK;AACnB;AACA,SAASF,QAAQ,CAAC4C,GAAG,EAAEC,CAAC,EAAEC,eAAe,EAAE;EACvC,OAAOD,CAAC,CAACjC,WAAW,EAAE,CAACmC,OAAO,CAACH,GAAG,CAAC5C,QAAQ,CAAC,IAAI,CAAC,GAAG4C,GAAG,CAAC5C,QAAQ,GAAG8C,eAAe;AACtF;AACA;AACA,SAASE,aAAa,CAACH,CAAC,EAAE;EACtB,IAAIjD,QAAQ,GAAGiD,CAAC,CAACjD,QAAQ;EACzB,IAAIA,QAAQ,EAAE;IACV,IAAIM,KAAK,GAAG,CAAC;IACb,IAAID,MAAM,GAAG,CAAC;IACd,KAAK,IAAIe,CAAC,GAAGpB,QAAQ,CAACe,MAAM,GAAG,CAAC,EAAEK,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3C,IAAIiC,CAAC,GAAGrD,QAAQ,CAACoB,CAAC,CAAC;MACnBiC,CAAC,CAACnD,MAAM,IAAII,KAAK;MACjB+C,CAAC,CAAClD,GAAG,IAAIG,KAAK;MACdD,MAAM,IAAIgD,CAAC,CAAChD,MAAM;MAClBC,KAAK,IAAI+C,CAAC,CAAC/C,KAAK,GAAGD,MAAM;IAC7B;EACJ;AACJ;AACA;AACA,SAASiD,SAAS,CAACL,CAAC,EAAEC,eAAe,EAAEK,QAAQ,EAAE;EAC7C,IAAIF,CAAC,GAAGJ,CAAC,CAACxC,cAAc,EAAE;EAC1B,IAAI4C,CAAC,EAAE;IACH,IAAIG,GAAG,GAAGP,CAAC;IACX,IAAIQ,GAAG,GAAGR,CAAC;IACX,IAAID,GAAG,GAAGK,CAAC;IACX,IAAIK,GAAG,GAAGD,GAAG,CAAC9C,kBAAkB,EAAE;IAClC,IAAIgD,GAAG,GAAGF,GAAG,CAACtD,GAAG;IACjB,IAAIyD,GAAG,GAAGJ,GAAG,CAACrD,GAAG;IACjB,IAAI0D,GAAG,GAAGb,GAAG,CAAC7C,GAAG;IACjB,IAAI2D,GAAG,GAAGJ,GAAG,CAACvD,GAAG;IACjB,OAAO6C,GAAG,CAAClC,SAAS,EAAE,IAAI2C,GAAG,CAAC7C,QAAQ,EAAE,EAAE;MACtCoC,GAAG,GAAGA,GAAG,CAAClC,SAAS,EAAE;MACrB2C,GAAG,GAAGA,GAAG,CAAC7C,QAAQ,EAAE;MACpB8C,GAAG,GAAGA,GAAG,CAAC9C,QAAQ,EAAE;MACpB4C,GAAG,GAAGA,GAAG,CAAC1C,SAAS,EAAE;MACrB0C,GAAG,CAACpD,QAAQ,GAAG6C,CAAC;MAChB,IAAI3C,KAAK,GAAI0C,GAAG,CAAC9C,MAAM,GAAG2D,GAAG,IAAKJ,GAAG,CAACvD,MAAM,GAAGyD,GAAG,CAAC,GAAGJ,QAAQ;MAC9D,IAAIjD,KAAK,GAAG,CAAC,EAAE;QACXqC,WAAW,CAACvC,QAAQ,CAAC4C,GAAG,EAAEC,CAAC,EAAEC,eAAe,CAAC,EAAED,CAAC,EAAE3C,KAAK,CAAC;QACxDqD,GAAG,IAAIrD,KAAK;QACZsD,GAAG,IAAItD,KAAK;MAChB;MACAuD,GAAG,IAAIb,GAAG,CAAC7C,GAAG;MACdwD,GAAG,IAAIF,GAAG,CAACtD,GAAG;MACd2D,GAAG,IAAIJ,GAAG,CAACvD,GAAG;MACdyD,GAAG,IAAIJ,GAAG,CAACrD,GAAG;IAClB;IACA,IAAI6C,GAAG,CAAClC,SAAS,EAAE,IAAI,CAAC0C,GAAG,CAAC1C,SAAS,EAAE,EAAE;MACrC0C,GAAG,CAAC3C,MAAM,GAAGmC,GAAG,CAAClC,SAAS,EAAE;MAC5B0C,GAAG,CAACrD,GAAG,IAAI0D,GAAG,GAAGD,GAAG;IACxB,CAAC,MACI;MACD,IAAIH,GAAG,CAAC7C,QAAQ,EAAE,IAAI,CAAC8C,GAAG,CAAC9C,QAAQ,EAAE,EAAE;QACnC8C,GAAG,CAAC7C,MAAM,GAAG4C,GAAG,CAAC7C,QAAQ,EAAE;QAC3B8C,GAAG,CAACvD,GAAG,IAAIwD,GAAG,GAAGG,GAAG;MACxB;MACAZ,eAAe,GAAGD,CAAC;IACvB;EACJ;EACA,OAAOC,eAAe;AAC1B;AACA;AACA,SAASa,SAAS,CAACtB,IAAI,EAAEc,QAAQ,EAAE;EAC/B,IAAIvD,QAAQ,GAAGyC,IAAI,CAACzC,QAAQ;EAC5B,IAAIA,QAAQ,CAACe,MAAM,EAAE;IACjB,IAAIiD,iBAAiB,GAAGhE,QAAQ,CAAC,CAAC,CAAC;IACnCA,QAAQ,CAACyB,OAAO,CAAC,UAAUc,KAAK,EAAE;MAC9BwB,SAAS,CAACxB,KAAK,EAAEgB,QAAQ,CAAC;MAC1BS,iBAAiB,GAAGV,SAAS,CAACf,KAAK,EAAEyB,iBAAiB,EAAET,QAAQ,CAAC;IACrE,CAAC,CAAC;IACFH,aAAa,CAACX,IAAI,CAAC;IACnB,IAAIwB,QAAQ,GAAG,CAACjE,QAAQ,CAAC,CAAC,CAAC,CAACE,MAAM,GAAGF,QAAQ,CAACA,QAAQ,CAACe,MAAM,GAAG,CAAC,CAAC,CAACb,MAAM,IAAI,CAAC;IAC9E,IAAIgE,WAAW,GAAGzB,IAAI,CAAChC,cAAc,EAAE;IACvC,IAAIyD,WAAW,EAAE;MACbzB,IAAI,CAACvC,MAAM,GAAGgE,WAAW,CAAChE,MAAM,GAAGqD,QAAQ;MAC3Cd,IAAI,CAACtC,GAAG,GAAGsC,IAAI,CAACvC,MAAM,GAAG+D,QAAQ;IACrC,CAAC,MACI;MACDxB,IAAI,CAACvC,MAAM,GAAG+D,QAAQ;IAC1B;EACJ,CAAC,MACI;IACD,IAAIC,WAAW,GAAGzB,IAAI,CAAChC,cAAc,EAAE;IACvCgC,IAAI,CAACvC,MAAM,GAAGgE,WAAW,GAAGA,WAAW,CAAChE,MAAM,GAAGqD,QAAQ,GAAG,CAAC;EACjE;AACJ;AACA,IAAIY,UAAU,GAAG,aAAe,YAAY;EACxC,SAASA,UAAU,GAAG;IAClB,IAAI,CAACC,GAAG,GAAGC,QAAQ;IACnB,IAAI,CAACC,KAAK,GAAG,CAACD,QAAQ;IACtB,IAAI,CAACE,MAAM,GAAG,CAACF,QAAQ;IACvB,IAAI,CAACG,IAAI,GAAGH,QAAQ;EACxB;EACAF,UAAU,CAAC3D,SAAS,CAACiE,MAAM,GAAG,UAAUhC,IAAI,EAAEiC,EAAE,EAAE;IAC9C,IAAIC,EAAE,GAAGD,EAAE,CAACjC,IAAI,CAAC;MAAEhD,CAAC,GAAGkF,EAAE,CAAClF,CAAC;MAAEC,CAAC,GAAGiF,EAAE,CAACjF,CAAC;IACrC,IAAID,CAAC,GAAG,IAAI,CAAC6E,KAAK,EAAE;MAChB,IAAI,CAACA,KAAK,GAAG7E,CAAC;IAClB;IACA,IAAIA,CAAC,GAAG,IAAI,CAAC+E,IAAI,EAAE;MACf,IAAI,CAACA,IAAI,GAAG/E,CAAC;IACjB;IACA,IAAIC,CAAC,GAAG,IAAI,CAAC6E,MAAM,EAAE;MACjB,IAAI,CAACA,MAAM,GAAG7E,CAAC;IACnB;IACA,IAAIA,CAAC,GAAG,IAAI,CAAC0E,GAAG,EAAE;MACd,IAAI,CAACA,GAAG,GAAG1E,CAAC;IAChB;EACJ,CAAC;EACD,OAAOyE,UAAU;AACrB,CAAC,EAAG;AACJ,SAASS,UAAU,CAAC3B,CAAC,EAAE4B,CAAC,EAAEC,MAAM,EAAE;EAC9B7B,CAAC,CAACxD,CAAC,GAAGwD,CAAC,CAAC/C,MAAM,GAAG2E,CAAC;EAClB5B,CAAC,CAACvD,CAAC,GAAGuD,CAAC,CAAC1C,KAAK;EACbuE,MAAM,CAACL,MAAM,CAACxB,CAAC,CAAC;EAChBA,CAAC,CAACjD,QAAQ,CAACyB,OAAO,CAAC,UAAU4B,CAAC,EAAE;IAAE,OAAOuB,UAAU,CAACvB,CAAC,EAAEwB,CAAC,GAAG5B,CAAC,CAAC9C,GAAG,EAAE2E,MAAM,CAAC;EAAE,CAAC,CAAC;AACjF;AACA;AACA;AACA;AACA,SAASC,SAAS,CAAC9B,CAAC,EAAE;EAClB,IAAIjD,QAAQ,GAAGiD,CAAC,CAACjD,QAAQ;EACzB,IAAIC,SAAS,GAAG,CAAC;EACjBD,QAAQ,CAACyB,OAAO,CAAC,UAAU4B,CAAC,EAAE;IAC1B0B,SAAS,CAAC1B,CAAC,CAAC;IACZ,IAAIA,CAAC,CAACrD,QAAQ,CAACe,MAAM,EAAE;MACnBd,SAAS,IAAIoD,CAAC,CAACpD,SAAS;IAC5B,CAAC,MACI;MACDA,SAAS,EAAE;IACf;EACJ,CAAC,CAAC;EACFgD,CAAC,CAAChD,SAAS,GAAGA,SAAS;EACvB,IAAID,QAAQ,CAACe,MAAM,EAAE;IACjBkC,CAAC,CAACtD,WAAW,GAAGK,QAAQ,CAAC,CAAC,CAAC,CAACL,WAAW;IACvCsD,CAAC,CAACpD,YAAY,GAAGG,QAAQ,CAACiD,CAAC,CAACjD,QAAQ,CAACe,MAAM,GAAG,CAAC,CAAC,CAAClB,YAAY;IAC7DoD,CAAC,CAACxD,CAAC,GAAG,CAACwD,CAAC,CAACtD,WAAW,GAAGsD,CAAC,CAACpD,YAAY,IAAI,CAAC;EAC9C,CAAC,MACI;IACDoD,CAAC,CAACtD,WAAW,GAAGsD,CAAC,CAACxD,CAAC;IACnBwD,CAAC,CAACpD,YAAY,GAAGoD,CAAC,CAACxD,CAAC;EACxB;AACJ;AACA,OAAO,SAASuF,UAAU,CAACxD,IAAI,EAAE;EAC7B,IAAIsD,MAAM,GAAG,IAAIG,UAAU;EAC3BlB,SAAS,CAACvC,IAAI,EAAE,CAAC,CAAC;EAClBoD,UAAU,CAACpD,IAAI,EAAE,CAACA,IAAI,CAACtB,MAAM,EAAE4E,MAAM,CAAC;EACtCC,SAAS,CAACvD,IAAI,CAAC;EACf,OAAOsD,MAAM;AACjB;AACA,IAAIG,UAAU,GAAG,aAAe,YAAY;EACxC,SAASA,UAAU,GAAG;IAClB,IAAI,CAACC,UAAU,GAAG,IAAIf,UAAU;IAChC,IAAI,CAAClE,SAAS,GAAG,CAAC;IAClB,IAAI,CAACkF,KAAK,GAAG,EAAE;IACf;IACA;IACA,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAAC9E,KAAK,GAAG,CAAC;EAClB;EACA0E,UAAU,CAACzE,SAAS,CAACiE,MAAM,GAAG,UAAUhC,IAAI,EAAE;IAC1C,IAAI,CAACyC,UAAU,CAACT,MAAM,CAAChC,IAAI,EAAE,UAAUA,IAAI,EAAE;MAAE,OAAQ;QAAEhD,CAAC,EAAEgD,IAAI,CAAChD,CAAC;QAAEC,CAAC,EAAE+C,IAAI,CAAC/C;MAAE,CAAC;IAAG,CAAC,CAAC;IACpF,IAAI,CAAC+C,IAAI,CAACzC,QAAQ,CAACe,MAAM,EAAE;MACvB,IAAI,CAACd,SAAS,EAAE;MAChB,IAAI,CAACmF,SAAS,CAAC1C,IAAI,CAACD,IAAI,CAAC;IAC7B,CAAC,MACI;MACD,IAAI,CAAC4C,YAAY,CAAC3C,IAAI,CAACD,IAAI,CAAC;IAChC;IACA,IAAIA,IAAI,CAAClC,KAAK,GAAG,IAAI,CAACA,KAAK,EAAE;MACzB,IAAI,CAACA,KAAK,GAAGkC,IAAI,CAAClC,KAAK;IAC3B;IACA,IAAI,CAAC4E,KAAK,CAACzC,IAAI,CAACD,IAAI,CAAC;EACzB,CAAC;EACDwC,UAAU,CAACzE,SAAS,CAAC8E,MAAM,GAAG,UAAUC,KAAK,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAC1E,IAAIF,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAG,CAAC;IAAE;IACrC,IAAIC,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAG,CAAC;IAAE;IACrC,IAAIC,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,KAAK;IAAE;IACvC,IAAIC,MAAM,GAAG,IAAI,CAAC3F,SAAS,GAAG,CAAC;IAC/B,IAAI4F,MAAM,GAAG,IAAI,CAACtF,KAAK;IACvB,IAAI2E,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAIY,QAAQ,GAAG,CAAC;IAChB,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIR,KAAK,GAAG,CAAC,IAAIK,MAAM,EAAE;MACrB,IAAII,gBAAgB,GAAG,CAACd,UAAU,CAACZ,KAAK,GAAGY,UAAU,CAACV,IAAI,IAAIoB,MAAM;MACpE,IAAIK,eAAe,GAAGV,KAAK,GAAGK,MAAM;MACpCE,QAAQ,GAAGG,eAAe,GAAGD,gBAAgB;MAC7C,IAAIL,KAAK,EAAE;QACPG,QAAQ,GAAG,CAACA,QAAQ;MACxB;IACJ;IACA,IAAIN,MAAM,GAAG,CAAC,IAAIK,MAAM,EAAE;MACtB,IAAIK,gBAAgB,GAAG,CAAChB,UAAU,CAACX,MAAM,GAAGW,UAAU,CAACd,GAAG,IAAIyB,MAAM;MACpE,IAAIM,eAAe,GAAGX,MAAM,GAAGK,MAAM;MACrCE,QAAQ,GAAGI,eAAe,GAAGD,gBAAgB;IACjD;IACA,IAAIE,gBAAgB,GAAG,IAAIjC,UAAU,EAAE;IACvC,IAAI,CAACgB,KAAK,CAAC1D,OAAO,CAAC,UAAUgB,IAAI,EAAE;MAC/BA,IAAI,CAAC3C,OAAO,GAAG2C,IAAI,CAAChD,CAAC,GAAGqG,QAAQ;MAChCrD,IAAI,CAAC1C,OAAO,GAAG0C,IAAI,CAAC/C,CAAC,GAAGqG,QAAQ;MAChCK,gBAAgB,CAAC3B,MAAM,CAAChC,IAAI,EAAE,UAAUA,IAAI,EAAE;QAAE,OAAQ;UAAEhD,CAAC,EAAEgD,IAAI,CAAC3C,OAAO;UAAEJ,CAAC,EAAE+C,IAAI,CAAC1C;QAAQ,CAAC;MAAG,CAAC,CAAC;IACrG,CAAC,CAAC;IACF;IACA,IAAIsG,OAAO,GAAG,CAACD,gBAAgB,CAAC5B,IAAI;IACpC,IAAI8B,OAAO,GAAG,CAACF,gBAAgB,CAAChC,GAAG;IACnC,IAAI,CAACe,KAAK,CAAC1D,OAAO,CAAC,UAAUgB,IAAI,EAAE;MAC/BA,IAAI,CAAC3C,OAAO,IAAIuG,OAAO,GAAGZ,MAAM;MAChChD,IAAI,CAAC1C,OAAO,IAAIuG,OAAO,GAAGZ,MAAM;IACpC,CAAC,CAAC;EACN,CAAC;EACD,OAAOT,UAAU;AACrB,CAAC,EAAG;AACJ,SAASA,UAAU;AACnB,SAASsB,OAAO,CAAC/E,IAAI,EAAEgF,SAAS,EAAE;EAC9BhF,IAAI,CAACxB,QAAQ,CAACyB,OAAO,CAAC,UAAUc,KAAK,EAAE;IAAE,OAAOgE,OAAO,CAAChE,KAAK,EAAEiE,SAAS,CAAC;EAAE,CAAC,CAAC;EAC7E,IAAIA,SAAS,EAAE;IACXC,OAAO,CAACC,GAAG,CAACF,SAAS,CAAChF,IAAI,CAAC,CAAC;EAChC,CAAC,MACI;IACDiF,OAAO,CAACC,GAAG,CAAClF,IAAI,CAAC;EACrB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}