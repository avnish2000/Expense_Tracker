{"ast":null,"code":"import { Node } from \"./node\";\n\nvar EnterNode =\n/** @class */\nfunction () {\n  function EnterNode(parent, datum) {\n    this.next = null;\n    this.scene = parent.scene;\n    this.parent = parent;\n    this.datum = datum;\n  }\n\n  EnterNode.prototype.appendChild = function (node) {\n    // This doesn't work without the `strict: true` in the `tsconfig.json`,\n    // so we must have two `if` checks below, instead of this single one.\n    // if (this.next && !Node.isNode(this.next)) {\n    //     throw new Error(`${this.next} is not a Node.`);\n    // }\n    if (this.next === null) {\n      return this.parent.insertBefore(node, null);\n    }\n\n    if (!Node.isNode(this.next)) {\n      throw new Error(this.next + \" is not a Node.\");\n    }\n\n    return this.parent.insertBefore(node, this.next);\n  };\n\n  EnterNode.prototype.insertBefore = function (node, nextNode) {\n    return this.parent.insertBefore(node, nextNode);\n  };\n\n  return EnterNode;\n}();\n\nexport { EnterNode };\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\n\nvar Selection =\n/** @class */\nfunction () {\n  function Selection(groups, parents) {\n    this.groups = groups;\n    this.parents = parents;\n  }\n\n  Selection.select = function (node) {\n    return new Selection([[typeof node === 'function' ? node() : node]], [undefined]);\n  };\n\n  Selection.selectAll = function (nodes) {\n    return new Selection([nodes == null ? [] : nodes], [undefined]);\n  };\n  /**\n   * Creates new nodes, appends them to the nodes of this selection and returns them\n   * as a new selection. The created nodes inherit the datums and the parents of the nodes\n   * they replace.\n   * @param Class The constructor function to use to create the new nodes.\n   */\n\n\n  Selection.prototype.append = function (Class) {\n    return this.select(function (node) {\n      return node.appendChild(new Class());\n    });\n  };\n  /**\n   * Same as the {@link append}, but accepts a custom creator function with the\n   * {@link NodeSelector} signature rather than a constructor function.\n   * @param creator\n   */\n\n\n  Selection.prototype.appendFn = function (creator) {\n    return this.select(function (node, data, index, group) {\n      return node.appendChild(creator(node, data, index, group));\n    });\n  };\n  /**\n   * Runs the given selector that returns a single node for every node in each group.\n   * The original nodes are then replaced by the nodes returned by the selector\n   * and returned as a new selection.\n   * The selected nodes inherit the datums and the parents of the original nodes.\n   */\n\n\n  Selection.prototype.select = function (selector) {\n    var groups = this.groups;\n    var numGroups = groups.length;\n    var subgroups = [];\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n      var subgroup = subgroups[j] = new Array(groupSize);\n\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n\n        if (node) {\n          var subnode = selector(node, node.datum, i, group);\n\n          if (subnode) {\n            subnode.datum = node.datum;\n          }\n\n          subgroup[i] = subnode;\n        } // else this can be a group of the `enter` selection,\n        // for example, with no nodes at the i-th position,\n        // only nodes at the end of the group\n\n      }\n    }\n\n    return new Selection(subgroups, this.parents);\n  };\n  /**\n   * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n   * @param Class The constructor function to use to find matching nodes.\n   */\n\n\n  Selection.prototype.selectByClass = function (Class) {\n    return this.select(function (node) {\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child instanceof Class) {\n            return child;\n          }\n        }\n      }\n    });\n  };\n\n  Selection.prototype.selectByTag = function (tag) {\n    return this.select(function (node) {\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child.tag === tag) {\n            return child;\n          }\n        }\n      }\n    });\n  };\n\n  Selection.prototype.selectAllByClass = function (Class) {\n    return this.selectAll(function (node) {\n      var nodes = [];\n\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child instanceof Class) {\n            nodes.push(child);\n          }\n        }\n      }\n\n      return nodes;\n    });\n  };\n\n  Selection.prototype.selectAllByTag = function (tag) {\n    return this.selectAll(function (node) {\n      var nodes = [];\n\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child.tag === tag) {\n            nodes.push(child);\n          }\n        }\n      }\n\n      return nodes;\n    });\n  };\n\n  Selection.prototype.selectNone = function () {\n    return [];\n  };\n  /**\n   * Runs the given selector that returns a group of nodes for every node in each group.\n   * The original nodes are then replaced by the groups of nodes returned by the selector\n   * and returned as a new selection. The original nodes become the parent nodes for each\n   * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n   * If called without any parameters, creates a new selection with an empty group for each\n   * node in this selection.\n   */\n\n\n  Selection.prototype.selectAll = function (selectorAll) {\n    if (!selectorAll) {\n      selectorAll = this.selectNone;\n    } // Each subgroup is populated with the selector (run on each group node) results.\n\n\n    var subgroups = []; // In the new selection that we return, subgroups become groups,\n    // and group nodes become parents.\n\n    var parents = [];\n    var groups = this.groups;\n    var groupCount = groups.length;\n\n    for (var j = 0; j < groupCount; j++) {\n      var group = groups[j];\n      var groupLength = group.length;\n\n      for (var i = 0; i < groupLength; i++) {\n        var node = group[i];\n\n        if (node) {\n          subgroups.push(selectorAll(node, node.datum, i, group));\n          parents.push(node);\n        }\n      }\n    }\n\n    return new Selection(subgroups, parents);\n  };\n  /**\n   * Runs the given callback for every node in this selection and returns this selection.\n   * @param cb\n   */\n\n\n  Selection.prototype.each = function (cb) {\n    var groups = this.groups;\n    var numGroups = groups.length;\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n\n        if (node) {\n          cb(node, node.datum, i, group);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  Selection.prototype.remove = function () {\n    return this.each(function (node) {\n      if (Node.isNode(node)) {\n        var parent_1 = node.parent;\n\n        if (parent_1) {\n          parent_1.removeChild(node);\n        }\n      }\n    });\n  };\n\n  Selection.prototype.merge = function (other) {\n    var groups0 = this.groups;\n    var groups1 = other.groups;\n    var m0 = groups0.length;\n    var m1 = groups1.length;\n    var m = Math.min(m0, m1);\n    var merges = new Array(m0);\n    var j = 0;\n\n    for (; j < m; j++) {\n      var group0 = groups0[j];\n      var group1 = groups1[j];\n      var n = group0.length;\n      var merge = merges[j] = new Array(n);\n\n      for (var i = 0; i < n; i++) {\n        var node = group0[i] || group1[i];\n        merge[i] = node || undefined;\n      }\n    }\n\n    for (; j < m0; j++) {\n      merges[j] = groups0[j];\n    }\n\n    return new Selection(merges, this.parents);\n  };\n  /**\n   * Return the first non-null element in this selection.\n   * If the selection is empty, returns null.\n   */\n\n\n  Selection.prototype.node = function () {\n    var groups = this.groups;\n    var numGroups = groups.length;\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n\n        if (node) {\n          return node;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  Selection.prototype.attr = function (name, value) {\n    this.each(function (node) {\n      node[name] = value;\n    });\n    return this;\n  };\n\n  Selection.prototype.attrFn = function (name, value) {\n    this.each(function (node, datum, index, group) {\n      node[name] = value(node, datum, index, group);\n    });\n    return this;\n  };\n  /**\n   * Invokes the given function once, passing in this selection.\n   * Returns this selection. Facilitates method chaining.\n   * @param cb\n   */\n\n\n  Selection.prototype.call = function (cb) {\n    cb(this);\n    return this;\n  };\n\n  Object.defineProperty(Selection.prototype, \"size\", {\n    /**\n     * Returns the total number of nodes in this selection.\n     */\n    get: function () {\n      var size = 0;\n      this.each(function () {\n        return size++;\n      });\n      return size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"data\", {\n    /**\n     * Returns the array of data for the selected elements.\n     */\n    get: function () {\n      var data = [];\n      this.each(function (_, datum) {\n        return data.push(datum);\n      });\n      return data;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"enter\", {\n    get: function () {\n      return new Selection(this.enterGroups ? this.enterGroups : [[]], this.parents);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"exit\", {\n    get: function () {\n      return new Selection(this.exitGroups ? this.exitGroups : [[]], this.parents);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Binds the given value to each selected node and returns this selection\n   * with its {@link GDatum} type changed to the type of the given value.\n   * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n   * This method can also be used to clear bound data.\n   * @param value\n   */\n\n  Selection.prototype.setDatum = function (value) {\n    return this.each(function (node) {\n      node.datum = value;\n    });\n  };\n\n  Object.defineProperty(Selection.prototype, \"datum\", {\n    /**\n     * Returns the bound datum for the first non-null element in the selection.\n     * This is generally useful only if you know the selection contains exactly one element.\n     */\n    get: function () {\n      var node = this.node();\n      return node ? node.datum : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Binds the specified array of values with the selected nodes, returning a new selection\n   * that represents the _update_ selection: the nodes successfully bound to the values.\n   * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n   * which can be used to add or remove the nodes to correspond to the new data.\n   * The `values` is an array of values of a particular type, or a function that returns\n   * an array of values for each group.\n   * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n   * @param values\n   * @param key\n   */\n\n  Selection.prototype.setData = function (values, key) {\n    if (typeof values !== 'function') {\n      var data_1 = values;\n\n      values = function () {\n        return data_1;\n      };\n    }\n\n    var groups = this.groups;\n    var parents = this.parents;\n    var numGroups = groups.length;\n    var updateGroups = new Array(numGroups);\n    var enterGroups = new Array(numGroups);\n    var exitGroups = new Array(numGroups);\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var parent_2 = parents[j];\n\n      if (!parent_2) {\n        throw new Error(\"Group #\" + j + \" has no parent: \" + group);\n      }\n\n      var groupSize = group.length;\n      var data = values(parent_2, parent_2.datum, j, parents);\n      var dataSize = data.length;\n      var enterGroup = enterGroups[j] = new Array(dataSize);\n      var updateGroup = updateGroups[j] = new Array(dataSize);\n      var exitGroup = exitGroups[j] = new Array(groupSize);\n\n      if (key) {\n        this.bindKey(parent_2, group, enterGroup, updateGroup, exitGroup, data, key);\n      } else {\n        this.bindIndex(parent_2, group, enterGroup, updateGroup, exitGroup, data);\n      } // Now connect the enter nodes to their following update node, such that\n      // appendChild can insert the materialized enter node before this node,\n      // rather than at the end of the parent node.\n\n\n      for (var i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n        var previous = enterGroup[i0];\n\n        if (previous) {\n          if (i0 >= i1) {\n            i1 = i0 + 1;\n          }\n\n          var next = void 0;\n\n          while (!(next = updateGroup[i1]) && i1 < dataSize) {\n            i1++;\n          }\n\n          previous.next = next || null;\n        }\n      }\n    }\n\n    var result = new Selection(updateGroups, parents);\n    result.enterGroups = enterGroups;\n    result.exitGroups = exitGroups;\n    return result;\n  };\n\n  Selection.prototype.bindIndex = function (parent, group, enter, update, exit, data) {\n    var groupSize = group.length;\n    var dataSize = data.length;\n    var i = 0;\n\n    for (; i < dataSize; i++) {\n      var node = group[i];\n\n      if (node) {\n        node.datum = data[i];\n        update[i] = node;\n      } else {\n        // more datums than group nodes\n        enter[i] = new EnterNode(parent, data[i]);\n      }\n    } // more group nodes than datums\n\n\n    for (; i < groupSize; i++) {\n      var node = group[i];\n\n      if (node) {\n        exit[i] = node;\n      }\n    }\n  };\n\n  Selection.prototype.bindKey = function (parent, group, enter, update, exit, data, key) {\n    var groupSize = group.length;\n    var dataSize = data.length;\n    var keyValues = new Array(groupSize);\n    var nodeByKeyValue = {}; // Compute the key for each node.\n    // If multiple nodes have the same key, the duplicates are added to exit.\n\n    for (var i = 0; i < groupSize; i++) {\n      var node = group[i];\n\n      if (node) {\n        var keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n\n        if (keyValue in nodeByKeyValue) {\n          exit[i] = node;\n        } else {\n          nodeByKeyValue[keyValue] = node;\n        }\n      }\n    } // Compute the key for each datum.\n    // If there is a node associated with this key, join and add it to update.\n    // If there is not (or the key is a duplicate), add it to enter.\n\n\n    for (var i = 0; i < dataSize; i++) {\n      var keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n      var node = nodeByKeyValue[keyValue];\n\n      if (node) {\n        update[i] = node;\n        node.datum = data[i];\n        nodeByKeyValue[keyValue] = undefined;\n      } else {\n        enter[i] = new EnterNode(parent, data[i]);\n      }\n    } // Add any remaining nodes that were not bound to data to exit.\n\n\n    for (var i = 0; i < groupSize; i++) {\n      var node = group[i];\n\n      if (node && nodeByKeyValue[keyValues[i]] === node) {\n        exit[i] = node;\n      }\n    }\n  };\n\n  Selection.keyPrefix = '$'; // Protect against keys like '__proto__'.\n\n  return Selection;\n}();\n\nexport { Selection };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/selection.js"],"names":["Node","EnterNode","parent","datum","next","scene","prototype","appendChild","node","insertBefore","isNode","Error","nextNode","Selection","groups","parents","select","undefined","selectAll","nodes","append","Class","appendFn","creator","data","index","group","selector","numGroups","length","subgroups","j","groupSize","subgroup","Array","i","subnode","selectByClass","children","n","child","selectByTag","tag","selectAllByClass","push","selectAllByTag","selectNone","selectorAll","groupCount","groupLength","each","cb","remove","parent_1","removeChild","merge","other","groups0","groups1","m0","m1","m","Math","min","merges","group0","group1","attr","name","value","attrFn","call","Object","defineProperty","get","size","enumerable","configurable","_","enterGroups","exitGroups","setDatum","setData","values","key","data_1","updateGroups","parent_2","dataSize","enterGroup","updateGroup","exitGroup","bindKey","bindIndex","i0","i1","previous","result","enter","update","exit","keyValues","nodeByKeyValue","keyValue","keyPrefix"],"mappings":"AAAA,SAASA,IAAT,QAAqB,QAArB;;AACA,IAAIC,SAAS;AAAG;AAAe,YAAY;AACvC,WAASA,SAAT,CAAmBC,MAAnB,EAA2BC,KAA3B,EAAkC;AAC9B,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAaH,MAAM,CAACG,KAApB;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACH;;AACDF,EAAAA,SAAS,CAACK,SAAV,CAAoBC,WAApB,GAAkC,UAAUC,IAAV,EAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAI,KAAKJ,IAAL,KAAc,IAAlB,EAAwB;AACpB,aAAO,KAAKF,MAAL,CAAYO,YAAZ,CAAyBD,IAAzB,EAA+B,IAA/B,CAAP;AACH;;AACD,QAAI,CAACR,IAAI,CAACU,MAAL,CAAY,KAAKN,IAAjB,CAAL,EAA6B;AACzB,YAAM,IAAIO,KAAJ,CAAU,KAAKP,IAAL,GAAY,iBAAtB,CAAN;AACH;;AACD,WAAO,KAAKF,MAAL,CAAYO,YAAZ,CAAyBD,IAAzB,EAA+B,KAAKJ,IAApC,CAAP;AACH,GAbD;;AAcAH,EAAAA,SAAS,CAACK,SAAV,CAAoBG,YAApB,GAAmC,UAAUD,IAAV,EAAgBI,QAAhB,EAA0B;AACzD,WAAO,KAAKV,MAAL,CAAYO,YAAZ,CAAyBD,IAAzB,EAA+BI,QAA/B,CAAP;AACH,GAFD;;AAGA,SAAOX,SAAP;AACH,CAzB8B,EAA/B;;AA0BA,SAASA,SAAT;AACA;;;;;;;AAMA,IAAIY,SAAS;AAAG;AAAe,YAAY;AACvC,WAASA,SAAT,CAAmBC,MAAnB,EAA2BC,OAA3B,EAAoC;AAChC,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACH;;AACDF,EAAAA,SAAS,CAACG,MAAV,GAAmB,UAAUR,IAAV,EAAgB;AAC/B,WAAO,IAAIK,SAAJ,CAAc,CAAC,CAAC,OAAOL,IAAP,KAAgB,UAAhB,GAA6BA,IAAI,EAAjC,GAAsCA,IAAvC,CAAD,CAAd,EAA8D,CAACS,SAAD,CAA9D,CAAP;AACH,GAFD;;AAGAJ,EAAAA,SAAS,CAACK,SAAV,GAAsB,UAAUC,KAAV,EAAiB;AACnC,WAAO,IAAIN,SAAJ,CAAc,CAACM,KAAK,IAAI,IAAT,GAAgB,EAAhB,GAAqBA,KAAtB,CAAd,EAA4C,CAACF,SAAD,CAA5C,CAAP;AACH,GAFD;AAGA;;;;;;;;AAMAJ,EAAAA,SAAS,CAACP,SAAV,CAAoBc,MAApB,GAA6B,UAAUC,KAAV,EAAiB;AAC1C,WAAO,KAAKL,MAAL,CAAY,UAAUR,IAAV,EAAgB;AAC/B,aAAOA,IAAI,CAACD,WAAL,CAAiB,IAAIc,KAAJ,EAAjB,CAAP;AACH,KAFM,CAAP;AAGH,GAJD;AAKA;;;;;;;AAKAR,EAAAA,SAAS,CAACP,SAAV,CAAoBgB,QAApB,GAA+B,UAAUC,OAAV,EAAmB;AAC9C,WAAO,KAAKP,MAAL,CAAY,UAAUR,IAAV,EAAgBgB,IAAhB,EAAsBC,KAAtB,EAA6BC,KAA7B,EAAoC;AACnD,aAAOlB,IAAI,CAACD,WAAL,CAAiBgB,OAAO,CAACf,IAAD,EAAOgB,IAAP,EAAaC,KAAb,EAAoBC,KAApB,CAAxB,CAAP;AACH,KAFM,CAAP;AAGH,GAJD;AAKA;;;;;;;;AAMAb,EAAAA,SAAS,CAACP,SAAV,CAAoBU,MAApB,GAA6B,UAAUW,QAAV,EAAoB;AAC7C,QAAIb,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIc,SAAS,GAAGd,MAAM,CAACe,MAAvB;AACA,QAAIC,SAAS,GAAG,EAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,UAAIL,KAAK,GAAGZ,MAAM,CAACiB,CAAD,CAAlB;AACA,UAAIC,SAAS,GAAGN,KAAK,CAACG,MAAtB;AACA,UAAII,QAAQ,GAAGH,SAAS,CAACC,CAAD,CAAT,GAAe,IAAIG,KAAJ,CAAUF,SAAV,CAA9B;;AACA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,YAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,YAAI3B,IAAJ,EAAU;AACN,cAAI4B,OAAO,GAAGT,QAAQ,CAACnB,IAAD,EAAOA,IAAI,CAACL,KAAZ,EAAmBgC,CAAnB,EAAsBT,KAAtB,CAAtB;;AACA,cAAIU,OAAJ,EAAa;AACTA,YAAAA,OAAO,CAACjC,KAAR,GAAgBK,IAAI,CAACL,KAArB;AACH;;AACD8B,UAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcC,OAAd;AACH,SAR+B,CAShC;AACA;AACA;;AACH;AACJ;;AACD,WAAO,IAAIvB,SAAJ,CAAciB,SAAd,EAAyB,KAAKf,OAA9B,CAAP;AACH,GAvBD;AAwBA;;;;;;AAIAF,EAAAA,SAAS,CAACP,SAAV,CAAoB+B,aAApB,GAAoC,UAAUhB,KAAV,EAAiB;AACjD,WAAO,KAAKL,MAAL,CAAY,UAAUR,IAAV,EAAgB;AAC/B,UAAIR,IAAI,CAACU,MAAL,CAAYF,IAAZ,CAAJ,EAAuB;AACnB,YAAI8B,QAAQ,GAAG9B,IAAI,CAAC8B,QAApB;AACA,YAAIC,CAAC,GAAGD,QAAQ,CAACT,MAAjB;;AACA,aAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,CAApB,EAAuBJ,CAAC,EAAxB,EAA4B;AACxB,cAAIK,KAAK,GAAGF,QAAQ,CAACH,CAAD,CAApB;;AACA,cAAIK,KAAK,YAAYnB,KAArB,EAA4B;AACxB,mBAAOmB,KAAP;AACH;AACJ;AACJ;AACJ,KAXM,CAAP;AAYH,GAbD;;AAcA3B,EAAAA,SAAS,CAACP,SAAV,CAAoBmC,WAApB,GAAkC,UAAUC,GAAV,EAAe;AAC7C,WAAO,KAAK1B,MAAL,CAAY,UAAUR,IAAV,EAAgB;AAC/B,UAAIR,IAAI,CAACU,MAAL,CAAYF,IAAZ,CAAJ,EAAuB;AACnB,YAAI8B,QAAQ,GAAG9B,IAAI,CAAC8B,QAApB;AACA,YAAIC,CAAC,GAAGD,QAAQ,CAACT,MAAjB;;AACA,aAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,CAApB,EAAuBJ,CAAC,EAAxB,EAA4B;AACxB,cAAIK,KAAK,GAAGF,QAAQ,CAACH,CAAD,CAApB;;AACA,cAAIK,KAAK,CAACE,GAAN,KAAcA,GAAlB,EAAuB;AACnB,mBAAOF,KAAP;AACH;AACJ;AACJ;AACJ,KAXM,CAAP;AAYH,GAbD;;AAcA3B,EAAAA,SAAS,CAACP,SAAV,CAAoBqC,gBAApB,GAAuC,UAAUtB,KAAV,EAAiB;AACpD,WAAO,KAAKH,SAAL,CAAe,UAAUV,IAAV,EAAgB;AAClC,UAAIW,KAAK,GAAG,EAAZ;;AACA,UAAInB,IAAI,CAACU,MAAL,CAAYF,IAAZ,CAAJ,EAAuB;AACnB,YAAI8B,QAAQ,GAAG9B,IAAI,CAAC8B,QAApB;AACA,YAAIC,CAAC,GAAGD,QAAQ,CAACT,MAAjB;;AACA,aAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,CAApB,EAAuBJ,CAAC,EAAxB,EAA4B;AACxB,cAAIK,KAAK,GAAGF,QAAQ,CAACH,CAAD,CAApB;;AACA,cAAIK,KAAK,YAAYnB,KAArB,EAA4B;AACxBF,YAAAA,KAAK,CAACyB,IAAN,CAAWJ,KAAX;AACH;AACJ;AACJ;;AACD,aAAOrB,KAAP;AACH,KAbM,CAAP;AAcH,GAfD;;AAgBAN,EAAAA,SAAS,CAACP,SAAV,CAAoBuC,cAApB,GAAqC,UAAUH,GAAV,EAAe;AAChD,WAAO,KAAKxB,SAAL,CAAe,UAAUV,IAAV,EAAgB;AAClC,UAAIW,KAAK,GAAG,EAAZ;;AACA,UAAInB,IAAI,CAACU,MAAL,CAAYF,IAAZ,CAAJ,EAAuB;AACnB,YAAI8B,QAAQ,GAAG9B,IAAI,CAAC8B,QAApB;AACA,YAAIC,CAAC,GAAGD,QAAQ,CAACT,MAAjB;;AACA,aAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,CAApB,EAAuBJ,CAAC,EAAxB,EAA4B;AACxB,cAAIK,KAAK,GAAGF,QAAQ,CAACH,CAAD,CAApB;;AACA,cAAIK,KAAK,CAACE,GAAN,KAAcA,GAAlB,EAAuB;AACnBvB,YAAAA,KAAK,CAACyB,IAAN,CAAWJ,KAAX;AACH;AACJ;AACJ;;AACD,aAAOrB,KAAP;AACH,KAbM,CAAP;AAcH,GAfD;;AAgBAN,EAAAA,SAAS,CAACP,SAAV,CAAoBwC,UAApB,GAAiC,YAAY;AACzC,WAAO,EAAP;AACH,GAFD;AAGA;;;;;;;;;;AAQAjC,EAAAA,SAAS,CAACP,SAAV,CAAoBY,SAApB,GAAgC,UAAU6B,WAAV,EAAuB;AACnD,QAAI,CAACA,WAAL,EAAkB;AACdA,MAAAA,WAAW,GAAG,KAAKD,UAAnB;AACH,KAHkD,CAInD;;;AACA,QAAIhB,SAAS,GAAG,EAAhB,CALmD,CAMnD;AACA;;AACA,QAAIf,OAAO,GAAG,EAAd;AACA,QAAID,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIkC,UAAU,GAAGlC,MAAM,CAACe,MAAxB;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,UAApB,EAAgCjB,CAAC,EAAjC,EAAqC;AACjC,UAAIL,KAAK,GAAGZ,MAAM,CAACiB,CAAD,CAAlB;AACA,UAAIkB,WAAW,GAAGvB,KAAK,CAACG,MAAxB;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,WAApB,EAAiCd,CAAC,EAAlC,EAAsC;AAClC,YAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,YAAI3B,IAAJ,EAAU;AACNsB,UAAAA,SAAS,CAACc,IAAV,CAAeG,WAAW,CAACvC,IAAD,EAAOA,IAAI,CAACL,KAAZ,EAAmBgC,CAAnB,EAAsBT,KAAtB,CAA1B;AACAX,UAAAA,OAAO,CAAC6B,IAAR,CAAapC,IAAb;AACH;AACJ;AACJ;;AACD,WAAO,IAAIK,SAAJ,CAAciB,SAAd,EAAyBf,OAAzB,CAAP;AACH,GAvBD;AAwBA;;;;;;AAIAF,EAAAA,SAAS,CAACP,SAAV,CAAoB4C,IAApB,GAA2B,UAAUC,EAAV,EAAc;AACrC,QAAIrC,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIc,SAAS,GAAGd,MAAM,CAACe,MAAvB;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,UAAIL,KAAK,GAAGZ,MAAM,CAACiB,CAAD,CAAlB;AACA,UAAIC,SAAS,GAAGN,KAAK,CAACG,MAAtB;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,YAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,YAAI3B,IAAJ,EAAU;AACN2C,UAAAA,EAAE,CAAC3C,IAAD,EAAOA,IAAI,CAACL,KAAZ,EAAmBgC,CAAnB,EAAsBT,KAAtB,CAAF;AACH;AACJ;AACJ;;AACD,WAAO,IAAP;AACH,GAdD;;AAeAb,EAAAA,SAAS,CAACP,SAAV,CAAoB8C,MAApB,GAA6B,YAAY;AACrC,WAAO,KAAKF,IAAL,CAAU,UAAU1C,IAAV,EAAgB;AAC7B,UAAIR,IAAI,CAACU,MAAL,CAAYF,IAAZ,CAAJ,EAAuB;AACnB,YAAI6C,QAAQ,GAAG7C,IAAI,CAACN,MAApB;;AACA,YAAImD,QAAJ,EAAc;AACVA,UAAAA,QAAQ,CAACC,WAAT,CAAqB9C,IAArB;AACH;AACJ;AACJ,KAPM,CAAP;AAQH,GATD;;AAUAK,EAAAA,SAAS,CAACP,SAAV,CAAoBiD,KAApB,GAA4B,UAAUC,KAAV,EAAiB;AACzC,QAAIC,OAAO,GAAG,KAAK3C,MAAnB;AACA,QAAI4C,OAAO,GAAGF,KAAK,CAAC1C,MAApB;AACA,QAAI6C,EAAE,GAAGF,OAAO,CAAC5B,MAAjB;AACA,QAAI+B,EAAE,GAAGF,OAAO,CAAC7B,MAAjB;AACA,QAAIgC,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASJ,EAAT,EAAaC,EAAb,CAAR;AACA,QAAII,MAAM,GAAG,IAAI9B,KAAJ,CAAUyB,EAAV,CAAb;AACA,QAAI5B,CAAC,GAAG,CAAR;;AACA,WAAOA,CAAC,GAAG8B,CAAX,EAAc9B,CAAC,EAAf,EAAmB;AACf,UAAIkC,MAAM,GAAGR,OAAO,CAAC1B,CAAD,CAApB;AACA,UAAImC,MAAM,GAAGR,OAAO,CAAC3B,CAAD,CAApB;AACA,UAAIQ,CAAC,GAAG0B,MAAM,CAACpC,MAAf;AACA,UAAI0B,KAAK,GAAGS,MAAM,CAACjC,CAAD,CAAN,GAAY,IAAIG,KAAJ,CAAUK,CAAV,CAAxB;;AACA,WAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,CAApB,EAAuBJ,CAAC,EAAxB,EAA4B;AACxB,YAAI3B,IAAI,GAAGyD,MAAM,CAAC9B,CAAD,CAAN,IAAa+B,MAAM,CAAC/B,CAAD,CAA9B;AACAoB,QAAAA,KAAK,CAACpB,CAAD,CAAL,GAAW3B,IAAI,IAAIS,SAAnB;AACH;AACJ;;AACD,WAAOc,CAAC,GAAG4B,EAAX,EAAe5B,CAAC,EAAhB,EAAoB;AAChBiC,MAAAA,MAAM,CAACjC,CAAD,CAAN,GAAY0B,OAAO,CAAC1B,CAAD,CAAnB;AACH;;AACD,WAAO,IAAIlB,SAAJ,CAAcmD,MAAd,EAAsB,KAAKjD,OAA3B,CAAP;AACH,GAtBD;AAuBA;;;;;;AAIAF,EAAAA,SAAS,CAACP,SAAV,CAAoBE,IAApB,GAA2B,YAAY;AACnC,QAAIM,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIc,SAAS,GAAGd,MAAM,CAACe,MAAvB;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,UAAIL,KAAK,GAAGZ,MAAM,CAACiB,CAAD,CAAlB;AACA,UAAIC,SAAS,GAAGN,KAAK,CAACG,MAAtB;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,YAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,YAAI3B,IAAJ,EAAU;AACN,iBAAOA,IAAP;AACH;AACJ;AACJ;;AACD,WAAO,IAAP;AACH,GAdD;;AAeAK,EAAAA,SAAS,CAACP,SAAV,CAAoB6D,IAApB,GAA2B,UAAUC,IAAV,EAAgBC,KAAhB,EAAuB;AAC9C,SAAKnB,IAAL,CAAU,UAAU1C,IAAV,EAAgB;AACtBA,MAAAA,IAAI,CAAC4D,IAAD,CAAJ,GAAaC,KAAb;AACH,KAFD;AAGA,WAAO,IAAP;AACH,GALD;;AAMAxD,EAAAA,SAAS,CAACP,SAAV,CAAoBgE,MAApB,GAA6B,UAAUF,IAAV,EAAgBC,KAAhB,EAAuB;AAChD,SAAKnB,IAAL,CAAU,UAAU1C,IAAV,EAAgBL,KAAhB,EAAuBsB,KAAvB,EAA8BC,KAA9B,EAAqC;AAC3ClB,MAAAA,IAAI,CAAC4D,IAAD,CAAJ,GAAaC,KAAK,CAAC7D,IAAD,EAAOL,KAAP,EAAcsB,KAAd,EAAqBC,KAArB,CAAlB;AACH,KAFD;AAGA,WAAO,IAAP;AACH,GALD;AAMA;;;;;;;AAKAb,EAAAA,SAAS,CAACP,SAAV,CAAoBiE,IAApB,GAA2B,UAAUpB,EAAV,EAAc;AACrCA,IAAAA,EAAE,CAAC,IAAD,CAAF;AACA,WAAO,IAAP;AACH,GAHD;;AAIAqB,EAAAA,MAAM,CAACC,cAAP,CAAsB5D,SAAS,CAACP,SAAhC,EAA2C,MAA3C,EAAmD;AAC/C;;;AAGAoE,IAAAA,GAAG,EAAE,YAAY;AACb,UAAIC,IAAI,GAAG,CAAX;AACA,WAAKzB,IAAL,CAAU,YAAY;AAAE,eAAOyB,IAAI,EAAX;AAAgB,OAAxC;AACA,aAAOA,IAAP;AACH,KAR8C;AAS/CC,IAAAA,UAAU,EAAE,IATmC;AAU/CC,IAAAA,YAAY,EAAE;AAViC,GAAnD;AAYAL,EAAAA,MAAM,CAACC,cAAP,CAAsB5D,SAAS,CAACP,SAAhC,EAA2C,MAA3C,EAAmD;AAC/C;;;AAGAoE,IAAAA,GAAG,EAAE,YAAY;AACb,UAAIlD,IAAI,GAAG,EAAX;AACA,WAAK0B,IAAL,CAAU,UAAU4B,CAAV,EAAa3E,KAAb,EAAoB;AAAE,eAAOqB,IAAI,CAACoB,IAAL,CAAUzC,KAAV,CAAP;AAA0B,OAA1D;AACA,aAAOqB,IAAP;AACH,KAR8C;AAS/CoD,IAAAA,UAAU,EAAE,IATmC;AAU/CC,IAAAA,YAAY,EAAE;AAViC,GAAnD;AAYAL,EAAAA,MAAM,CAACC,cAAP,CAAsB5D,SAAS,CAACP,SAAhC,EAA2C,OAA3C,EAAoD;AAChDoE,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,IAAI7D,SAAJ,CAAc,KAAKkE,WAAL,GAAmB,KAAKA,WAAxB,GAAsC,CAAC,EAAD,CAApD,EAA0D,KAAKhE,OAA/D,CAAP;AACH,KAH+C;AAIhD6D,IAAAA,UAAU,EAAE,IAJoC;AAKhDC,IAAAA,YAAY,EAAE;AALkC,GAApD;AAOAL,EAAAA,MAAM,CAACC,cAAP,CAAsB5D,SAAS,CAACP,SAAhC,EAA2C,MAA3C,EAAmD;AAC/CoE,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,IAAI7D,SAAJ,CAAc,KAAKmE,UAAL,GAAkB,KAAKA,UAAvB,GAAoC,CAAC,EAAD,CAAlD,EAAwD,KAAKjE,OAA7D,CAAP;AACH,KAH8C;AAI/C6D,IAAAA,UAAU,EAAE,IAJmC;AAK/CC,IAAAA,YAAY,EAAE;AALiC,GAAnD;AAOA;;;;;;;;AAOAhE,EAAAA,SAAS,CAACP,SAAV,CAAoB2E,QAApB,GAA+B,UAAUZ,KAAV,EAAiB;AAC5C,WAAO,KAAKnB,IAAL,CAAU,UAAU1C,IAAV,EAAgB;AAC7BA,MAAAA,IAAI,CAACL,KAAL,GAAakE,KAAb;AACH,KAFM,CAAP;AAGH,GAJD;;AAKAG,EAAAA,MAAM,CAACC,cAAP,CAAsB5D,SAAS,CAACP,SAAhC,EAA2C,OAA3C,EAAoD;AAChD;;;;AAIAoE,IAAAA,GAAG,EAAE,YAAY;AACb,UAAIlE,IAAI,GAAG,KAAKA,IAAL,EAAX;AACA,aAAOA,IAAI,GAAGA,IAAI,CAACL,KAAR,GAAgB,IAA3B;AACH,KAR+C;AAShDyE,IAAAA,UAAU,EAAE,IAToC;AAUhDC,IAAAA,YAAY,EAAE;AAVkC,GAApD;AAYA;;;;;;;;;;;;AAWAhE,EAAAA,SAAS,CAACP,SAAV,CAAoB4E,OAApB,GAA8B,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AACjD,QAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,UAAIE,MAAM,GAAGF,MAAb;;AACAA,MAAAA,MAAM,GAAG,YAAY;AAAE,eAAOE,MAAP;AAAgB,OAAvC;AACH;;AACD,QAAIvE,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIC,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIa,SAAS,GAAGd,MAAM,CAACe,MAAvB;AACA,QAAIyD,YAAY,GAAG,IAAIpD,KAAJ,CAAUN,SAAV,CAAnB;AACA,QAAImD,WAAW,GAAG,IAAI7C,KAAJ,CAAUN,SAAV,CAAlB;AACA,QAAIoD,UAAU,GAAG,IAAI9C,KAAJ,CAAUN,SAAV,CAAjB;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,UAAIL,KAAK,GAAGZ,MAAM,CAACiB,CAAD,CAAlB;AACA,UAAIwD,QAAQ,GAAGxE,OAAO,CAACgB,CAAD,CAAtB;;AACA,UAAI,CAACwD,QAAL,EAAe;AACX,cAAM,IAAI5E,KAAJ,CAAU,YAAYoB,CAAZ,GAAgB,kBAAhB,GAAqCL,KAA/C,CAAN;AACH;;AACD,UAAIM,SAAS,GAAGN,KAAK,CAACG,MAAtB;AACA,UAAIL,IAAI,GAAG2D,MAAM,CAACI,QAAD,EAAWA,QAAQ,CAACpF,KAApB,EAA2B4B,CAA3B,EAA8BhB,OAA9B,CAAjB;AACA,UAAIyE,QAAQ,GAAGhE,IAAI,CAACK,MAApB;AACA,UAAI4D,UAAU,GAAGV,WAAW,CAAChD,CAAD,CAAX,GAAiB,IAAIG,KAAJ,CAAUsD,QAAV,CAAlC;AACA,UAAIE,WAAW,GAAGJ,YAAY,CAACvD,CAAD,CAAZ,GAAkB,IAAIG,KAAJ,CAAUsD,QAAV,CAApC;AACA,UAAIG,SAAS,GAAGX,UAAU,CAACjD,CAAD,CAAV,GAAgB,IAAIG,KAAJ,CAAUF,SAAV,CAAhC;;AACA,UAAIoD,GAAJ,EAAS;AACL,aAAKQ,OAAL,CAAaL,QAAb,EAAuB7D,KAAvB,EAA8B+D,UAA9B,EAA0CC,WAA1C,EAAuDC,SAAvD,EAAkEnE,IAAlE,EAAwE4D,GAAxE;AACH,OAFD,MAGK;AACD,aAAKS,SAAL,CAAeN,QAAf,EAAyB7D,KAAzB,EAAgC+D,UAAhC,EAA4CC,WAA5C,EAAyDC,SAAzD,EAAoEnE,IAApE;AACH,OAjB+B,CAkBhC;AACA;AACA;;;AACA,WAAK,IAAIsE,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,CAAtB,EAAyBD,EAAE,GAAGN,QAA9B,EAAwCM,EAAE,EAA1C,EAA8C;AAC1C,YAAIE,QAAQ,GAAGP,UAAU,CAACK,EAAD,CAAzB;;AACA,YAAIE,QAAJ,EAAc;AACV,cAAIF,EAAE,IAAIC,EAAV,EAAc;AACVA,YAAAA,EAAE,GAAGD,EAAE,GAAG,CAAV;AACH;;AACD,cAAI1F,IAAI,GAAG,KAAK,CAAhB;;AACA,iBAAO,EAAEA,IAAI,GAAGsF,WAAW,CAACK,EAAD,CAApB,KAA6BA,EAAE,GAAGP,QAAzC,EAAmD;AAC/CO,YAAAA,EAAE;AACL;;AACDC,UAAAA,QAAQ,CAAC5F,IAAT,GAAgBA,IAAI,IAAI,IAAxB;AACH;AACJ;AACJ;;AACD,QAAI6F,MAAM,GAAG,IAAIpF,SAAJ,CAAcyE,YAAd,EAA4BvE,OAA5B,CAAb;AACAkF,IAAAA,MAAM,CAAClB,WAAP,GAAqBA,WAArB;AACAkB,IAAAA,MAAM,CAACjB,UAAP,GAAoBA,UAApB;AACA,WAAOiB,MAAP;AACH,GAlDD;;AAmDApF,EAAAA,SAAS,CAACP,SAAV,CAAoBuF,SAApB,GAAgC,UAAU3F,MAAV,EAAkBwB,KAAlB,EAAyBwE,KAAzB,EAAgCC,MAAhC,EAAwCC,IAAxC,EAA8C5E,IAA9C,EAAoD;AAChF,QAAIQ,SAAS,GAAGN,KAAK,CAACG,MAAtB;AACA,QAAI2D,QAAQ,GAAGhE,IAAI,CAACK,MAApB;AACA,QAAIM,CAAC,GAAG,CAAR;;AACA,WAAOA,CAAC,GAAGqD,QAAX,EAAqBrD,CAAC,EAAtB,EAA0B;AACtB,UAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,UAAI3B,IAAJ,EAAU;AACNA,QAAAA,IAAI,CAACL,KAAL,GAAaqB,IAAI,CAACW,CAAD,CAAjB;AACAgE,QAAAA,MAAM,CAAChE,CAAD,CAAN,GAAY3B,IAAZ;AACH,OAHD,MAIK;AAAE;AACH0F,QAAAA,KAAK,CAAC/D,CAAD,CAAL,GAAW,IAAIlC,SAAJ,CAAcC,MAAd,EAAsBsB,IAAI,CAACW,CAAD,CAA1B,CAAX;AACH;AACJ,KAb+E,CAchF;;;AACA,WAAOA,CAAC,GAAGH,SAAX,EAAsBG,CAAC,EAAvB,EAA2B;AACvB,UAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,UAAI3B,IAAJ,EAAU;AACN4F,QAAAA,IAAI,CAACjE,CAAD,CAAJ,GAAU3B,IAAV;AACH;AACJ;AACJ,GArBD;;AAsBAK,EAAAA,SAAS,CAACP,SAAV,CAAoBsF,OAApB,GAA8B,UAAU1F,MAAV,EAAkBwB,KAAlB,EAAyBwE,KAAzB,EAAgCC,MAAhC,EAAwCC,IAAxC,EAA8C5E,IAA9C,EAAoD4D,GAApD,EAAyD;AACnF,QAAIpD,SAAS,GAAGN,KAAK,CAACG,MAAtB;AACA,QAAI2D,QAAQ,GAAGhE,IAAI,CAACK,MAApB;AACA,QAAIwE,SAAS,GAAG,IAAInE,KAAJ,CAAUF,SAAV,CAAhB;AACA,QAAIsE,cAAc,GAAG,EAArB,CAJmF,CAKnF;AACA;;AACA,SAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,UAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,UAAI3B,IAAJ,EAAU;AACN,YAAI+F,QAAQ,GAAGF,SAAS,CAAClE,CAAD,CAAT,GAAetB,SAAS,CAAC2F,SAAV,GAAsBpB,GAAG,CAAC5E,IAAD,EAAOA,IAAI,CAACL,KAAZ,EAAmBgC,CAAnB,EAAsBT,KAAtB,CAAvD;;AACA,YAAI6E,QAAQ,IAAID,cAAhB,EAAgC;AAC5BF,UAAAA,IAAI,CAACjE,CAAD,CAAJ,GAAU3B,IAAV;AACH,SAFD,MAGK;AACD8F,UAAAA,cAAc,CAACC,QAAD,CAAd,GAA2B/F,IAA3B;AACH;AACJ;AACJ,KAlBkF,CAmBnF;AACA;AACA;;;AACA,SAAK,IAAI2B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,QAApB,EAA8BrD,CAAC,EAA/B,EAAmC;AAC/B,UAAIoE,QAAQ,GAAG1F,SAAS,CAAC2F,SAAV,GAAsBpB,GAAG,CAAClF,MAAD,EAASsB,IAAI,CAACW,CAAD,CAAb,EAAkBA,CAAlB,EAAqBX,IAArB,CAAxC;AACA,UAAIhB,IAAI,GAAG8F,cAAc,CAACC,QAAD,CAAzB;;AACA,UAAI/F,IAAJ,EAAU;AACN2F,QAAAA,MAAM,CAAChE,CAAD,CAAN,GAAY3B,IAAZ;AACAA,QAAAA,IAAI,CAACL,KAAL,GAAaqB,IAAI,CAACW,CAAD,CAAjB;AACAmE,QAAAA,cAAc,CAACC,QAAD,CAAd,GAA2BtF,SAA3B;AACH,OAJD,MAKK;AACDiF,QAAAA,KAAK,CAAC/D,CAAD,CAAL,GAAW,IAAIlC,SAAJ,CAAcC,MAAd,EAAsBsB,IAAI,CAACW,CAAD,CAA1B,CAAX;AACH;AACJ,KAjCkF,CAkCnF;;;AACA,SAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAChC,UAAI3B,IAAI,GAAGkB,KAAK,CAACS,CAAD,CAAhB;;AACA,UAAI3B,IAAI,IAAK8F,cAAc,CAACD,SAAS,CAAClE,CAAD,CAAV,CAAd,KAAiC3B,IAA9C,EAAqD;AACjD4F,QAAAA,IAAI,CAACjE,CAAD,CAAJ,GAAU3B,IAAV;AACH;AACJ;AACJ,GAzCD;;AA0CAK,EAAAA,SAAS,CAAC2F,SAAV,GAAsB,GAAtB,CAzbuC,CAybZ;;AAC3B,SAAO3F,SAAP;AACH,CA3b8B,EAA/B;;AA4bA,SAASA,SAAT","sourcesContent":["import { Node } from \"./node\";\nvar EnterNode = /** @class */ (function () {\n    function EnterNode(parent, datum) {\n        this.next = null;\n        this.scene = parent.scene;\n        this.parent = parent;\n        this.datum = datum;\n    }\n    EnterNode.prototype.appendChild = function (node) {\n        // This doesn't work without the `strict: true` in the `tsconfig.json`,\n        // so we must have two `if` checks below, instead of this single one.\n        // if (this.next && !Node.isNode(this.next)) {\n        //     throw new Error(`${this.next} is not a Node.`);\n        // }\n        if (this.next === null) {\n            return this.parent.insertBefore(node, null);\n        }\n        if (!Node.isNode(this.next)) {\n            throw new Error(this.next + \" is not a Node.\");\n        }\n        return this.parent.insertBefore(node, this.next);\n    };\n    EnterNode.prototype.insertBefore = function (node, nextNode) {\n        return this.parent.insertBefore(node, nextNode);\n    };\n    return EnterNode;\n}());\nexport { EnterNode };\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\nvar Selection = /** @class */ (function () {\n    function Selection(groups, parents) {\n        this.groups = groups;\n        this.parents = parents;\n    }\n    Selection.select = function (node) {\n        return new Selection([[typeof node === 'function' ? node() : node]], [undefined]);\n    };\n    Selection.selectAll = function (nodes) {\n        return new Selection([nodes == null ? [] : nodes], [undefined]);\n    };\n    /**\n     * Creates new nodes, appends them to the nodes of this selection and returns them\n     * as a new selection. The created nodes inherit the datums and the parents of the nodes\n     * they replace.\n     * @param Class The constructor function to use to create the new nodes.\n     */\n    Selection.prototype.append = function (Class) {\n        return this.select(function (node) {\n            return node.appendChild(new Class());\n        });\n    };\n    /**\n     * Same as the {@link append}, but accepts a custom creator function with the\n     * {@link NodeSelector} signature rather than a constructor function.\n     * @param creator\n     */\n    Selection.prototype.appendFn = function (creator) {\n        return this.select(function (node, data, index, group) {\n            return node.appendChild(creator(node, data, index, group));\n        });\n    };\n    /**\n     * Runs the given selector that returns a single node for every node in each group.\n     * The original nodes are then replaced by the nodes returned by the selector\n     * and returned as a new selection.\n     * The selected nodes inherit the datums and the parents of the original nodes.\n     */\n    Selection.prototype.select = function (selector) {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        var subgroups = [];\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            var subgroup = subgroups[j] = new Array(groupSize);\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    var subnode = selector(node, node.datum, i, group);\n                    if (subnode) {\n                        subnode.datum = node.datum;\n                    }\n                    subgroup[i] = subnode;\n                }\n                // else this can be a group of the `enter` selection,\n                // for example, with no nodes at the i-th position,\n                // only nodes at the end of the group\n            }\n        }\n        return new Selection(subgroups, this.parents);\n    };\n    /**\n     * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n     * @param Class The constructor function to use to find matching nodes.\n     */\n    Selection.prototype.selectByClass = function (Class) {\n        return this.select(function (node) {\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child instanceof Class) {\n                        return child;\n                    }\n                }\n            }\n        });\n    };\n    Selection.prototype.selectByTag = function (tag) {\n        return this.select(function (node) {\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child.tag === tag) {\n                        return child;\n                    }\n                }\n            }\n        });\n    };\n    Selection.prototype.selectAllByClass = function (Class) {\n        return this.selectAll(function (node) {\n            var nodes = [];\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child instanceof Class) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    };\n    Selection.prototype.selectAllByTag = function (tag) {\n        return this.selectAll(function (node) {\n            var nodes = [];\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child.tag === tag) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    };\n    Selection.prototype.selectNone = function () {\n        return [];\n    };\n    /**\n     * Runs the given selector that returns a group of nodes for every node in each group.\n     * The original nodes are then replaced by the groups of nodes returned by the selector\n     * and returned as a new selection. The original nodes become the parent nodes for each\n     * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n     * If called without any parameters, creates a new selection with an empty group for each\n     * node in this selection.\n     */\n    Selection.prototype.selectAll = function (selectorAll) {\n        if (!selectorAll) {\n            selectorAll = this.selectNone;\n        }\n        // Each subgroup is populated with the selector (run on each group node) results.\n        var subgroups = [];\n        // In the new selection that we return, subgroups become groups,\n        // and group nodes become parents.\n        var parents = [];\n        var groups = this.groups;\n        var groupCount = groups.length;\n        for (var j = 0; j < groupCount; j++) {\n            var group = groups[j];\n            var groupLength = group.length;\n            for (var i = 0; i < groupLength; i++) {\n                var node = group[i];\n                if (node) {\n                    subgroups.push(selectorAll(node, node.datum, i, group));\n                    parents.push(node);\n                }\n            }\n        }\n        return new Selection(subgroups, parents);\n    };\n    /**\n     * Runs the given callback for every node in this selection and returns this selection.\n     * @param cb\n     */\n    Selection.prototype.each = function (cb) {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    cb(node, node.datum, i, group);\n                }\n            }\n        }\n        return this;\n    };\n    Selection.prototype.remove = function () {\n        return this.each(function (node) {\n            if (Node.isNode(node)) {\n                var parent_1 = node.parent;\n                if (parent_1) {\n                    parent_1.removeChild(node);\n                }\n            }\n        });\n    };\n    Selection.prototype.merge = function (other) {\n        var groups0 = this.groups;\n        var groups1 = other.groups;\n        var m0 = groups0.length;\n        var m1 = groups1.length;\n        var m = Math.min(m0, m1);\n        var merges = new Array(m0);\n        var j = 0;\n        for (; j < m; j++) {\n            var group0 = groups0[j];\n            var group1 = groups1[j];\n            var n = group0.length;\n            var merge = merges[j] = new Array(n);\n            for (var i = 0; i < n; i++) {\n                var node = group0[i] || group1[i];\n                merge[i] = node || undefined;\n            }\n        }\n        for (; j < m0; j++) {\n            merges[j] = groups0[j];\n        }\n        return new Selection(merges, this.parents);\n    };\n    /**\n     * Return the first non-null element in this selection.\n     * If the selection is empty, returns null.\n     */\n    Selection.prototype.node = function () {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    };\n    Selection.prototype.attr = function (name, value) {\n        this.each(function (node) {\n            node[name] = value;\n        });\n        return this;\n    };\n    Selection.prototype.attrFn = function (name, value) {\n        this.each(function (node, datum, index, group) {\n            node[name] = value(node, datum, index, group);\n        });\n        return this;\n    };\n    /**\n     * Invokes the given function once, passing in this selection.\n     * Returns this selection. Facilitates method chaining.\n     * @param cb\n     */\n    Selection.prototype.call = function (cb) {\n        cb(this);\n        return this;\n    };\n    Object.defineProperty(Selection.prototype, \"size\", {\n        /**\n         * Returns the total number of nodes in this selection.\n         */\n        get: function () {\n            var size = 0;\n            this.each(function () { return size++; });\n            return size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"data\", {\n        /**\n         * Returns the array of data for the selected elements.\n         */\n        get: function () {\n            var data = [];\n            this.each(function (_, datum) { return data.push(datum); });\n            return data;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"enter\", {\n        get: function () {\n            return new Selection(this.enterGroups ? this.enterGroups : [[]], this.parents);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"exit\", {\n        get: function () {\n            return new Selection(this.exitGroups ? this.exitGroups : [[]], this.parents);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Binds the given value to each selected node and returns this selection\n     * with its {@link GDatum} type changed to the type of the given value.\n     * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n     * This method can also be used to clear bound data.\n     * @param value\n     */\n    Selection.prototype.setDatum = function (value) {\n        return this.each(function (node) {\n            node.datum = value;\n        });\n    };\n    Object.defineProperty(Selection.prototype, \"datum\", {\n        /**\n         * Returns the bound datum for the first non-null element in the selection.\n         * This is generally useful only if you know the selection contains exactly one element.\n         */\n        get: function () {\n            var node = this.node();\n            return node ? node.datum : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Binds the specified array of values with the selected nodes, returning a new selection\n     * that represents the _update_ selection: the nodes successfully bound to the values.\n     * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n     * which can be used to add or remove the nodes to correspond to the new data.\n     * The `values` is an array of values of a particular type, or a function that returns\n     * an array of values for each group.\n     * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n     * @param values\n     * @param key\n     */\n    Selection.prototype.setData = function (values, key) {\n        if (typeof values !== 'function') {\n            var data_1 = values;\n            values = function () { return data_1; };\n        }\n        var groups = this.groups;\n        var parents = this.parents;\n        var numGroups = groups.length;\n        var updateGroups = new Array(numGroups);\n        var enterGroups = new Array(numGroups);\n        var exitGroups = new Array(numGroups);\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var parent_2 = parents[j];\n            if (!parent_2) {\n                throw new Error(\"Group #\" + j + \" has no parent: \" + group);\n            }\n            var groupSize = group.length;\n            var data = values(parent_2, parent_2.datum, j, parents);\n            var dataSize = data.length;\n            var enterGroup = enterGroups[j] = new Array(dataSize);\n            var updateGroup = updateGroups[j] = new Array(dataSize);\n            var exitGroup = exitGroups[j] = new Array(groupSize);\n            if (key) {\n                this.bindKey(parent_2, group, enterGroup, updateGroup, exitGroup, data, key);\n            }\n            else {\n                this.bindIndex(parent_2, group, enterGroup, updateGroup, exitGroup, data);\n            }\n            // Now connect the enter nodes to their following update node, such that\n            // appendChild can insert the materialized enter node before this node,\n            // rather than at the end of the parent node.\n            for (var i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n                var previous = enterGroup[i0];\n                if (previous) {\n                    if (i0 >= i1) {\n                        i1 = i0 + 1;\n                    }\n                    var next = void 0;\n                    while (!(next = updateGroup[i1]) && i1 < dataSize) {\n                        i1++;\n                    }\n                    previous.next = next || null;\n                }\n            }\n        }\n        var result = new Selection(updateGroups, parents);\n        result.enterGroups = enterGroups;\n        result.exitGroups = exitGroups;\n        return result;\n    };\n    Selection.prototype.bindIndex = function (parent, group, enter, update, exit, data) {\n        var groupSize = group.length;\n        var dataSize = data.length;\n        var i = 0;\n        for (; i < dataSize; i++) {\n            var node = group[i];\n            if (node) {\n                node.datum = data[i];\n                update[i] = node;\n            }\n            else { // more datums than group nodes\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n        // more group nodes than datums\n        for (; i < groupSize; i++) {\n            var node = group[i];\n            if (node) {\n                exit[i] = node;\n            }\n        }\n    };\n    Selection.prototype.bindKey = function (parent, group, enter, update, exit, data, key) {\n        var groupSize = group.length;\n        var dataSize = data.length;\n        var keyValues = new Array(groupSize);\n        var nodeByKeyValue = {};\n        // Compute the key for each node.\n        // If multiple nodes have the same key, the duplicates are added to exit.\n        for (var i = 0; i < groupSize; i++) {\n            var node = group[i];\n            if (node) {\n                var keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n                if (keyValue in nodeByKeyValue) {\n                    exit[i] = node;\n                }\n                else {\n                    nodeByKeyValue[keyValue] = node;\n                }\n            }\n        }\n        // Compute the key for each datum.\n        // If there is a node associated with this key, join and add it to update.\n        // If there is not (or the key is a duplicate), add it to enter.\n        for (var i = 0; i < dataSize; i++) {\n            var keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n            var node = nodeByKeyValue[keyValue];\n            if (node) {\n                update[i] = node;\n                node.datum = data[i];\n                nodeByKeyValue[keyValue] = undefined;\n            }\n            else {\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n        // Add any remaining nodes that were not bound to data to exit.\n        for (var i = 0; i < groupSize; i++) {\n            var node = group[i];\n            if (node && (nodeByKeyValue[keyValues[i]] === node)) {\n                exit[i] = node;\n            }\n        }\n    };\n    Selection.keyPrefix = '$'; // Protect against keys like '__proto__'.\n    return Selection;\n}());\nexport { Selection };\n"]},"metadata":{},"sourceType":"module"}