{"ast":null,"code":"import { Node } from \"./node\";\nvar EnterNode = /** @class */function () {\n  function EnterNode(parent, datum) {\n    this.next = null;\n    this.scene = parent.scene;\n    this.parent = parent;\n    this.datum = datum;\n  }\n  EnterNode.prototype.appendChild = function (node) {\n    // This doesn't work without the `strict: true` in the `tsconfig.json`,\n    // so we must have two `if` checks below, instead of this single one.\n    // if (this.next && !Node.isNode(this.next)) {\n    //     throw new Error(`${this.next} is not a Node.`);\n    // }\n    if (this.next === null) {\n      return this.parent.insertBefore(node, null);\n    }\n    if (!Node.isNode(this.next)) {\n      throw new Error(this.next + \" is not a Node.\");\n    }\n    return this.parent.insertBefore(node, this.next);\n  };\n  EnterNode.prototype.insertBefore = function (node, nextNode) {\n    return this.parent.insertBefore(node, nextNode);\n  };\n  return EnterNode;\n}();\nexport { EnterNode };\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\nvar Selection = /** @class */function () {\n  function Selection(groups, parents) {\n    this.groups = groups;\n    this.parents = parents;\n  }\n  Selection.select = function (node) {\n    return new Selection([[typeof node === 'function' ? node() : node]], [undefined]);\n  };\n  Selection.selectAll = function (nodes) {\n    return new Selection([nodes == null ? [] : nodes], [undefined]);\n  };\n  /**\n   * Creates new nodes, appends them to the nodes of this selection and returns them\n   * as a new selection. The created nodes inherit the datums and the parents of the nodes\n   * they replace.\n   * @param Class The constructor function to use to create the new nodes.\n   */\n  Selection.prototype.append = function (Class) {\n    return this.select(function (node) {\n      return node.appendChild(new Class());\n    });\n  };\n  /**\n   * Same as the {@link append}, but accepts a custom creator function with the\n   * {@link NodeSelector} signature rather than a constructor function.\n   * @param creator\n   */\n  Selection.prototype.appendFn = function (creator) {\n    return this.select(function (node, data, index, group) {\n      return node.appendChild(creator(node, data, index, group));\n    });\n  };\n  /**\n   * Runs the given selector that returns a single node for every node in each group.\n   * The original nodes are then replaced by the nodes returned by the selector\n   * and returned as a new selection.\n   * The selected nodes inherit the datums and the parents of the original nodes.\n   */\n  Selection.prototype.select = function (selector) {\n    var groups = this.groups;\n    var numGroups = groups.length;\n    var subgroups = [];\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n      var subgroup = subgroups[j] = new Array(groupSize);\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n        if (node) {\n          var subnode = selector(node, node.datum, i, group);\n          if (subnode) {\n            subnode.datum = node.datum;\n          }\n          subgroup[i] = subnode;\n        }\n        // else this can be a group of the `enter` selection,\n        // for example, with no nodes at the i-th position,\n        // only nodes at the end of the group\n      }\n    }\n\n    return new Selection(subgroups, this.parents);\n  };\n  /**\n   * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n   * @param Class The constructor function to use to find matching nodes.\n   */\n  Selection.prototype.selectByClass = function (Class) {\n    return this.select(function (node) {\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n          if (child instanceof Class) {\n            return child;\n          }\n        }\n      }\n    });\n  };\n  Selection.prototype.selectByTag = function (tag) {\n    return this.select(function (node) {\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n          if (child.tag === tag) {\n            return child;\n          }\n        }\n      }\n    });\n  };\n  Selection.prototype.selectAllByClass = function (Class) {\n    return this.selectAll(function (node) {\n      var nodes = [];\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n          if (child instanceof Class) {\n            nodes.push(child);\n          }\n        }\n      }\n      return nodes;\n    });\n  };\n  Selection.prototype.selectAllByTag = function (tag) {\n    return this.selectAll(function (node) {\n      var nodes = [];\n      if (Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n          if (child.tag === tag) {\n            nodes.push(child);\n          }\n        }\n      }\n      return nodes;\n    });\n  };\n  Selection.prototype.selectNone = function () {\n    return [];\n  };\n  /**\n   * Runs the given selector that returns a group of nodes for every node in each group.\n   * The original nodes are then replaced by the groups of nodes returned by the selector\n   * and returned as a new selection. The original nodes become the parent nodes for each\n   * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n   * If called without any parameters, creates a new selection with an empty group for each\n   * node in this selection.\n   */\n  Selection.prototype.selectAll = function (selectorAll) {\n    if (!selectorAll) {\n      selectorAll = this.selectNone;\n    }\n    // Each subgroup is populated with the selector (run on each group node) results.\n    var subgroups = [];\n    // In the new selection that we return, subgroups become groups,\n    // and group nodes become parents.\n    var parents = [];\n    var groups = this.groups;\n    var groupCount = groups.length;\n    for (var j = 0; j < groupCount; j++) {\n      var group = groups[j];\n      var groupLength = group.length;\n      for (var i = 0; i < groupLength; i++) {\n        var node = group[i];\n        if (node) {\n          subgroups.push(selectorAll(node, node.datum, i, group));\n          parents.push(node);\n        }\n      }\n    }\n    return new Selection(subgroups, parents);\n  };\n  /**\n   * Runs the given callback for every node in this selection and returns this selection.\n   * @param cb\n   */\n  Selection.prototype.each = function (cb) {\n    var groups = this.groups;\n    var numGroups = groups.length;\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n        if (node) {\n          cb(node, node.datum, i, group);\n        }\n      }\n    }\n    return this;\n  };\n  Selection.prototype.remove = function () {\n    return this.each(function (node) {\n      if (Node.isNode(node)) {\n        var parent_1 = node.parent;\n        if (parent_1) {\n          parent_1.removeChild(node);\n        }\n      }\n    });\n  };\n  Selection.prototype.merge = function (other) {\n    var groups0 = this.groups;\n    var groups1 = other.groups;\n    var m0 = groups0.length;\n    var m1 = groups1.length;\n    var m = Math.min(m0, m1);\n    var merges = new Array(m0);\n    var j = 0;\n    for (; j < m; j++) {\n      var group0 = groups0[j];\n      var group1 = groups1[j];\n      var n = group0.length;\n      var merge = merges[j] = new Array(n);\n      for (var i = 0; i < n; i++) {\n        var node = group0[i] || group1[i];\n        merge[i] = node || undefined;\n      }\n    }\n    for (; j < m0; j++) {\n      merges[j] = groups0[j];\n    }\n    return new Selection(merges, this.parents);\n  };\n  /**\n   * Return the first non-null element in this selection.\n   * If the selection is empty, returns null.\n   */\n  Selection.prototype.node = function () {\n    var groups = this.groups;\n    var numGroups = groups.length;\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n        if (node) {\n          return node;\n        }\n      }\n    }\n    return null;\n  };\n  Selection.prototype.attr = function (name, value) {\n    this.each(function (node) {\n      node[name] = value;\n    });\n    return this;\n  };\n  Selection.prototype.attrFn = function (name, value) {\n    this.each(function (node, datum, index, group) {\n      node[name] = value(node, datum, index, group);\n    });\n    return this;\n  };\n  /**\n   * Invokes the given function once, passing in this selection.\n   * Returns this selection. Facilitates method chaining.\n   * @param cb\n   */\n  Selection.prototype.call = function (cb) {\n    cb(this);\n    return this;\n  };\n  Object.defineProperty(Selection.prototype, \"size\", {\n    /**\n     * Returns the total number of nodes in this selection.\n     */\n    get: function () {\n      var size = 0;\n      this.each(function () {\n        return size++;\n      });\n      return size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"data\", {\n    /**\n     * Returns the array of data for the selected elements.\n     */\n    get: function () {\n      var data = [];\n      this.each(function (_, datum) {\n        return data.push(datum);\n      });\n      return data;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"enter\", {\n    get: function () {\n      return new Selection(this.enterGroups ? this.enterGroups : [[]], this.parents);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"exit\", {\n    get: function () {\n      return new Selection(this.exitGroups ? this.exitGroups : [[]], this.parents);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Binds the given value to each selected node and returns this selection\n   * with its {@link GDatum} type changed to the type of the given value.\n   * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n   * This method can also be used to clear bound data.\n   * @param value\n   */\n  Selection.prototype.setDatum = function (value) {\n    return this.each(function (node) {\n      node.datum = value;\n    });\n  };\n  Object.defineProperty(Selection.prototype, \"datum\", {\n    /**\n     * Returns the bound datum for the first non-null element in the selection.\n     * This is generally useful only if you know the selection contains exactly one element.\n     */\n    get: function () {\n      var node = this.node();\n      return node ? node.datum : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Binds the specified array of values with the selected nodes, returning a new selection\n   * that represents the _update_ selection: the nodes successfully bound to the values.\n   * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n   * which can be used to add or remove the nodes to correspond to the new data.\n   * The `values` is an array of values of a particular type, or a function that returns\n   * an array of values for each group.\n   * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n   * @param values\n   * @param key\n   */\n  Selection.prototype.setData = function (values, key) {\n    if (typeof values !== 'function') {\n      var data_1 = values;\n      values = function () {\n        return data_1;\n      };\n    }\n    var groups = this.groups;\n    var parents = this.parents;\n    var numGroups = groups.length;\n    var updateGroups = new Array(numGroups);\n    var enterGroups = new Array(numGroups);\n    var exitGroups = new Array(numGroups);\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var parent_2 = parents[j];\n      if (!parent_2) {\n        throw new Error(\"Group #\" + j + \" has no parent: \" + group);\n      }\n      var groupSize = group.length;\n      var data = values(parent_2, parent_2.datum, j, parents);\n      var dataSize = data.length;\n      var enterGroup = enterGroups[j] = new Array(dataSize);\n      var updateGroup = updateGroups[j] = new Array(dataSize);\n      var exitGroup = exitGroups[j] = new Array(groupSize);\n      if (key) {\n        this.bindKey(parent_2, group, enterGroup, updateGroup, exitGroup, data, key);\n      } else {\n        this.bindIndex(parent_2, group, enterGroup, updateGroup, exitGroup, data);\n      }\n      // Now connect the enter nodes to their following update node, such that\n      // appendChild can insert the materialized enter node before this node,\n      // rather than at the end of the parent node.\n      for (var i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n        var previous = enterGroup[i0];\n        if (previous) {\n          if (i0 >= i1) {\n            i1 = i0 + 1;\n          }\n          var next = void 0;\n          while (!(next = updateGroup[i1]) && i1 < dataSize) {\n            i1++;\n          }\n          previous.next = next || null;\n        }\n      }\n    }\n    var result = new Selection(updateGroups, parents);\n    result.enterGroups = enterGroups;\n    result.exitGroups = exitGroups;\n    return result;\n  };\n  Selection.prototype.bindIndex = function (parent, group, enter, update, exit, data) {\n    var groupSize = group.length;\n    var dataSize = data.length;\n    var i = 0;\n    for (; i < dataSize; i++) {\n      var node = group[i];\n      if (node) {\n        node.datum = data[i];\n        update[i] = node;\n      } else {\n        // more datums than group nodes\n        enter[i] = new EnterNode(parent, data[i]);\n      }\n    }\n    // more group nodes than datums\n    for (; i < groupSize; i++) {\n      var node = group[i];\n      if (node) {\n        exit[i] = node;\n      }\n    }\n  };\n  Selection.prototype.bindKey = function (parent, group, enter, update, exit, data, key) {\n    var groupSize = group.length;\n    var dataSize = data.length;\n    var keyValues = new Array(groupSize);\n    var nodeByKeyValue = {};\n    // Compute the key for each node.\n    // If multiple nodes have the same key, the duplicates are added to exit.\n    for (var i = 0; i < groupSize; i++) {\n      var node = group[i];\n      if (node) {\n        var keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n        if (keyValue in nodeByKeyValue) {\n          exit[i] = node;\n        } else {\n          nodeByKeyValue[keyValue] = node;\n        }\n      }\n    }\n    // Compute the key for each datum.\n    // If there is a node associated with this key, join and add it to update.\n    // If there is not (or the key is a duplicate), add it to enter.\n    for (var i = 0; i < dataSize; i++) {\n      var keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n      var node = nodeByKeyValue[keyValue];\n      if (node) {\n        update[i] = node;\n        node.datum = data[i];\n        nodeByKeyValue[keyValue] = undefined;\n      } else {\n        enter[i] = new EnterNode(parent, data[i]);\n      }\n    }\n    // Add any remaining nodes that were not bound to data to exit.\n    for (var i = 0; i < groupSize; i++) {\n      var node = group[i];\n      if (node && nodeByKeyValue[keyValues[i]] === node) {\n        exit[i] = node;\n      }\n    }\n  };\n  Selection.keyPrefix = '$'; // Protect against keys like '__proto__'.\n  return Selection;\n}();\nexport { Selection };","map":{"version":3,"names":["Node","EnterNode","parent","datum","next","scene","prototype","appendChild","node","insertBefore","isNode","Error","nextNode","Selection","groups","parents","select","undefined","selectAll","nodes","append","Class","appendFn","creator","data","index","group","selector","numGroups","length","subgroups","j","groupSize","subgroup","Array","i","subnode","selectByClass","children","n","child","selectByTag","tag","selectAllByClass","push","selectAllByTag","selectNone","selectorAll","groupCount","groupLength","each","cb","remove","parent_1","removeChild","merge","other","groups0","groups1","m0","m1","m","Math","min","merges","group0","group1","attr","name","value","attrFn","call","Object","defineProperty","get","size","enumerable","configurable","_","enterGroups","exitGroups","setDatum","setData","values","key","data_1","updateGroups","parent_2","dataSize","enterGroup","updateGroup","exitGroup","bindKey","bindIndex","i0","i1","previous","result","enter","update","exit","keyValues","nodeByKeyValue","keyValue","keyPrefix"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/selection.js"],"sourcesContent":["import { Node } from \"./node\";\nvar EnterNode = /** @class */ (function () {\n    function EnterNode(parent, datum) {\n        this.next = null;\n        this.scene = parent.scene;\n        this.parent = parent;\n        this.datum = datum;\n    }\n    EnterNode.prototype.appendChild = function (node) {\n        // This doesn't work without the `strict: true` in the `tsconfig.json`,\n        // so we must have two `if` checks below, instead of this single one.\n        // if (this.next && !Node.isNode(this.next)) {\n        //     throw new Error(`${this.next} is not a Node.`);\n        // }\n        if (this.next === null) {\n            return this.parent.insertBefore(node, null);\n        }\n        if (!Node.isNode(this.next)) {\n            throw new Error(this.next + \" is not a Node.\");\n        }\n        return this.parent.insertBefore(node, this.next);\n    };\n    EnterNode.prototype.insertBefore = function (node, nextNode) {\n        return this.parent.insertBefore(node, nextNode);\n    };\n    return EnterNode;\n}());\nexport { EnterNode };\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\nvar Selection = /** @class */ (function () {\n    function Selection(groups, parents) {\n        this.groups = groups;\n        this.parents = parents;\n    }\n    Selection.select = function (node) {\n        return new Selection([[typeof node === 'function' ? node() : node]], [undefined]);\n    };\n    Selection.selectAll = function (nodes) {\n        return new Selection([nodes == null ? [] : nodes], [undefined]);\n    };\n    /**\n     * Creates new nodes, appends them to the nodes of this selection and returns them\n     * as a new selection. The created nodes inherit the datums and the parents of the nodes\n     * they replace.\n     * @param Class The constructor function to use to create the new nodes.\n     */\n    Selection.prototype.append = function (Class) {\n        return this.select(function (node) {\n            return node.appendChild(new Class());\n        });\n    };\n    /**\n     * Same as the {@link append}, but accepts a custom creator function with the\n     * {@link NodeSelector} signature rather than a constructor function.\n     * @param creator\n     */\n    Selection.prototype.appendFn = function (creator) {\n        return this.select(function (node, data, index, group) {\n            return node.appendChild(creator(node, data, index, group));\n        });\n    };\n    /**\n     * Runs the given selector that returns a single node for every node in each group.\n     * The original nodes are then replaced by the nodes returned by the selector\n     * and returned as a new selection.\n     * The selected nodes inherit the datums and the parents of the original nodes.\n     */\n    Selection.prototype.select = function (selector) {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        var subgroups = [];\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            var subgroup = subgroups[j] = new Array(groupSize);\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    var subnode = selector(node, node.datum, i, group);\n                    if (subnode) {\n                        subnode.datum = node.datum;\n                    }\n                    subgroup[i] = subnode;\n                }\n                // else this can be a group of the `enter` selection,\n                // for example, with no nodes at the i-th position,\n                // only nodes at the end of the group\n            }\n        }\n        return new Selection(subgroups, this.parents);\n    };\n    /**\n     * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n     * @param Class The constructor function to use to find matching nodes.\n     */\n    Selection.prototype.selectByClass = function (Class) {\n        return this.select(function (node) {\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child instanceof Class) {\n                        return child;\n                    }\n                }\n            }\n        });\n    };\n    Selection.prototype.selectByTag = function (tag) {\n        return this.select(function (node) {\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child.tag === tag) {\n                        return child;\n                    }\n                }\n            }\n        });\n    };\n    Selection.prototype.selectAllByClass = function (Class) {\n        return this.selectAll(function (node) {\n            var nodes = [];\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child instanceof Class) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    };\n    Selection.prototype.selectAllByTag = function (tag) {\n        return this.selectAll(function (node) {\n            var nodes = [];\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child.tag === tag) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    };\n    Selection.prototype.selectNone = function () {\n        return [];\n    };\n    /**\n     * Runs the given selector that returns a group of nodes for every node in each group.\n     * The original nodes are then replaced by the groups of nodes returned by the selector\n     * and returned as a new selection. The original nodes become the parent nodes for each\n     * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n     * If called without any parameters, creates a new selection with an empty group for each\n     * node in this selection.\n     */\n    Selection.prototype.selectAll = function (selectorAll) {\n        if (!selectorAll) {\n            selectorAll = this.selectNone;\n        }\n        // Each subgroup is populated with the selector (run on each group node) results.\n        var subgroups = [];\n        // In the new selection that we return, subgroups become groups,\n        // and group nodes become parents.\n        var parents = [];\n        var groups = this.groups;\n        var groupCount = groups.length;\n        for (var j = 0; j < groupCount; j++) {\n            var group = groups[j];\n            var groupLength = group.length;\n            for (var i = 0; i < groupLength; i++) {\n                var node = group[i];\n                if (node) {\n                    subgroups.push(selectorAll(node, node.datum, i, group));\n                    parents.push(node);\n                }\n            }\n        }\n        return new Selection(subgroups, parents);\n    };\n    /**\n     * Runs the given callback for every node in this selection and returns this selection.\n     * @param cb\n     */\n    Selection.prototype.each = function (cb) {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    cb(node, node.datum, i, group);\n                }\n            }\n        }\n        return this;\n    };\n    Selection.prototype.remove = function () {\n        return this.each(function (node) {\n            if (Node.isNode(node)) {\n                var parent_1 = node.parent;\n                if (parent_1) {\n                    parent_1.removeChild(node);\n                }\n            }\n        });\n    };\n    Selection.prototype.merge = function (other) {\n        var groups0 = this.groups;\n        var groups1 = other.groups;\n        var m0 = groups0.length;\n        var m1 = groups1.length;\n        var m = Math.min(m0, m1);\n        var merges = new Array(m0);\n        var j = 0;\n        for (; j < m; j++) {\n            var group0 = groups0[j];\n            var group1 = groups1[j];\n            var n = group0.length;\n            var merge = merges[j] = new Array(n);\n            for (var i = 0; i < n; i++) {\n                var node = group0[i] || group1[i];\n                merge[i] = node || undefined;\n            }\n        }\n        for (; j < m0; j++) {\n            merges[j] = groups0[j];\n        }\n        return new Selection(merges, this.parents);\n    };\n    /**\n     * Return the first non-null element in this selection.\n     * If the selection is empty, returns null.\n     */\n    Selection.prototype.node = function () {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    };\n    Selection.prototype.attr = function (name, value) {\n        this.each(function (node) {\n            node[name] = value;\n        });\n        return this;\n    };\n    Selection.prototype.attrFn = function (name, value) {\n        this.each(function (node, datum, index, group) {\n            node[name] = value(node, datum, index, group);\n        });\n        return this;\n    };\n    /**\n     * Invokes the given function once, passing in this selection.\n     * Returns this selection. Facilitates method chaining.\n     * @param cb\n     */\n    Selection.prototype.call = function (cb) {\n        cb(this);\n        return this;\n    };\n    Object.defineProperty(Selection.prototype, \"size\", {\n        /**\n         * Returns the total number of nodes in this selection.\n         */\n        get: function () {\n            var size = 0;\n            this.each(function () { return size++; });\n            return size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"data\", {\n        /**\n         * Returns the array of data for the selected elements.\n         */\n        get: function () {\n            var data = [];\n            this.each(function (_, datum) { return data.push(datum); });\n            return data;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"enter\", {\n        get: function () {\n            return new Selection(this.enterGroups ? this.enterGroups : [[]], this.parents);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"exit\", {\n        get: function () {\n            return new Selection(this.exitGroups ? this.exitGroups : [[]], this.parents);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Binds the given value to each selected node and returns this selection\n     * with its {@link GDatum} type changed to the type of the given value.\n     * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n     * This method can also be used to clear bound data.\n     * @param value\n     */\n    Selection.prototype.setDatum = function (value) {\n        return this.each(function (node) {\n            node.datum = value;\n        });\n    };\n    Object.defineProperty(Selection.prototype, \"datum\", {\n        /**\n         * Returns the bound datum for the first non-null element in the selection.\n         * This is generally useful only if you know the selection contains exactly one element.\n         */\n        get: function () {\n            var node = this.node();\n            return node ? node.datum : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Binds the specified array of values with the selected nodes, returning a new selection\n     * that represents the _update_ selection: the nodes successfully bound to the values.\n     * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n     * which can be used to add or remove the nodes to correspond to the new data.\n     * The `values` is an array of values of a particular type, or a function that returns\n     * an array of values for each group.\n     * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n     * @param values\n     * @param key\n     */\n    Selection.prototype.setData = function (values, key) {\n        if (typeof values !== 'function') {\n            var data_1 = values;\n            values = function () { return data_1; };\n        }\n        var groups = this.groups;\n        var parents = this.parents;\n        var numGroups = groups.length;\n        var updateGroups = new Array(numGroups);\n        var enterGroups = new Array(numGroups);\n        var exitGroups = new Array(numGroups);\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var parent_2 = parents[j];\n            if (!parent_2) {\n                throw new Error(\"Group #\" + j + \" has no parent: \" + group);\n            }\n            var groupSize = group.length;\n            var data = values(parent_2, parent_2.datum, j, parents);\n            var dataSize = data.length;\n            var enterGroup = enterGroups[j] = new Array(dataSize);\n            var updateGroup = updateGroups[j] = new Array(dataSize);\n            var exitGroup = exitGroups[j] = new Array(groupSize);\n            if (key) {\n                this.bindKey(parent_2, group, enterGroup, updateGroup, exitGroup, data, key);\n            }\n            else {\n                this.bindIndex(parent_2, group, enterGroup, updateGroup, exitGroup, data);\n            }\n            // Now connect the enter nodes to their following update node, such that\n            // appendChild can insert the materialized enter node before this node,\n            // rather than at the end of the parent node.\n            for (var i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n                var previous = enterGroup[i0];\n                if (previous) {\n                    if (i0 >= i1) {\n                        i1 = i0 + 1;\n                    }\n                    var next = void 0;\n                    while (!(next = updateGroup[i1]) && i1 < dataSize) {\n                        i1++;\n                    }\n                    previous.next = next || null;\n                }\n            }\n        }\n        var result = new Selection(updateGroups, parents);\n        result.enterGroups = enterGroups;\n        result.exitGroups = exitGroups;\n        return result;\n    };\n    Selection.prototype.bindIndex = function (parent, group, enter, update, exit, data) {\n        var groupSize = group.length;\n        var dataSize = data.length;\n        var i = 0;\n        for (; i < dataSize; i++) {\n            var node = group[i];\n            if (node) {\n                node.datum = data[i];\n                update[i] = node;\n            }\n            else { // more datums than group nodes\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n        // more group nodes than datums\n        for (; i < groupSize; i++) {\n            var node = group[i];\n            if (node) {\n                exit[i] = node;\n            }\n        }\n    };\n    Selection.prototype.bindKey = function (parent, group, enter, update, exit, data, key) {\n        var groupSize = group.length;\n        var dataSize = data.length;\n        var keyValues = new Array(groupSize);\n        var nodeByKeyValue = {};\n        // Compute the key for each node.\n        // If multiple nodes have the same key, the duplicates are added to exit.\n        for (var i = 0; i < groupSize; i++) {\n            var node = group[i];\n            if (node) {\n                var keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n                if (keyValue in nodeByKeyValue) {\n                    exit[i] = node;\n                }\n                else {\n                    nodeByKeyValue[keyValue] = node;\n                }\n            }\n        }\n        // Compute the key for each datum.\n        // If there is a node associated with this key, join and add it to update.\n        // If there is not (or the key is a duplicate), add it to enter.\n        for (var i = 0; i < dataSize; i++) {\n            var keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n            var node = nodeByKeyValue[keyValue];\n            if (node) {\n                update[i] = node;\n                node.datum = data[i];\n                nodeByKeyValue[keyValue] = undefined;\n            }\n            else {\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n        // Add any remaining nodes that were not bound to data to exit.\n        for (var i = 0; i < groupSize; i++) {\n            var node = group[i];\n            if (node && (nodeByKeyValue[keyValues[i]] === node)) {\n                exit[i] = node;\n            }\n        }\n    };\n    Selection.keyPrefix = '$'; // Protect against keys like '__proto__'.\n    return Selection;\n}());\nexport { Selection };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}