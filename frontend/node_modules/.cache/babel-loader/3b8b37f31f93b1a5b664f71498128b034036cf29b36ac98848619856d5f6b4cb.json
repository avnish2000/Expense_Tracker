{"ast":null,"code":"import { Matrix } from \"./matrix\";\nimport { createId } from \"../util/id\";\nexport var PointerEvents;\n(function (PointerEvents) {\n  PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n  PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nvar Node = /** @class */function () {\n  function Node() {\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = createId(this);\n    /**\n     * Some number to identify this node, typically within a `Group` node.\n     * Usually this will be some enum value used as a selector.\n     */\n    this.tag = NaN;\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this._children = [];\n    // Used to check for duplicate nodes.\n    this.childSet = {}; // new Set<Node>()\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    this.matrix = new Matrix();\n    this.inverseMatrix = new Matrix();\n    this._dirtyTransform = false;\n    this._scalingX = 1;\n    this._scalingY = 1;\n    /**\n     * The center of scaling.\n     * The default value of `null` means the scaling center will be\n     * determined automatically, as the center of the bounding box\n     * of a node.\n     */\n    this._scalingCenterX = null;\n    this._scalingCenterY = null;\n    this._rotationCenterX = null;\n    this._rotationCenterY = null;\n    /**\n     * Rotation angle in radians.\n     * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n     * interval is performed.\n     */\n    this._rotation = 0;\n    this._translationX = 0;\n    this._translationY = 0;\n    /**\n     * Each time a property of the node that effects how it renders changes\n     * the `dirty` property of the node should be set to `true`. The change\n     * to the `dirty` property of the node will propagate up to its parents\n     * and eventually to the scene, at which point an animation frame callback\n     * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n     * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n     * Since changes to node properties are not rendered immediately, it's possible\n     * to change as many properties on as many nodes as needed and the rendering\n     * will still only happen once in the next animation frame callback.\n     * The animation frame callback is only scheduled if it hasn't been already.\n     */\n    this._dirty = true;\n    this._visible = true;\n    this.pointerEvents = PointerEvents.All;\n  }\n  /**\n   * This is meaningfully faster than `instanceof` and should be the preferred way\n   * of checking inside loops.\n   * @param node\n   */\n  Node.isNode = function (node) {\n    return node ? node.matrix !== undefined : false;\n  };\n  Node.prototype._setScene = function (value) {\n    this._scene = value;\n    var children = this.children;\n    var n = children.length;\n    for (var i = 0; i < n; i++) {\n      children[i]._setScene(value);\n    }\n  };\n  Object.defineProperty(Node.prototype, \"scene\", {\n    get: function () {\n      return this._scene;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype._setParent = function (value) {\n    this._parent = value;\n  };\n  Object.defineProperty(Node.prototype, \"parent\", {\n    get: function () {\n      return this._parent;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"children\", {\n    get: function () {\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.countChildren = function (depth) {\n    if (depth === void 0) {\n      depth = Node.MAX_SAFE_INTEGER;\n    }\n    if (depth <= 0) {\n      return 0;\n    }\n    var children = this.children;\n    var n = children.length;\n    var size = n;\n    for (var i = 0; i < n; i++) {\n      size += children[i].countChildren(depth - 1);\n    }\n    return size;\n  };\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  Node.prototype.append = function (nodes) {\n    // Passing a single parameter to an open-ended version of `append`\n    // would be 30-35% slower than this.\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    // The function takes an array rather than having open-ended\n    // arguments like `...nodes: Node[]` because the latter is\n    // transpiled to a function where the `arguments` object\n    // is copied to a temporary array inside a loop.\n    // So an array is created either way. And if we already have\n    // an array of nodes we want to add, we have to use the prohibitively\n    // expensive spread operator to pass it to the function,\n    // and, on top of that, the copy of the `arguments` is still made.\n    var n = nodes.length;\n    for (var i = 0; i < n; i++) {\n      var node = nodes[i];\n      if (node.parent) {\n        throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n      }\n      if (node.scene) {\n        throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n      }\n      if (this.childSet[node.id]) {\n        // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n        throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n      }\n      this._children.push(node);\n      this.childSet[node.id] = true;\n      node._setParent(this);\n      node._setScene(this.scene);\n    }\n    this.dirty = true;\n  };\n  Node.prototype.appendChild = function (node) {\n    if (node.parent) {\n      throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n    }\n    if (node.scene) {\n      throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n    }\n    if (this.childSet[node.id]) {\n      // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n      throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n    }\n    this._children.push(node);\n    this.childSet[node.id] = true;\n    node._setParent(this);\n    node._setScene(this.scene);\n    this.dirty = true;\n    return node;\n  };\n  Node.prototype.removeChild = function (node) {\n    if (node.parent === this) {\n      var i = this.children.indexOf(node);\n      if (i >= 0) {\n        this._children.splice(i, 1);\n        delete this.childSet[node.id];\n        node._setParent(undefined);\n        node._setScene(undefined);\n        this.dirty = true;\n        return node;\n      }\n    }\n    throw new Error(\"The node to be removed is not a child of this node.\");\n  };\n  /**\n   * Inserts the node `node` before the existing child node `nextNode`.\n   * If `nextNode` is null, insert `node` at the end of the list of children.\n   * If the `node` belongs to another parent, it is first removed.\n   * Returns the `node`.\n   * @param node\n   * @param nextNode\n   */\n  Node.prototype.insertBefore = function (node, nextNode) {\n    var parent = node.parent;\n    if (node.parent) {\n      node.parent.removeChild(node);\n    }\n    if (nextNode && nextNode.parent === this) {\n      var i = this.children.indexOf(nextNode);\n      if (i >= 0) {\n        this._children.splice(i, 0, node);\n        this.childSet[node.id] = true;\n        node._setParent(this);\n        node._setScene(this.scene);\n      } else {\n        throw new Error(nextNode + \" has \" + parent + \" as the parent, \" + \"but is not in its list of children.\");\n      }\n      this.dirty = true;\n    } else {\n      this.append(node);\n    }\n    return node;\n  };\n  Object.defineProperty(Node.prototype, \"nextSibling\", {\n    get: function () {\n      var parent = this.parent;\n      if (parent) {\n        var children = parent.children;\n        var index = children.indexOf(this);\n        if (index >= 0 && index <= children.length - 1) {\n          return children[index + 1];\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.transformPoint = function (x, y) {\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    return matrix.invertSelf().transformPoint(x, y);\n  };\n  Node.prototype.inverseTransformPoint = function (x, y) {\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    return matrix.transformPoint(x, y);\n  };\n  Object.defineProperty(Node.prototype, \"dirtyTransform\", {\n    get: function () {\n      return this._dirtyTransform;\n    },\n    set: function (value) {\n      this._dirtyTransform = value;\n      if (value) {\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingX\", {\n    get: function () {\n      return this._scalingX;\n    },\n    set: function (value) {\n      if (this._scalingX !== value) {\n        this._scalingX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingY\", {\n    get: function () {\n      return this._scalingY;\n    },\n    set: function (value) {\n      if (this._scalingY !== value) {\n        this._scalingY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingCenterX\", {\n    get: function () {\n      return this._scalingCenterX;\n    },\n    set: function (value) {\n      if (this._scalingCenterX !== value) {\n        this._scalingCenterX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingCenterY\", {\n    get: function () {\n      return this._scalingCenterY;\n    },\n    set: function (value) {\n      if (this._scalingCenterY !== value) {\n        this._scalingCenterY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationCenterX\", {\n    get: function () {\n      return this._rotationCenterX;\n    },\n    set: function (value) {\n      if (this._rotationCenterX !== value) {\n        this._rotationCenterX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationCenterY\", {\n    get: function () {\n      return this._rotationCenterY;\n    },\n    set: function (value) {\n      if (this._rotationCenterY !== value) {\n        this._rotationCenterY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotation\", {\n    get: function () {\n      return this._rotation;\n    },\n    set: function (value) {\n      if (this._rotation !== value) {\n        this._rotation = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationDeg\", {\n    get: function () {\n      return this.rotation / Math.PI * 180;\n    },\n    /**\n     * For performance reasons the rotation angle's internal representation\n     * is in radians. Therefore, don't expect to get the same number you set.\n     * Even with integer angles about a quarter of them from 0 to 359 cannot\n     * be converted to radians and back without precision loss.\n     * For example:\n     *\n     *     node.rotationDeg = 11;\n     *     console.log(node.rotationDeg); // 10.999999999999998\n     *\n     * @param value Rotation angle in degrees.\n     */\n    set: function (value) {\n      this.rotation = value / 180 * Math.PI;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"translationX\", {\n    get: function () {\n      return this._translationX;\n    },\n    set: function (value) {\n      if (this._translationX !== value) {\n        this._translationX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"translationY\", {\n    get: function () {\n      return this._translationY;\n    },\n    set: function (value) {\n      if (this._translationY !== value) {\n        this._translationY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.containsPoint = function (x, y) {\n    return false;\n  };\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   * @param x\n   * @param y\n   */\n  Node.prototype.pickNode = function (x, y) {\n    if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n      return;\n    }\n    var children = this.children;\n    if (children.length) {\n      // Nodes added later should be hit-tested first,\n      // as they are rendered on top of the previously added nodes.\n      for (var i = children.length - 1; i >= 0; i--) {\n        var hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      // a leaf node, but not a container leaf\n      return this;\n    }\n  };\n  Node.prototype.computeBBox = function () {\n    return;\n  };\n  Node.prototype.computeBBoxCenter = function () {\n    var bbox = this.computeBBox && this.computeBBox();\n    if (bbox) {\n      return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];\n    }\n    return [0, 0];\n  };\n  Node.prototype.computeTransformMatrix = function () {\n    // TODO: transforms without center of scaling and rotation correspond directly\n    //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n    //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n    //       within a group, rotating groups at right angles (e.g. for axis) and translating\n    //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n    //       can be done using D3-like scales already by inverting the output range.\n    //       So for now, just assume that centers of scaling and rotation are at the origin.\n    // const [bbcx, bbcy] = this.computeBBoxCenter();\n    var _a = [0, 0],\n      bbcx = _a[0],\n      bbcy = _a[1];\n    var sx = this.scalingX;\n    var sy = this.scalingY;\n    var scx;\n    var scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n      scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n    }\n    var r = this.rotation;\n    var cos = Math.cos(r);\n    var sin = Math.sin(r);\n    var rcx;\n    var rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n      rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n    }\n    var tx = this.translationX;\n    var ty = this.translationY;\n    // The transform matrix `M` is a result of the following transformations:\n    // 1) translate the center of scaling to the origin\n    // 2) scale\n    // 3) translate back\n    // 4) translate the center of rotation to the origin\n    // 5) rotate\n    // 6) translate back\n    // 7) translate\n    //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n    //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n    // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n    //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n    // Translation after steps 1-4 above:\n    var tx4 = scx * (1 - sx) - rcx;\n    var ty4 = scy * (1 - sy) - rcy;\n    this.dirtyTransform = false;\n    this.matrix.setElements([cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx4 - sin * ty4 + rcx + tx, sin * tx4 + cos * ty4 + rcy + ty]).inverseTo(this.inverseMatrix);\n  };\n  Object.defineProperty(Node.prototype, \"dirty\", {\n    get: function () {\n      return this._dirty;\n    },\n    set: function (value) {\n      // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n      //       if we are, then all parents and the scene have been\n      //       notified already, and we are doing redundant work\n      //       (but test if this is indeed the case)\n      this._dirty = value;\n      if (value) {\n        if (this.parent) {\n          this.parent.dirty = true;\n        } else if (this.scene) {\n          this.scene.dirty = true;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"visible\", {\n    get: function () {\n      return this._visible;\n    },\n    set: function (value) {\n      if (this._visible !== value) {\n        this._visible = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n  return Node;\n}();\nexport { Node };","map":{"version":3,"names":["Matrix","createId","PointerEvents","Node","id","tag","NaN","isContainerNode","_children","childSet","matrix","inverseMatrix","_dirtyTransform","_scalingX","_scalingY","_scalingCenterX","_scalingCenterY","_rotationCenterX","_rotationCenterY","_rotation","_translationX","_translationY","_dirty","_visible","pointerEvents","All","isNode","node","undefined","prototype","_setScene","value","_scene","children","n","length","i","Object","defineProperty","get","enumerable","configurable","_setParent","_parent","countChildren","depth","MAX_SAFE_INTEGER","size","append","nodes","parent","Error","scene","constructor","name","push","dirty","appendChild","removeChild","indexOf","splice","insertBefore","nextNode","index","transformPoint","x","y","flyweight","preMultiplySelf","invertSelf","inverseTransformPoint","set","dirtyTransform","rotation","Math","PI","containsPoint","pickNode","visible","None","hit","computeBBox","computeBBoxCenter","bbox","width","height","computeTransformMatrix","_a","bbcx","bbcy","sx","scalingX","sy","scalingY","scx","scy","scalingCenterX","scalingCenterY","r","cos","sin","rcx","rcy","rotationCenterX","rotationCenterY","tx","translationX","ty","translationY","tx4","ty4","setElements","inverseTo","pow"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/node.js"],"sourcesContent":["import { Matrix } from \"./matrix\";\nimport { createId } from \"../util/id\";\nexport var PointerEvents;\n(function (PointerEvents) {\n    PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n    PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        /**\n         * Unique node ID in the form `ClassName-NaturalNumber`.\n         */\n        this.id = createId(this);\n        /**\n         * Some number to identify this node, typically within a `Group` node.\n         * Usually this will be some enum value used as a selector.\n         */\n        this.tag = NaN;\n        /**\n         * To simplify the type system (especially in Selections) we don't have the `Parent` node\n         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n         * But we still need to distinguish regular leaf nodes from container leafs somehow.\n         */\n        this.isContainerNode = false;\n        this._children = [];\n        // Used to check for duplicate nodes.\n        this.childSet = {}; // new Set<Node>()\n        // These matrices may need to have package level visibility\n        // for performance optimization purposes.\n        this.matrix = new Matrix();\n        this.inverseMatrix = new Matrix();\n        this._dirtyTransform = false;\n        this._scalingX = 1;\n        this._scalingY = 1;\n        /**\n         * The center of scaling.\n         * The default value of `null` means the scaling center will be\n         * determined automatically, as the center of the bounding box\n         * of a node.\n         */\n        this._scalingCenterX = null;\n        this._scalingCenterY = null;\n        this._rotationCenterX = null;\n        this._rotationCenterY = null;\n        /**\n         * Rotation angle in radians.\n         * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n         * interval is performed.\n         */\n        this._rotation = 0;\n        this._translationX = 0;\n        this._translationY = 0;\n        /**\n         * Each time a property of the node that effects how it renders changes\n         * the `dirty` property of the node should be set to `true`. The change\n         * to the `dirty` property of the node will propagate up to its parents\n         * and eventually to the scene, at which point an animation frame callback\n         * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n         * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n         * Since changes to node properties are not rendered immediately, it's possible\n         * to change as many properties on as many nodes as needed and the rendering\n         * will still only happen once in the next animation frame callback.\n         * The animation frame callback is only scheduled if it hasn't been already.\n         */\n        this._dirty = true;\n        this._visible = true;\n        this.pointerEvents = PointerEvents.All;\n    }\n    /**\n     * This is meaningfully faster than `instanceof` and should be the preferred way\n     * of checking inside loops.\n     * @param node\n     */\n    Node.isNode = function (node) {\n        return node ? node.matrix !== undefined : false;\n    };\n    Node.prototype._setScene = function (value) {\n        this._scene = value;\n        var children = this.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n            children[i]._setScene(value);\n        }\n    };\n    Object.defineProperty(Node.prototype, \"scene\", {\n        get: function () {\n            return this._scene;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype._setParent = function (value) {\n        this._parent = value;\n    };\n    Object.defineProperty(Node.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"children\", {\n        get: function () {\n            return this._children;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.countChildren = function (depth) {\n        if (depth === void 0) { depth = Node.MAX_SAFE_INTEGER; }\n        if (depth <= 0) {\n            return 0;\n        }\n        var children = this.children;\n        var n = children.length;\n        var size = n;\n        for (var i = 0; i < n; i++) {\n            size += children[i].countChildren(depth - 1);\n        }\n        return size;\n    };\n    /**\n     * Appends one or more new node instances to this parent.\n     * If one needs to:\n     * - move a child to the end of the list of children\n     * - move a child from one parent to another (including parents in other scenes)\n     * one should use the {@link insertBefore} method instead.\n     * @param nodes A node or nodes to append.\n     */\n    Node.prototype.append = function (nodes) {\n        // Passing a single parameter to an open-ended version of `append`\n        // would be 30-35% slower than this.\n        if (Node.isNode(nodes)) {\n            nodes = [nodes];\n        }\n        // The function takes an array rather than having open-ended\n        // arguments like `...nodes: Node[]` because the latter is\n        // transpiled to a function where the `arguments` object\n        // is copied to a temporary array inside a loop.\n        // So an array is created either way. And if we already have\n        // an array of nodes we want to add, we have to use the prohibitively\n        // expensive spread operator to pass it to the function,\n        // and, on top of that, the copy of the `arguments` is still made.\n        var n = nodes.length;\n        for (var i = 0; i < n; i++) {\n            var node = nodes[i];\n            if (node.parent) {\n                throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n            }\n            if (node.scene) {\n                throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n            }\n            if (this.childSet[node.id]) {\n                // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n                throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n            }\n            this._children.push(node);\n            this.childSet[node.id] = true;\n            node._setParent(this);\n            node._setScene(this.scene);\n        }\n        this.dirty = true;\n    };\n    Node.prototype.appendChild = function (node) {\n        if (node.parent) {\n            throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n        }\n        if (node.scene) {\n            throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n        }\n        if (this.childSet[node.id]) {\n            // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n            throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n        }\n        this._children.push(node);\n        this.childSet[node.id] = true;\n        node._setParent(this);\n        node._setScene(this.scene);\n        this.dirty = true;\n        return node;\n    };\n    Node.prototype.removeChild = function (node) {\n        if (node.parent === this) {\n            var i = this.children.indexOf(node);\n            if (i >= 0) {\n                this._children.splice(i, 1);\n                delete this.childSet[node.id];\n                node._setParent(undefined);\n                node._setScene(undefined);\n                this.dirty = true;\n                return node;\n            }\n        }\n        throw new Error(\"The node to be removed is not a child of this node.\");\n    };\n    /**\n     * Inserts the node `node` before the existing child node `nextNode`.\n     * If `nextNode` is null, insert `node` at the end of the list of children.\n     * If the `node` belongs to another parent, it is first removed.\n     * Returns the `node`.\n     * @param node\n     * @param nextNode\n     */\n    Node.prototype.insertBefore = function (node, nextNode) {\n        var parent = node.parent;\n        if (node.parent) {\n            node.parent.removeChild(node);\n        }\n        if (nextNode && nextNode.parent === this) {\n            var i = this.children.indexOf(nextNode);\n            if (i >= 0) {\n                this._children.splice(i, 0, node);\n                this.childSet[node.id] = true;\n                node._setParent(this);\n                node._setScene(this.scene);\n            }\n            else {\n                throw new Error(nextNode + \" has \" + parent + \" as the parent, \"\n                    + \"but is not in its list of children.\");\n            }\n            this.dirty = true;\n        }\n        else {\n            this.append(node);\n        }\n        return node;\n    };\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        get: function () {\n            var parent = this.parent;\n            if (parent) {\n                var children = parent.children;\n                var index = children.indexOf(this);\n                if (index >= 0 && index <= children.length - 1) {\n                    return children[index + 1];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.transformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.invertSelf().transformPoint(x, y);\n    };\n    Node.prototype.inverseTransformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.transformPoint(x, y);\n    };\n    Object.defineProperty(Node.prototype, \"dirtyTransform\", {\n        get: function () {\n            return this._dirtyTransform;\n        },\n        set: function (value) {\n            this._dirtyTransform = value;\n            if (value) {\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingX\", {\n        get: function () {\n            return this._scalingX;\n        },\n        set: function (value) {\n            if (this._scalingX !== value) {\n                this._scalingX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingY\", {\n        get: function () {\n            return this._scalingY;\n        },\n        set: function (value) {\n            if (this._scalingY !== value) {\n                this._scalingY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingCenterX\", {\n        get: function () {\n            return this._scalingCenterX;\n        },\n        set: function (value) {\n            if (this._scalingCenterX !== value) {\n                this._scalingCenterX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingCenterY\", {\n        get: function () {\n            return this._scalingCenterY;\n        },\n        set: function (value) {\n            if (this._scalingCenterY !== value) {\n                this._scalingCenterY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationCenterX\", {\n        get: function () {\n            return this._rotationCenterX;\n        },\n        set: function (value) {\n            if (this._rotationCenterX !== value) {\n                this._rotationCenterX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationCenterY\", {\n        get: function () {\n            return this._rotationCenterY;\n        },\n        set: function (value) {\n            if (this._rotationCenterY !== value) {\n                this._rotationCenterY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotation\", {\n        get: function () {\n            return this._rotation;\n        },\n        set: function (value) {\n            if (this._rotation !== value) {\n                this._rotation = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationDeg\", {\n        get: function () {\n            return this.rotation / Math.PI * 180;\n        },\n        /**\n         * For performance reasons the rotation angle's internal representation\n         * is in radians. Therefore, don't expect to get the same number you set.\n         * Even with integer angles about a quarter of them from 0 to 359 cannot\n         * be converted to radians and back without precision loss.\n         * For example:\n         *\n         *     node.rotationDeg = 11;\n         *     console.log(node.rotationDeg); // 10.999999999999998\n         *\n         * @param value Rotation angle in degrees.\n         */\n        set: function (value) {\n            this.rotation = value / 180 * Math.PI;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"translationX\", {\n        get: function () {\n            return this._translationX;\n        },\n        set: function (value) {\n            if (this._translationX !== value) {\n                this._translationX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"translationY\", {\n        get: function () {\n            return this._translationY;\n        },\n        set: function (value) {\n            if (this._translationY !== value) {\n                this._translationY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.containsPoint = function (x, y) {\n        return false;\n    };\n    /**\n     * Hit testing method.\n     * Recursively checks if the given point is inside this node or any of its children.\n     * Returns the first matching node or `undefined`.\n     * Nodes that render later (show on top) are hit tested first.\n     * @param x\n     * @param y\n     */\n    Node.prototype.pickNode = function (x, y) {\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n            return;\n        }\n        var children = this.children;\n        if (children.length) {\n            // Nodes added later should be hit-tested first,\n            // as they are rendered on top of the previously added nodes.\n            for (var i = children.length - 1; i >= 0; i--) {\n                var hit = children[i].pickNode(x, y);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n        else if (!this.isContainerNode) { // a leaf node, but not a container leaf\n            return this;\n        }\n    };\n    Node.prototype.computeBBox = function () { return; };\n    Node.prototype.computeBBoxCenter = function () {\n        var bbox = this.computeBBox && this.computeBBox();\n        if (bbox) {\n            return [\n                bbox.x + bbox.width * 0.5,\n                bbox.y + bbox.height * 0.5\n            ];\n        }\n        return [0, 0];\n    };\n    Node.prototype.computeTransformMatrix = function () {\n        // TODO: transforms without center of scaling and rotation correspond directly\n        //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n        //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n        //       within a group, rotating groups at right angles (e.g. for axis) and translating\n        //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n        //       can be done using D3-like scales already by inverting the output range.\n        //       So for now, just assume that centers of scaling and rotation are at the origin.\n        // const [bbcx, bbcy] = this.computeBBoxCenter();\n        var _a = [0, 0], bbcx = _a[0], bbcy = _a[1];\n        var sx = this.scalingX;\n        var sy = this.scalingY;\n        var scx;\n        var scy;\n        if (sx === 1 && sy === 1) {\n            scx = 0;\n            scy = 0;\n        }\n        else {\n            scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n            scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n        }\n        var r = this.rotation;\n        var cos = Math.cos(r);\n        var sin = Math.sin(r);\n        var rcx;\n        var rcy;\n        if (r === 0) {\n            rcx = 0;\n            rcy = 0;\n        }\n        else {\n            rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n            rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n        }\n        var tx = this.translationX;\n        var ty = this.translationY;\n        // The transform matrix `M` is a result of the following transformations:\n        // 1) translate the center of scaling to the origin\n        // 2) scale\n        // 3) translate back\n        // 4) translate the center of rotation to the origin\n        // 5) rotate\n        // 6) translate back\n        // 7) translate\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n        // Translation after steps 1-4 above:\n        var tx4 = scx * (1 - sx) - rcx;\n        var ty4 = scy * (1 - sy) - rcy;\n        this.dirtyTransform = false;\n        this.matrix.setElements([\n            cos * sx, sin * sx,\n            -sin * sy, cos * sy,\n            cos * tx4 - sin * ty4 + rcx + tx,\n            sin * tx4 + cos * ty4 + rcy + ty\n        ]).inverseTo(this.inverseMatrix);\n    };\n    Object.defineProperty(Node.prototype, \"dirty\", {\n        get: function () {\n            return this._dirty;\n        },\n        set: function (value) {\n            // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n            //       if we are, then all parents and the scene have been\n            //       notified already, and we are doing redundant work\n            //       (but test if this is indeed the case)\n            this._dirty = value;\n            if (value) {\n                if (this.parent) {\n                    this.parent.dirty = true;\n                }\n                else if (this.scene) {\n                    this.scene.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"visible\", {\n        get: function () {\n            return this._visible;\n        },\n        set: function (value) {\n            if (this._visible !== value) {\n                this._visible = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n    return Node;\n}());\nexport { Node };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}