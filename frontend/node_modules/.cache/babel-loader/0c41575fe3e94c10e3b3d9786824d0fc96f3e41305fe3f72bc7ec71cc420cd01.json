{"ast":null,"code":"// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    var value = arr[i];\n    if (predicate(value, i, arr)) {\n      return value;\n    }\n  }\n}\nexport function findIndex(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\nexport function extent(values) {\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n  while (++i < n) {\n    // Find the first comparable finite value.\n    if ((value = values[i]) != null && value >= value) {\n      min = max = value;\n      while (++i < n) {\n        // Compare the remaining values.\n        if ((value = values[i]) != null) {\n          if (min > value) {\n            min = value;\n          }\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n  return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\nexport function finiteExtent(values) {\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n  while (++i < n) {\n    // Find the first comparable finite value.\n    if ((value = values[i]) != null && value >= value && isFinite(value)) {\n      min = max = value;\n      while (++i < n) {\n        // Compare the remaining values.\n        if ((value = values[i]) != null && isFinite(value)) {\n          if (min > value) {\n            min = value;\n          }\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n  return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\nexport function numericExtent(values) {\n  var calculatedExtent = finiteExtent(values);\n  if (typeof calculatedExtent === 'undefined') {\n    return;\n  }\n  var a = calculatedExtent[0],\n    b = calculatedExtent[1];\n  var min = a instanceof Date ? a.getTime() : a;\n  var max = b instanceof Date ? b.getTime() : b;\n  if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n    return [min, max];\n  }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values) {\n  var min = 0;\n  var max = 0;\n  for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n    var value = values_1[_i];\n    if (value < 0) {\n      min += value;\n    } else {\n      max += value;\n    }\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function findLargestMinMax(totals) {\n  var min = 0;\n  var max = 0;\n  for (var _i = 0, totals_1 = totals; _i < totals_1.length; _i++) {\n    var total = totals_1[_i];\n    if (total.min < min) {\n      min = total.min;\n    }\n    if (total.max > max) {\n      max = total.max;\n    }\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function copy(array, start, count) {\n  if (start === void 0) {\n    start = 0;\n  }\n  if (count === void 0) {\n    count = array.length;\n  }\n  var result = [];\n  var n = array.length;\n  if (n) {\n    for (var i = 0; i < count; i++) {\n      result.push(array[(start + i) % n]);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["find","arr","predicate","i","length","value","findIndex","extent","values","n","min","max","undefined","finiteExtent","isFinite","numericExtent","calculatedExtent","a","b","Date","getTime","findMinMax","_i","values_1","findLargestMinMax","totals","totals_1","total","copy","array","start","count","result","push"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/util/array.js"],"sourcesContent":["// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            return value;\n        }\n    }\n}\nexport function findIndex(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (predicate(arr[i], i, arr)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\nexport function extent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\nexport function finiteExtent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value && isFinite(value)) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null && isFinite(value)) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\nexport function numericExtent(values) {\n    var calculatedExtent = finiteExtent(values);\n    if (typeof calculatedExtent === 'undefined') {\n        return;\n    }\n    var a = calculatedExtent[0], b = calculatedExtent[1];\n    var min = a instanceof Date ? a.getTime() : a;\n    var max = b instanceof Date ? b.getTime() : b;\n    if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n        return [min, max];\n    }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values) {\n    var min = 0;\n    var max = 0;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var value = values_1[_i];\n        if (value < 0) {\n            min += value;\n        }\n        else {\n            max += value;\n        }\n    }\n    return { min: min, max: max };\n}\nexport function findLargestMinMax(totals) {\n    var min = 0;\n    var max = 0;\n    for (var _i = 0, totals_1 = totals; _i < totals_1.length; _i++) {\n        var total = totals_1[_i];\n        if (total.min < min) {\n            min = total.min;\n        }\n        if (total.max > max) {\n            max = total.max;\n        }\n    }\n    return { min: min, max: max };\n}\nexport function copy(array, start, count) {\n    if (start === void 0) { start = 0; }\n    if (count === void 0) { count = array.length; }\n    var result = [];\n    var n = array.length;\n    if (n) {\n        for (var i = 0; i < count; i++) {\n            result.push(array[(start + i) % n]);\n        }\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}