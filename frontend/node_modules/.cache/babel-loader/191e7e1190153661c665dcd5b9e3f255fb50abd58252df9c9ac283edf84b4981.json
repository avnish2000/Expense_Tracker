{"ast":null,"code":"import { cubicSegmentIntersections, segmentIntersection } from \"./intersection\";\nvar Path2D = /** @class */function () {\n  function Path2D() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.commands = [];\n    this.params = [];\n    this._closedPath = false;\n  }\n  Path2D.prototype.moveTo = function (x, y) {\n    if (this.xy) {\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n    this.commands.push('M');\n    this.params.push(x, y);\n  };\n  Path2D.prototype.lineTo = function (x, y) {\n    if (this.xy) {\n      this.commands.push('L');\n      this.params.push(x, y);\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  Path2D.prototype.rect = function (x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  };\n  /**\n   * Adds an arc segment to the path definition.\n   * https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n   * @param rx The major-axis radius.\n   * @param ry The minor-axis radius.\n   * @param rotation The x-axis rotation, expressed in radians.\n   * @param fA The large arc flag. `1` to use angle > π.\n   * @param fS The sweep flag. `1` for the arc that goes to `x`/`y` clockwise.\n   * @param x2 The x coordinate to arc to.\n   * @param y2 The y coordinate to arc to.\n   */\n  Path2D.prototype.arcTo = function (rx, ry, rotation, fA, fS, x2, y2) {\n    // Convert from endpoint to center parametrization:\n    // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n    var xy = this.xy;\n    if (!xy) {\n      return;\n    }\n    if (rx < 0) {\n      rx = -rx;\n    }\n    if (ry < 0) {\n      ry = -ry;\n    }\n    var x1 = xy[0];\n    var y1 = xy[1];\n    var hdx = (x1 - x2) / 2;\n    var hdy = (y1 - y2) / 2;\n    var sinPhi = Math.sin(rotation);\n    var cosPhi = Math.cos(rotation);\n    var xp = cosPhi * hdx + sinPhi * hdy;\n    var yp = -sinPhi * hdx + cosPhi * hdy;\n    var ratX = xp / rx;\n    var ratY = yp / ry;\n    var lambda = ratX * ratX + ratY * ratY;\n    var cx = (x1 + x2) / 2;\n    var cy = (y1 + y2) / 2;\n    var cpx = 0;\n    var cpy = 0;\n    if (lambda >= 1) {\n      lambda = Math.sqrt(lambda);\n      rx *= lambda;\n      ry *= lambda;\n      // me gives lambda == cpx == cpy == 0;\n    } else {\n      lambda = Math.sqrt(1 / lambda - 1);\n      if (fA === fS) {\n        lambda = -lambda;\n      }\n      cpx = lambda * rx * ratY;\n      cpy = -lambda * ry * ratX;\n      cx += cosPhi * cpx - sinPhi * cpy;\n      cy += sinPhi * cpx + cosPhi * cpy;\n    }\n    var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx);\n    var deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;\n    // if (fS) {\n    //     if (deltaTheta <= 0) {\n    //         deltaTheta += Math.PI * 2;\n    //     }\n    // }\n    // else {\n    //     if (deltaTheta >= 0) {\n    //         deltaTheta -= Math.PI * 2;\n    //     }\n    // }\n    this.cubicArc(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);\n  };\n  Path2D.prototype.arcToAlt = function (rx, ry, rotation, fA, fS, x2, y2) {\n    // Convert from endpoint to center parametrization. See:\n    // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n    if (!this.xy) {\n      return;\n    }\n    if (rx < 0) {\n      rx = -rx;\n    }\n    if (ry < 0) {\n      ry = -ry;\n    }\n    var x1 = this.xy[0];\n    var y1 = this.xy[1];\n    var hdx = (x1 - x2) / 2;\n    var hdy = (y1 - y2) / 2;\n    var sinPhi = Math.sin(rotation);\n    var cosPhi = Math.cos(rotation);\n    var x1p = cosPhi * hdx + sinPhi * hdy;\n    var y1p = -sinPhi * hdx + cosPhi * hdy;\n    var rx_y1p = rx * rx * y1p * y1p;\n    var ry_x1p = ry * ry * x1p * x1p;\n    var root = Math.sqrt((rx * rx * ry * ry - rx_y1p - ry_x1p) / (rx_y1p + ry_x1p));\n    var rootSign = fA === fS ? 0 : 1;\n    var cxp = rootSign * root * rx * y1p / ry;\n    var cyp = -rootSign * root * ry * x1p / rx;\n    var cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;\n    var cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;\n    var theta1 = Math.acos((x1p - cxp) / rx / ((x1p - cxp) / rx));\n  };\n  /**\n   * Approximates an elliptical arc with up to four cubic Bézier curves.\n   * @param commands The string array to write SVG command letters to.\n   * @param params The number array to write SVG command parameters (cubic control points) to.\n   * @param cx The x-axis coordinate for the ellipse's center.\n   * @param cy The y-axis coordinate for the ellipse's center.\n   * @param rx The ellipse's major-axis radius.\n   * @param ry The ellipse's minor-axis radius.\n   * @param phi The rotation for this ellipse, expressed in radians.\n   * @param theta1 The starting angle, measured clockwise from the positive x-axis and expressed in radians.\n   * @param theta2 The ending angle, measured clockwise from the positive x-axis and expressed in radians.\n   * @param anticlockwise The arc control points are always placed clockwise from `theta1` to `theta2`,\n   * even when `theta1 > theta2`, unless this flag is set to `1`.\n   */\n  Path2D.cubicArc = function (commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n    if (anticlockwise) {\n      var temp = theta1;\n      theta1 = theta2;\n      theta2 = temp;\n    }\n    var start = params.length;\n    // See https://pomax.github.io/bezierinfo/#circles_cubic\n    // Arc of unit circle (start angle = 0, end angle <= π/2) in cubic Bézier coordinates:\n    // S = [1, 0]\n    // C1 = [1, f]\n    // C2 = [cos(θ) + f * sin(θ), sin(θ) - f * cos(θ)]\n    // E = [cos(θ), sin(θ)]\n    // f = 4/3 * tan(θ/4)\n    var f90 = 0.5522847498307935; // f for θ = π/2 is 4/3 * (Math.sqrt(2) - 1)\n    var sinTheta1 = Math.sin(theta1);\n    var cosTheta1 = Math.cos(theta1);\n    var sinPhi = Math.sin(phi);\n    var cosPhi = Math.cos(phi);\n    var rightAngle = Math.PI / 2;\n    // Since we know how to draw an arc of a unit circle with a cubic Bézier,\n    // to draw an elliptical arc with arbitrary rotation and radii we:\n    // 1) rotate the Bézier coordinates that represent a circular arc by θ\n    // 2) scale the circular arc separately along the x/y axes, making it elliptical\n    // 3) rotate elliptical arc by φ\n    // |cos(φ) -sin(φ)| |sx  0| |cos(θ) -sin(θ)| -> |xx xy|\n    // |sin(φ)  cos(φ)| | 0 sy| |sin(θ)  cos(θ)| -> |yx yy|\n    var xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry;\n    var yx = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry;\n    var xy = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry;\n    var yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry;\n    // TODO: what if delta between θ1 and θ2 is greater than 2π?\n    // Always draw clockwise from θ1 to θ2.\n    theta2 -= theta1;\n    if (theta2 < 0) {\n      theta2 += Math.PI * 2;\n    }\n    // Multiplying each point [x, y] by:\n    // |xx xy cx| |x|\n    // |yx yy cy| |y|\n    // | 0  0  1| |1|\n    // TODO: This move command may be redundant, if we are already at this point.\n    // The coordinates of the point calculated here may differ ever so slightly\n    // because of precision error.\n    commands.push('M');\n    params.push(xx + cx, yx + cy);\n    while (theta2 >= rightAngle) {\n      theta2 -= rightAngle;\n      commands.push('C');\n      // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n      // Revert this commit when fixed ^^.\n      var lastX = xy + cx;\n      params.push(xx + xy * f90 + cx, yx + yy * f90 + cy, xx * f90 + xy + cx, yx * f90 + yy + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yy + cy);\n      // Prepend π/2 rotation matrix.\n      // |xx xy| | 0 1| -> | xy -xx|\n      // |yx yy| |-1 0| -> | yy -yx|\n      // [xx, yx, xy, yy] = [xy, yy, -xx, -yx];\n      // Compared to swapping with a temp variable, destructuring is:\n      // - 10% faster in Chrome 70\n      // - 99% slower in Firefox 63\n      // Temp variable solution is 45% faster in FF than Chrome.\n      // https://jsperf.com/multi-swap\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1165569\n      var temp = xx;\n      xx = xy;\n      xy = -temp;\n      temp = yx;\n      yx = yy;\n      yy = -temp;\n    }\n    if (theta2) {\n      var f = 4 / 3 * Math.tan(theta2 / 4);\n      var sinPhi2 = Math.sin(theta2);\n      var cosPhi2 = Math.cos(theta2);\n      var C2x = cosPhi2 + f * sinPhi2;\n      var C2y = sinPhi2 - f * cosPhi2;\n      commands.push('C');\n      // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n      // Revert this commit when fixed ^^.\n      var lastX = xx * cosPhi2 + xy * sinPhi2 + cx;\n      params.push(xx + xy * f + cx, yx + yy * f + cy, xx * C2x + xy * C2y + cx, yx * C2x + yy * C2y + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yx * cosPhi2 + yy * sinPhi2 + cy);\n    }\n    if (anticlockwise) {\n      for (var i = start, j = params.length - 2; i < j; i += 2, j -= 2) {\n        var temp = params[i];\n        params[i] = params[j];\n        params[j] = temp;\n        temp = params[i + 1];\n        params[i + 1] = params[j + 1];\n        params[j + 1] = temp;\n      }\n    }\n  };\n  Path2D.prototype.cubicArc = function (cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n    var commands = this.commands;\n    var params = this.params;\n    var start = commands.length;\n    Path2D.cubicArc(commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise);\n    var x = params[params.length - 2];\n    var y = params[params.length - 1];\n    if (this.xy) {\n      commands[start] = 'L';\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n  };\n  /**\n   * Returns the `[x, y]` coordinates of the curve at `t`.\n   * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n   * @param t\n   */\n  Path2D.prototype.deCasteljau = function (points, t) {\n    var n = points.length;\n    if (n < 2 || n % 2 === 1) {\n      throw new Error('Fewer than two points or not an even count.');\n    } else if (n === 2 || t === 0) {\n      return points.slice(0, 2);\n    } else if (t === 1) {\n      return points.slice(-2);\n    } else {\n      var newPoints = [];\n      var last = n - 2;\n      for (var i = 0; i < last; i += 2) {\n        newPoints.push((1 - t) * points[i] + t * points[i + 2],\n        // x\n        (1 - t) * points[i + 1] + t * points[i + 3] // y\n        );\n      }\n\n      return this.deCasteljau(newPoints, t);\n    }\n  };\n  /**\n   * Approximates the given curve using `n` line segments.\n   * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n   * @param n\n   */\n  Path2D.prototype.approximateCurve = function (points, n) {\n    var xy = this.deCasteljau(points, 0);\n    this.moveTo(xy[0], xy[1]);\n    var step = 1 / n;\n    for (var t = step; t <= 1; t += step) {\n      var xy_1 = this.deCasteljau(points, t);\n      this.lineTo(xy_1[0], xy_1[1]);\n    }\n  };\n  /**\n   * Adds a quadratic curve segment to the path definition.\n   * Note: the given quadratic segment is converted and stored as a cubic one.\n   * @param cx x-component of the curve's control point\n   * @param cy y-component of the curve's control point\n   * @param x x-component of the end point\n   * @param y y-component of the end point\n   */\n  Path2D.prototype.quadraticCurveTo = function (cx, cy, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx, cy);\n    }\n    // See https://pomax.github.io/bezierinfo/#reordering\n    this.cubicCurveTo((this.xy[0] + 2 * cx) / 3, (this.xy[1] + 2 * cy) / 3,\n    // 1/3 start + 2/3 control\n    (2 * cx + x) / 3, (2 * cy + y) / 3,\n    // 2/3 control + 1/3 end\n    x, y);\n  };\n  Path2D.prototype.cubicCurveTo = function (cx1, cy1, cx2, cy2, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx1, cy1);\n    }\n    this.commands.push('C');\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n    this.xy[0] = x;\n    this.xy[1] = y;\n  };\n  Object.defineProperty(Path2D.prototype, \"closedPath\", {\n    get: function () {\n      return this._closedPath;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Path2D.prototype.closePath = function () {\n    if (this.xy) {\n      this.xy = undefined;\n      this.commands.push('Z');\n      this._closedPath = true;\n    }\n  };\n  Path2D.prototype.clear = function () {\n    this.commands.length = 0;\n    this.params.length = 0;\n    this.xy = undefined;\n    this._closedPath = false;\n  };\n  Path2D.prototype.isPointInPath = function (x, y) {\n    var commands = this.commands;\n    var params = this.params;\n    var cn = commands.length;\n    // Hit testing using ray casting method, where the ray's origin is some point\n    // outside the path. In this case, an offscreen point that is remote enough, so that\n    // even if the path itself is large and is partially offscreen, the ray's origin\n    // will likely be outside the path anyway. To test if the given point is inside the\n    // path or not, we cast a ray from the origin to the given point and check the number\n    // of intersections of this segment with the path. If the number of intersections is\n    // even, then the ray both entered and exited the path an equal number of times,\n    // therefore the point is outside the path, and inside the path, if the number of\n    // intersections is odd. Since the path is compound, we check if the ray segment\n    // intersects with each of the path's segments, which can be either a line segment\n    // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\n    // points).\n    var ox = -10000;\n    var oy = -10000;\n    // the starting point of the  current path\n    var sx = NaN;\n    var sy = NaN;\n    // the previous point of the current path\n    var px = 0;\n    var py = 0;\n    var intersectionCount = 0;\n    for (var ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 'M':\n          if (!isNaN(sx)) {\n            if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n              intersectionCount++;\n            }\n          }\n          sx = px = params[pi++];\n          sy = py = params[pi++];\n          break;\n        case 'L':\n          if (segmentIntersection(px, py, px = params[pi++], py = params[pi++], ox, oy, x, y)) {\n            intersectionCount++;\n          }\n          break;\n        case 'C':\n          intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], px = params[pi++], py = params[pi++], ox, oy, x, y).length;\n          break;\n        case 'Z':\n          if (!isNaN(sx)) {\n            if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n              intersectionCount++;\n            }\n          }\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  };\n  Path2D.fromString = function (value) {\n    var path = new Path2D();\n    path.setFromString(value);\n    return path;\n  };\n  /**\n   * Split the SVG path at command letters,\n   * then extract the command letter and parameters from each substring.\n   * @param value\n   */\n  Path2D.parseSvgPath = function (value) {\n    return value.trim().split(Path2D.splitCommandsRe).map(function (part) {\n      var strParams = part.match(Path2D.matchParamsRe);\n      return {\n        command: part.substr(0, 1),\n        params: strParams ? strParams.map(parseFloat) : []\n      };\n    });\n  };\n  Path2D.prettifySvgPath = function (value) {\n    return Path2D.parseSvgPath(value).map(function (d) {\n      return d.command + d.params.join(',');\n    }).join('\\n');\n  };\n  /**\n   * See https://www.w3.org/TR/SVG11/paths.html\n   * @param value\n   */\n  Path2D.prototype.setFromString = function (value) {\n    var _this = this;\n    this.clear();\n    var parts = Path2D.parseSvgPath(value);\n    // Current point.\n    var x;\n    var y;\n    // Last control point. Used to calculate the reflection point\n    // for `S`, `s`, `T`, `t` commands.\n    var cpx;\n    var cpy;\n    var lastCommand;\n    function checkQuadraticCP() {\n      if (!lastCommand.match(Path2D.quadraticCommandRe)) {\n        cpx = x;\n        cpy = y;\n      }\n    }\n    function checkCubicCP() {\n      if (!lastCommand.match(Path2D.cubicCommandRe)) {\n        cpx = x;\n        cpy = y;\n      }\n    }\n    // But that will make compiler complain about x/y, cpx/cpy\n    // being used without being set first.\n    parts.forEach(function (part) {\n      var p = part.params;\n      var n = p.length;\n      var i = 0;\n      switch (part.command) {\n        case 'M':\n          _this.moveTo(x = p[i++], y = p[i++]);\n          while (i < n) {\n            _this.lineTo(x = p[i++], y = p[i++]);\n          }\n          break;\n        case 'm':\n          _this.moveTo(x += p[i++], y += p[i++]);\n          while (i < n) {\n            _this.lineTo(x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'L':\n          while (i < n) {\n            _this.lineTo(x = p[i++], y = p[i++]);\n          }\n          break;\n        case 'l':\n          while (i < n) {\n            _this.lineTo(x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'C':\n          while (i < n) {\n            _this.cubicCurveTo(p[i++], p[i++], cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n          }\n          break;\n        case 'c':\n          while (i < n) {\n            _this.cubicCurveTo(x + p[i++], y + p[i++], cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'S':\n          checkCubicCP();\n          while (i < n) {\n            _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n          }\n          break;\n        case 's':\n          checkCubicCP();\n          while (i < n) {\n            _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'Q':\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n          }\n          break;\n        case 'q':\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'T':\n          checkQuadraticCP();\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x = p[i++], y = p[i++]);\n          }\n          break;\n        case 't':\n          checkQuadraticCP();\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'A':\n          while (i < n) {\n            _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x = p[i++], y = p[i++]);\n          }\n          break;\n        case 'a':\n          while (i < n) {\n            _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x += p[i++], y += p[i++]);\n          }\n          break;\n        case 'Z':\n        case 'z':\n          _this.closePath();\n          break;\n        case 'H':\n          while (i < n) {\n            _this.lineTo(x = p[i++], y);\n          }\n          break;\n        case 'h':\n          while (i < n) {\n            _this.lineTo(x += p[i++], y);\n          }\n          break;\n        case 'V':\n          while (i < n) {\n            _this.lineTo(x, y = p[i++]);\n          }\n          break;\n        case 'v':\n          while (i < n) {\n            _this.lineTo(x, y += p[i++]);\n          }\n          break;\n      }\n      lastCommand = part.command;\n    });\n  };\n  Path2D.prototype.toString = function () {\n    var c = this.commands;\n    var p = this.params;\n    var cn = c.length;\n    var out = [];\n    for (var ci = 0, pi = 0; ci < cn; ci++) {\n      switch (c[ci]) {\n        case 'M':\n          out.push('M' + p[pi++] + ',' + p[pi++]);\n          break;\n        case 'L':\n          out.push('L' + p[pi++] + ',' + p[pi++]);\n          break;\n        case 'C':\n          out.push('C' + p[pi++] + ',' + p[pi++] + ' ' + p[pi++] + ',' + p[pi++] + ' ' + p[pi++] + ',' + p[pi++]);\n          break;\n        case 'Z':\n          out.push('Z');\n          break;\n      }\n    }\n    return out.join('');\n  };\n  Path2D.prototype.toPrettyString = function () {\n    return Path2D.prettifySvgPath(this.toString());\n  };\n  Path2D.prototype.toSvg = function () {\n    return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 50\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + this.toString() + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n  };\n  Path2D.prototype.toDebugSvg = function () {\n    var d = Path2D.prettifySvgPath(this.toString());\n    return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 100 100\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + d + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n  };\n  /**\n   * Returns an array of sub-paths of this Path,\n   * where each sub-path is represented exclusively by cubic segments.\n   */\n  Path2D.prototype.toCubicPaths = function () {\n    // Each sub-path is an array of `(n * 3 + 1) * 2` numbers,\n    // where `n` is the number of segments.\n    var paths = [];\n    var params = this.params;\n    // current path\n    var path;\n    // the starting point of the  current path\n    var sx;\n    var sy;\n    // the previous point of the current path\n    var px;\n    var py;\n    var i = 0; // current parameter\n    this.commands.forEach(function (command) {\n      switch (command) {\n        case 'M':\n          path = [sx = px = params[i++], sy = py = params[i++]];\n          paths.push(path);\n          break;\n        case 'L':\n          var x = params[i++];\n          var y = params[i++];\n          // Place control points along the line `a + (b - a) * t`\n          // at t = 1/3 and 2/3:\n          path.push((px + px + x) / 3, (py + py + y) / 3, (px + x + x) / 3, (py + y + y) / 3, px = x, py = y);\n          break;\n        case 'C':\n          path.push(params[i++], params[i++], params[i++], params[i++], px = params[i++], py = params[i++]);\n          break;\n        case 'Z':\n          path.push((px + px + sx) / 3, (py + py + sy) / 3, (px + sx + sx) / 3, (py + sy + sy) / 3, px = sx, py = sy);\n          break;\n      }\n    });\n    return paths;\n  };\n  Path2D.cubicPathToString = function (path) {\n    var n = path.length;\n    if (!(n % 2 === 0 && (n / 2 - 1) / 2 >= 1)) {\n      throw new Error('Invalid path.');\n    }\n    return 'M' + path.slice(0, 2).join(',') + 'C' + path.slice(2).join(',');\n  };\n  Path2D.splitCommandsRe = /(?=[AaCcHhLlMmQqSsTtVvZz])/g;\n  Path2D.matchParamsRe = /-?[0-9]*\\.?\\d+/g;\n  Path2D.quadraticCommandRe = /[QqTt]/;\n  Path2D.cubicCommandRe = /[CcSs]/;\n  Path2D.xmlDeclaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n  Path2D.xmlns = 'http://www.w3.org/2000/svg';\n  return Path2D;\n}();\nexport { Path2D };","map":{"version":3,"names":["cubicSegmentIntersections","segmentIntersection","Path2D","commands","params","_closedPath","prototype","moveTo","x","y","xy","push","lineTo","rect","width","height","closePath","arcTo","rx","ry","rotation","fA","fS","x2","y2","x1","y1","hdx","hdy","sinPhi","Math","sin","cosPhi","cos","xp","yp","ratX","ratY","lambda","cx","cy","cpx","cpy","sqrt","theta1","atan2","deltaTheta","cubicArc","arcToAlt","x1p","y1p","rx_y1p","ry_x1p","root","rootSign","cxp","cyp","acos","phi","theta2","anticlockwise","temp","start","length","f90","sinTheta1","cosTheta1","rightAngle","PI","xx","yx","yy","lastX","abs","f","tan","sinPhi2","cosPhi2","C2x","C2y","i","j","deCasteljau","points","t","n","Error","slice","newPoints","last","approximateCurve","step","xy_1","quadraticCurveTo","cubicCurveTo","cx1","cy1","cx2","cy2","Object","defineProperty","get","enumerable","configurable","undefined","clear","isPointInPath","cn","ox","oy","sx","NaN","sy","px","py","intersectionCount","ci","pi","isNaN","fromString","value","path","setFromString","parseSvgPath","trim","split","splitCommandsRe","map","part","strParams","match","matchParamsRe","command","substr","parseFloat","prettifySvgPath","d","join","_this","parts","lastCommand","checkQuadraticCP","quadraticCommandRe","checkCubicCP","cubicCommandRe","forEach","p","toString","c","out","toPrettyString","toSvg","xmlDeclaration","xmlns","toDebugSvg","toCubicPaths","paths","cubicPathToString"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/path2D.js"],"sourcesContent":["import { cubicSegmentIntersections, segmentIntersection } from \"./intersection\";\nvar Path2D = /** @class */ (function () {\n    function Path2D() {\n        // The methods of this class will likely be called many times per animation frame,\n        // and any allocation can trigger a GC cycle during animation, so we attempt\n        // to minimize the number of allocations.\n        this.commands = [];\n        this.params = [];\n        this._closedPath = false;\n    }\n    Path2D.prototype.moveTo = function (x, y) {\n        if (this.xy) {\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.xy = [x, y];\n        }\n        this.commands.push('M');\n        this.params.push(x, y);\n    };\n    Path2D.prototype.lineTo = function (x, y) {\n        if (this.xy) {\n            this.commands.push('L');\n            this.params.push(x, y);\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.moveTo(x, y);\n        }\n    };\n    Path2D.prototype.rect = function (x, y, width, height) {\n        this.moveTo(x, y);\n        this.lineTo(x + width, y);\n        this.lineTo(x + width, y + height);\n        this.lineTo(x, y + height);\n        this.closePath();\n    };\n    /**\n     * Adds an arc segment to the path definition.\n     * https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n     * @param rx The major-axis radius.\n     * @param ry The minor-axis radius.\n     * @param rotation The x-axis rotation, expressed in radians.\n     * @param fA The large arc flag. `1` to use angle > π.\n     * @param fS The sweep flag. `1` for the arc that goes to `x`/`y` clockwise.\n     * @param x2 The x coordinate to arc to.\n     * @param y2 The y coordinate to arc to.\n     */\n    Path2D.prototype.arcTo = function (rx, ry, rotation, fA, fS, x2, y2) {\n        // Convert from endpoint to center parametrization:\n        // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        var xy = this.xy;\n        if (!xy) {\n            return;\n        }\n        if (rx < 0) {\n            rx = -rx;\n        }\n        if (ry < 0) {\n            ry = -ry;\n        }\n        var x1 = xy[0];\n        var y1 = xy[1];\n        var hdx = (x1 - x2) / 2;\n        var hdy = (y1 - y2) / 2;\n        var sinPhi = Math.sin(rotation);\n        var cosPhi = Math.cos(rotation);\n        var xp = cosPhi * hdx + sinPhi * hdy;\n        var yp = -sinPhi * hdx + cosPhi * hdy;\n        var ratX = xp / rx;\n        var ratY = yp / ry;\n        var lambda = ratX * ratX + ratY * ratY;\n        var cx = (x1 + x2) / 2;\n        var cy = (y1 + y2) / 2;\n        var cpx = 0;\n        var cpy = 0;\n        if (lambda >= 1) {\n            lambda = Math.sqrt(lambda);\n            rx *= lambda;\n            ry *= lambda;\n            // me gives lambda == cpx == cpy == 0;\n        }\n        else {\n            lambda = Math.sqrt(1 / lambda - 1);\n            if (fA === fS) {\n                lambda = -lambda;\n            }\n            cpx = lambda * rx * ratY;\n            cpy = -lambda * ry * ratX;\n            cx += cosPhi * cpx - sinPhi * cpy;\n            cy += sinPhi * cpx + cosPhi * cpy;\n        }\n        var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx);\n        var deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;\n        // if (fS) {\n        //     if (deltaTheta <= 0) {\n        //         deltaTheta += Math.PI * 2;\n        //     }\n        // }\n        // else {\n        //     if (deltaTheta >= 0) {\n        //         deltaTheta -= Math.PI * 2;\n        //     }\n        // }\n        this.cubicArc(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);\n    };\n    Path2D.prototype.arcToAlt = function (rx, ry, rotation, fA, fS, x2, y2) {\n        // Convert from endpoint to center parametrization. See:\n        // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        if (!this.xy) {\n            return;\n        }\n        if (rx < 0) {\n            rx = -rx;\n        }\n        if (ry < 0) {\n            ry = -ry;\n        }\n        var x1 = this.xy[0];\n        var y1 = this.xy[1];\n        var hdx = (x1 - x2) / 2;\n        var hdy = (y1 - y2) / 2;\n        var sinPhi = Math.sin(rotation);\n        var cosPhi = Math.cos(rotation);\n        var x1p = cosPhi * hdx + sinPhi * hdy;\n        var y1p = -sinPhi * hdx + cosPhi * hdy;\n        var rx_y1p = rx * rx * y1p * y1p;\n        var ry_x1p = ry * ry * x1p * x1p;\n        var root = Math.sqrt((rx * rx * ry * ry - rx_y1p - ry_x1p) / (rx_y1p + ry_x1p));\n        var rootSign = fA === fS ? 0 : 1;\n        var cxp = rootSign * root * rx * y1p / ry;\n        var cyp = -rootSign * root * ry * x1p / rx;\n        var cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;\n        var cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;\n        var theta1 = Math.acos((x1p - cxp) / rx / ((x1p - cxp) / rx));\n    };\n    /**\n     * Approximates an elliptical arc with up to four cubic Bézier curves.\n     * @param commands The string array to write SVG command letters to.\n     * @param params The number array to write SVG command parameters (cubic control points) to.\n     * @param cx The x-axis coordinate for the ellipse's center.\n     * @param cy The y-axis coordinate for the ellipse's center.\n     * @param rx The ellipse's major-axis radius.\n     * @param ry The ellipse's minor-axis radius.\n     * @param phi The rotation for this ellipse, expressed in radians.\n     * @param theta1 The starting angle, measured clockwise from the positive x-axis and expressed in radians.\n     * @param theta2 The ending angle, measured clockwise from the positive x-axis and expressed in radians.\n     * @param anticlockwise The arc control points are always placed clockwise from `theta1` to `theta2`,\n     * even when `theta1 > theta2`, unless this flag is set to `1`.\n     */\n    Path2D.cubicArc = function (commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n        if (anticlockwise) {\n            var temp = theta1;\n            theta1 = theta2;\n            theta2 = temp;\n        }\n        var start = params.length;\n        // See https://pomax.github.io/bezierinfo/#circles_cubic\n        // Arc of unit circle (start angle = 0, end angle <= π/2) in cubic Bézier coordinates:\n        // S = [1, 0]\n        // C1 = [1, f]\n        // C2 = [cos(θ) + f * sin(θ), sin(θ) - f * cos(θ)]\n        // E = [cos(θ), sin(θ)]\n        // f = 4/3 * tan(θ/4)\n        var f90 = 0.5522847498307935; // f for θ = π/2 is 4/3 * (Math.sqrt(2) - 1)\n        var sinTheta1 = Math.sin(theta1);\n        var cosTheta1 = Math.cos(theta1);\n        var sinPhi = Math.sin(phi);\n        var cosPhi = Math.cos(phi);\n        var rightAngle = Math.PI / 2;\n        // Since we know how to draw an arc of a unit circle with a cubic Bézier,\n        // to draw an elliptical arc with arbitrary rotation and radii we:\n        // 1) rotate the Bézier coordinates that represent a circular arc by θ\n        // 2) scale the circular arc separately along the x/y axes, making it elliptical\n        // 3) rotate elliptical arc by φ\n        // |cos(φ) -sin(φ)| |sx  0| |cos(θ) -sin(θ)| -> |xx xy|\n        // |sin(φ)  cos(φ)| | 0 sy| |sin(θ)  cos(θ)| -> |yx yy|\n        var xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry;\n        var yx = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry;\n        var xy = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry;\n        var yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry;\n        // TODO: what if delta between θ1 and θ2 is greater than 2π?\n        // Always draw clockwise from θ1 to θ2.\n        theta2 -= theta1;\n        if (theta2 < 0) {\n            theta2 += Math.PI * 2;\n        }\n        // Multiplying each point [x, y] by:\n        // |xx xy cx| |x|\n        // |yx yy cy| |y|\n        // | 0  0  1| |1|\n        // TODO: This move command may be redundant, if we are already at this point.\n        // The coordinates of the point calculated here may differ ever so slightly\n        // because of precision error.\n        commands.push('M');\n        params.push(xx + cx, yx + cy);\n        while (theta2 >= rightAngle) {\n            theta2 -= rightAngle;\n            commands.push('C');\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var lastX = xy + cx;\n            params.push(xx + xy * f90 + cx, yx + yy * f90 + cy, xx * f90 + xy + cx, yx * f90 + yy + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yy + cy);\n            // Prepend π/2 rotation matrix.\n            // |xx xy| | 0 1| -> | xy -xx|\n            // |yx yy| |-1 0| -> | yy -yx|\n            // [xx, yx, xy, yy] = [xy, yy, -xx, -yx];\n            // Compared to swapping with a temp variable, destructuring is:\n            // - 10% faster in Chrome 70\n            // - 99% slower in Firefox 63\n            // Temp variable solution is 45% faster in FF than Chrome.\n            // https://jsperf.com/multi-swap\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1165569\n            var temp = xx;\n            xx = xy;\n            xy = -temp;\n            temp = yx;\n            yx = yy;\n            yy = -temp;\n        }\n        if (theta2) {\n            var f = 4 / 3 * Math.tan(theta2 / 4);\n            var sinPhi2 = Math.sin(theta2);\n            var cosPhi2 = Math.cos(theta2);\n            var C2x = cosPhi2 + f * sinPhi2;\n            var C2y = sinPhi2 - f * cosPhi2;\n            commands.push('C');\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var lastX = xx * cosPhi2 + xy * sinPhi2 + cx;\n            params.push(xx + xy * f + cx, yx + yy * f + cy, xx * C2x + xy * C2y + cx, yx * C2x + yy * C2y + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yx * cosPhi2 + yy * sinPhi2 + cy);\n        }\n        if (anticlockwise) {\n            for (var i = start, j = params.length - 2; i < j; i += 2, j -= 2) {\n                var temp = params[i];\n                params[i] = params[j];\n                params[j] = temp;\n                temp = params[i + 1];\n                params[i + 1] = params[j + 1];\n                params[j + 1] = temp;\n            }\n        }\n    };\n    Path2D.prototype.cubicArc = function (cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n        var commands = this.commands;\n        var params = this.params;\n        var start = commands.length;\n        Path2D.cubicArc(commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise);\n        var x = params[params.length - 2];\n        var y = params[params.length - 1];\n        if (this.xy) {\n            commands[start] = 'L';\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.xy = [x, y];\n        }\n    };\n    /**\n     * Returns the `[x, y]` coordinates of the curve at `t`.\n     * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n     * @param t\n     */\n    Path2D.prototype.deCasteljau = function (points, t) {\n        var n = points.length;\n        if (n < 2 || n % 2 === 1) {\n            throw new Error('Fewer than two points or not an even count.');\n        }\n        else if (n === 2 || t === 0) {\n            return points.slice(0, 2);\n        }\n        else if (t === 1) {\n            return points.slice(-2);\n        }\n        else {\n            var newPoints = [];\n            var last = n - 2;\n            for (var i = 0; i < last; i += 2) {\n                newPoints.push((1 - t) * points[i] + t * points[i + 2], // x\n                (1 - t) * points[i + 1] + t * points[i + 3] // y\n                );\n            }\n            return this.deCasteljau(newPoints, t);\n        }\n    };\n    /**\n     * Approximates the given curve using `n` line segments.\n     * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n     * @param n\n     */\n    Path2D.prototype.approximateCurve = function (points, n) {\n        var xy = this.deCasteljau(points, 0);\n        this.moveTo(xy[0], xy[1]);\n        var step = 1 / n;\n        for (var t = step; t <= 1; t += step) {\n            var xy_1 = this.deCasteljau(points, t);\n            this.lineTo(xy_1[0], xy_1[1]);\n        }\n    };\n    /**\n     * Adds a quadratic curve segment to the path definition.\n     * Note: the given quadratic segment is converted and stored as a cubic one.\n     * @param cx x-component of the curve's control point\n     * @param cy y-component of the curve's control point\n     * @param x x-component of the end point\n     * @param y y-component of the end point\n     */\n    Path2D.prototype.quadraticCurveTo = function (cx, cy, x, y) {\n        if (!this.xy) {\n            this.moveTo(cx, cy);\n        }\n        // See https://pomax.github.io/bezierinfo/#reordering\n        this.cubicCurveTo((this.xy[0] + 2 * cx) / 3, (this.xy[1] + 2 * cy) / 3, // 1/3 start + 2/3 control\n        (2 * cx + x) / 3, (2 * cy + y) / 3, // 2/3 control + 1/3 end\n        x, y);\n    };\n    Path2D.prototype.cubicCurveTo = function (cx1, cy1, cx2, cy2, x, y) {\n        if (!this.xy) {\n            this.moveTo(cx1, cy1);\n        }\n        this.commands.push('C');\n        this.params.push(cx1, cy1, cx2, cy2, x, y);\n        this.xy[0] = x;\n        this.xy[1] = y;\n    };\n    Object.defineProperty(Path2D.prototype, \"closedPath\", {\n        get: function () {\n            return this._closedPath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path2D.prototype.closePath = function () {\n        if (this.xy) {\n            this.xy = undefined;\n            this.commands.push('Z');\n            this._closedPath = true;\n        }\n    };\n    Path2D.prototype.clear = function () {\n        this.commands.length = 0;\n        this.params.length = 0;\n        this.xy = undefined;\n        this._closedPath = false;\n    };\n    Path2D.prototype.isPointInPath = function (x, y) {\n        var commands = this.commands;\n        var params = this.params;\n        var cn = commands.length;\n        // Hit testing using ray casting method, where the ray's origin is some point\n        // outside the path. In this case, an offscreen point that is remote enough, so that\n        // even if the path itself is large and is partially offscreen, the ray's origin\n        // will likely be outside the path anyway. To test if the given point is inside the\n        // path or not, we cast a ray from the origin to the given point and check the number\n        // of intersections of this segment with the path. If the number of intersections is\n        // even, then the ray both entered and exited the path an equal number of times,\n        // therefore the point is outside the path, and inside the path, if the number of\n        // intersections is odd. Since the path is compound, we check if the ray segment\n        // intersects with each of the path's segments, which can be either a line segment\n        // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\n        // points).\n        var ox = -10000;\n        var oy = -10000;\n        // the starting point of the  current path\n        var sx = NaN;\n        var sy = NaN;\n        // the previous point of the current path\n        var px = 0;\n        var py = 0;\n        var intersectionCount = 0;\n        for (var ci = 0, pi = 0; ci < cn; ci++) {\n            switch (commands[ci]) {\n                case 'M':\n                    if (!isNaN(sx)) {\n                        if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n                            intersectionCount++;\n                        }\n                    }\n                    sx = px = params[pi++];\n                    sy = py = params[pi++];\n                    break;\n                case 'L':\n                    if (segmentIntersection(px, py, px = params[pi++], py = params[pi++], ox, oy, x, y)) {\n                        intersectionCount++;\n                    }\n                    break;\n                case 'C':\n                    intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], px = params[pi++], py = params[pi++], ox, oy, x, y).length;\n                    break;\n                case 'Z':\n                    if (!isNaN(sx)) {\n                        if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n                            intersectionCount++;\n                        }\n                    }\n                    break;\n            }\n        }\n        return intersectionCount % 2 === 1;\n    };\n    Path2D.fromString = function (value) {\n        var path = new Path2D();\n        path.setFromString(value);\n        return path;\n    };\n    /**\n     * Split the SVG path at command letters,\n     * then extract the command letter and parameters from each substring.\n     * @param value\n     */\n    Path2D.parseSvgPath = function (value) {\n        return value.trim().split(Path2D.splitCommandsRe).map(function (part) {\n            var strParams = part.match(Path2D.matchParamsRe);\n            return {\n                command: part.substr(0, 1),\n                params: strParams ? strParams.map(parseFloat) : []\n            };\n        });\n    };\n    Path2D.prettifySvgPath = function (value) {\n        return Path2D.parseSvgPath(value).map(function (d) { return d.command + d.params.join(','); }).join('\\n');\n    };\n    /**\n     * See https://www.w3.org/TR/SVG11/paths.html\n     * @param value\n     */\n    Path2D.prototype.setFromString = function (value) {\n        var _this = this;\n        this.clear();\n        var parts = Path2D.parseSvgPath(value);\n        // Current point.\n        var x;\n        var y;\n        // Last control point. Used to calculate the reflection point\n        // for `S`, `s`, `T`, `t` commands.\n        var cpx;\n        var cpy;\n        var lastCommand;\n        function checkQuadraticCP() {\n            if (!lastCommand.match(Path2D.quadraticCommandRe)) {\n                cpx = x;\n                cpy = y;\n            }\n        }\n        function checkCubicCP() {\n            if (!lastCommand.match(Path2D.cubicCommandRe)) {\n                cpx = x;\n                cpy = y;\n            }\n        }\n        // But that will make compiler complain about x/y, cpx/cpy\n        // being used without being set first.\n        parts.forEach(function (part) {\n            var p = part.params;\n            var n = p.length;\n            var i = 0;\n            switch (part.command) {\n                case 'M':\n                    _this.moveTo(x = p[i++], y = p[i++]);\n                    while (i < n) {\n                        _this.lineTo(x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'm':\n                    _this.moveTo(x += p[i++], y += p[i++]);\n                    while (i < n) {\n                        _this.lineTo(x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'L':\n                    while (i < n) {\n                        _this.lineTo(x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'l':\n                    while (i < n) {\n                        _this.lineTo(x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'C':\n                    while (i < n) {\n                        _this.cubicCurveTo(p[i++], p[i++], cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'c':\n                    while (i < n) {\n                        _this.cubicCurveTo(x + p[i++], y + p[i++], cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'S':\n                    checkCubicCP();\n                    while (i < n) {\n                        _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 's':\n                    checkCubicCP();\n                    while (i < n) {\n                        _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'Q':\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'q':\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'T':\n                    checkQuadraticCP();\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 't':\n                    checkQuadraticCP();\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'A':\n                    while (i < n) {\n                        _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'a':\n                    while (i < n) {\n                        _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'Z':\n                case 'z':\n                    _this.closePath();\n                    break;\n                case 'H':\n                    while (i < n) {\n                        _this.lineTo(x = p[i++], y);\n                    }\n                    break;\n                case 'h':\n                    while (i < n) {\n                        _this.lineTo(x += p[i++], y);\n                    }\n                    break;\n                case 'V':\n                    while (i < n) {\n                        _this.lineTo(x, y = p[i++]);\n                    }\n                    break;\n                case 'v':\n                    while (i < n) {\n                        _this.lineTo(x, y += p[i++]);\n                    }\n                    break;\n            }\n            lastCommand = part.command;\n        });\n    };\n    Path2D.prototype.toString = function () {\n        var c = this.commands;\n        var p = this.params;\n        var cn = c.length;\n        var out = [];\n        for (var ci = 0, pi = 0; ci < cn; ci++) {\n            switch (c[ci]) {\n                case 'M':\n                    out.push('M' + p[pi++] + ',' + p[pi++]);\n                    break;\n                case 'L':\n                    out.push('L' + p[pi++] + ',' + p[pi++]);\n                    break;\n                case 'C':\n                    out.push('C' + p[pi++] + ',' + p[pi++] + ' ' +\n                        p[pi++] + ',' + p[pi++] + ' ' +\n                        p[pi++] + ',' + p[pi++]);\n                    break;\n                case 'Z':\n                    out.push('Z');\n                    break;\n            }\n        }\n        return out.join('');\n    };\n    Path2D.prototype.toPrettyString = function () {\n        return Path2D.prettifySvgPath(this.toString());\n    };\n    Path2D.prototype.toSvg = function () {\n        return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 50\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + this.toString() + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n    };\n    Path2D.prototype.toDebugSvg = function () {\n        var d = Path2D.prettifySvgPath(this.toString());\n        return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 100 100\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + d + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n    };\n    /**\n     * Returns an array of sub-paths of this Path,\n     * where each sub-path is represented exclusively by cubic segments.\n     */\n    Path2D.prototype.toCubicPaths = function () {\n        // Each sub-path is an array of `(n * 3 + 1) * 2` numbers,\n        // where `n` is the number of segments.\n        var paths = [];\n        var params = this.params;\n        // current path\n        var path;\n        // the starting point of the  current path\n        var sx;\n        var sy;\n        // the previous point of the current path\n        var px;\n        var py;\n        var i = 0; // current parameter\n        this.commands.forEach(function (command) {\n            switch (command) {\n                case 'M':\n                    path = [\n                        sx = px = params[i++],\n                        sy = py = params[i++]\n                    ];\n                    paths.push(path);\n                    break;\n                case 'L':\n                    var x = params[i++];\n                    var y = params[i++];\n                    // Place control points along the line `a + (b - a) * t`\n                    // at t = 1/3 and 2/3:\n                    path.push((px + px + x) / 3, (py + py + y) / 3, (px + x + x) / 3, (py + y + y) / 3, px = x, py = y);\n                    break;\n                case 'C':\n                    path.push(params[i++], params[i++], params[i++], params[i++], px = params[i++], py = params[i++]);\n                    break;\n                case 'Z':\n                    path.push((px + px + sx) / 3, (py + py + sy) / 3, (px + sx + sx) / 3, (py + sy + sy) / 3, px = sx, py = sy);\n                    break;\n            }\n        });\n        return paths;\n    };\n    Path2D.cubicPathToString = function (path) {\n        var n = path.length;\n        if (!(n % 2 === 0 && (n / 2 - 1) / 2 >= 1)) {\n            throw new Error('Invalid path.');\n        }\n        return 'M' + path.slice(0, 2).join(',') + 'C' + path.slice(2).join(',');\n    };\n    Path2D.splitCommandsRe = /(?=[AaCcHhLlMmQqSsTtVvZz])/g;\n    Path2D.matchParamsRe = /-?[0-9]*\\.?\\d+/g;\n    Path2D.quadraticCommandRe = /[QqTt]/;\n    Path2D.cubicCommandRe = /[CcSs]/;\n    Path2D.xmlDeclaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n    Path2D.xmlns = 'http://www.w3.org/2000/svg';\n    return Path2D;\n}());\nexport { Path2D };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}