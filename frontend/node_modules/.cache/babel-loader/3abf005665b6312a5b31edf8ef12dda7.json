{"ast":null,"code":"import { BBox } from \"./bbox\";\n/**\n * As of Jan 8, 2019, Firefox still doesn't implement\n * `getTransform(): DOMMatrix;`\n * `setTransform(transform?: DOMMatrix2DInit)`\n * in the `CanvasRenderingContext2D`.\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\n * IE11 and Edge 44 also don't have the support.\n * Thus this class, to keep track of the current transform and\n * combine transformations.\n * Standards:\n * https://html.spec.whatwg.org/dev/canvas.html\n * https://www.w3.org/TR/geometry-1/\n */\n\nvar Matrix =\n/** @class */\nfunction () {\n  function Matrix(elements) {\n    if (elements === void 0) {\n      elements = [1, 0, 0, 1, 0, 0];\n    }\n\n    this.elements = elements;\n  }\n\n  Matrix.prototype.setElements = function (elements) {\n    var e = this.elements; // `this.elements = elements.slice()` is 4-5 times slower\n    // (in Chrome 71 and FF 64) than manually copying elements,\n    // since slicing allocates new memory.\n    // The performance of passing parameters individually\n    // vs as an array is about the same in both browsers, so we\n    // go with a single (array of elements) parameter, because\n    // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n    // calls give us roughly the same performance, versus\n    // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n    // where the spread operator causes a 20-30x performance drop\n    // (30x when compiled to ES5's `.apply(this, elements)`\n    //  20x when used natively).\n\n    e[0] = elements[0];\n    e[1] = elements[1];\n    e[2] = elements[2];\n    e[3] = elements[3];\n    e[4] = elements[4];\n    e[5] = elements[5];\n    return this;\n  };\n\n  Matrix.prototype.setIdentityElements = function () {\n    var e = this.elements;\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 1;\n    e[4] = 0;\n    e[5] = 0;\n    return this;\n  };\n\n  Object.defineProperty(Matrix.prototype, \"identity\", {\n    get: function () {\n      var e = this.elements;\n      return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"a\", {\n    get: function () {\n      return this.elements[0];\n    },\n    set: function (value) {\n      this.elements[0] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"b\", {\n    get: function () {\n      return this.elements[1];\n    },\n    set: function (value) {\n      this.elements[1] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"c\", {\n    get: function () {\n      return this.elements[2];\n    },\n    set: function (value) {\n      this.elements[2] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"d\", {\n    get: function () {\n      return this.elements[3];\n    },\n    set: function (value) {\n      this.elements[3] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"e\", {\n    get: function () {\n      return this.elements[4];\n    },\n    set: function (value) {\n      this.elements[4] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"f\", {\n    get: function () {\n      return this.elements[5];\n    },\n    set: function (value) {\n      this.elements[5] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n\n  Matrix.prototype.AxB = function (A, B, C) {\n    var m11 = A[0],\n        m12 = A[1],\n        m21 = A[2],\n        m22 = A[3],\n        m31 = A[4],\n        m32 = A[5];\n    var o11 = B[0],\n        o12 = B[1],\n        o21 = B[2],\n        o22 = B[3],\n        o31 = B[4],\n        o32 = B[5];\n    C = C || A;\n    C[0] = m11 * o11 + m21 * o12;\n    C[1] = m12 * o11 + m22 * o12;\n    C[2] = m11 * o21 + m21 * o22;\n    C[3] = m12 * o21 + m22 * o22;\n    C[4] = m11 * o31 + m21 * o32 + m31;\n    C[5] = m12 * o31 + m22 * o32 + m32;\n  };\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n\n\n  Matrix.prototype.multiplySelf = function (other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  };\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n\n\n  Matrix.prototype.multiply = function (other) {\n    var elements = new Array(6);\n    this.AxB(this.elements, other.elements, elements);\n    return new Matrix(elements);\n  };\n\n  Matrix.prototype.preMultiplySelf = function (other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  };\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n\n\n  Matrix.prototype.inverse = function () {\n    var _a = this.elements,\n        a = _a[0],\n        b = _a[1],\n        c = _a[2],\n        d = _a[3],\n        e = _a[4],\n        f = _a[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  };\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n\n\n  Matrix.prototype.inverseTo = function (other) {\n    var _a = this.elements,\n        a = _a[0],\n        b = _a[1],\n        c = _a[2],\n        d = _a[3],\n        e = _a[4],\n        f = _a[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  };\n\n  Matrix.prototype.invertSelf = function () {\n    var elements = this.elements;\n    var a = elements[0],\n        b = elements[1],\n        c = elements[2],\n        d = elements[3],\n        e = elements[4],\n        f = elements[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    elements[0] = d;\n    elements[1] = -b;\n    elements[2] = -c;\n    elements[3] = a;\n    elements[4] = c * f - d * e;\n    elements[5] = b * e - a * f;\n    return this;\n  };\n\n  Matrix.prototype.clone = function () {\n    return new Matrix(this.elements.slice());\n  };\n\n  Matrix.prototype.transformPoint = function (x, y) {\n    var e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  };\n\n  Matrix.prototype.transformBBox = function (bbox, radius, target) {\n    if (radius === void 0) {\n      radius = 0;\n    }\n\n    var elements = this.elements;\n    var xx = elements[0];\n    var xy = elements[1];\n    var yx = elements[2];\n    var yy = elements[3];\n    var h_w = bbox.width * 0.5;\n    var h_h = bbox.height * 0.5;\n    var cx = bbox.x + h_w;\n    var cy = bbox.y + h_h;\n    var w, h;\n\n    if (radius) {\n      h_w -= radius;\n      h_h -= radius;\n      var sx = Math.sqrt(xx * xx + yx * yx);\n      var sy = Math.sqrt(xy * xy + yy * yy);\n      w = Math.abs(h_w * xx) + Math.abs(h_h * yx) + Math.abs(sx * radius);\n      h = Math.abs(h_w * xy) + Math.abs(h_h * yy) + Math.abs(sy * radius);\n    } else {\n      w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n      h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    }\n\n    if (!target) {\n      target = new BBox(0, 0, 0, 0);\n    }\n\n    target.x = cx * xx + cy * yx + elements[4] - w;\n    target.y = cx * xy + cy * yy + elements[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  };\n\n  Matrix.prototype.toContext = function (ctx) {\n    // It's fair to say that matrix multiplications are not cheap.\n    // However, updating path definitions on every frame isn't either, so\n    // it may be cheaper to just translate paths. It's also fair to\n    // say, that most paths will have to be re-rendered anyway, say\n    // rectangle paths in a bar chart, where an animation would happen when\n    // the data set changes and existing bars are morphed into new ones.\n    // Or a pie chart, where old sectors are also morphed into new ones.\n    // Same for the line chart. The only plausible case where translating\n    // existing paths would be enough, is the scatter chart, where marker\n    // icons, typically circles, stay the same size. But if circle radii\n    // are bound to some data points, even circle paths would have to be\n    // updated. And thus it makes sense to optimize for fewer matrix\n    // transforms, where transform matrices of paths are mostly identity\n    // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n    // are used to define a path at specific coordinates. And only groups\n    // are used to collectively apply a transform to a set of nodes.\n    // If the matrix is mostly identity (95% of the time),\n    // the `if (this.isIdentity)` check can make this call 3-4 times\n    // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n    if (this.identity) {\n      return;\n    }\n\n    var e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  };\n\n  Matrix.flyweight = function (elements) {\n    if (elements) {\n      if (elements instanceof Matrix) {\n        Matrix.matrix.setElements(elements.elements);\n      } else {\n        Matrix.matrix.setElements(elements);\n      }\n    } else {\n      Matrix.matrix.setIdentityElements();\n    }\n\n    return Matrix.matrix;\n  };\n\n  Matrix.matrix = new Matrix();\n  return Matrix;\n}();\n\nexport { Matrix };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/matrix.js"],"names":["BBox","Matrix","elements","prototype","setElements","e","setIdentityElements","Object","defineProperty","get","enumerable","configurable","set","value","AxB","A","B","C","m11","m12","m21","m22","m31","m32","o11","o12","o21","o22","o31","o32","multiplySelf","other","multiply","Array","preMultiplySelf","inverse","_a","a","b","c","d","f","rD","inverseTo","invertSelf","clone","slice","transformPoint","x","y","transformBBox","bbox","radius","target","xx","xy","yx","yy","h_w","width","h_h","height","cx","cy","w","h","sx","Math","sqrt","sy","abs","toContext","ctx","identity","transform","flyweight","matrix"],"mappings":"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","sourcesContent":["import { BBox } from \"./bbox\";\n/**\n * As of Jan 8, 2019, Firefox still doesn't implement\n * `getTransform(): DOMMatrix;`\n * `setTransform(transform?: DOMMatrix2DInit)`\n * in the `CanvasRenderingContext2D`.\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\n * IE11 and Edge 44 also don't have the support.\n * Thus this class, to keep track of the current transform and\n * combine transformations.\n * Standards:\n * https://html.spec.whatwg.org/dev/canvas.html\n * https://www.w3.org/TR/geometry-1/\n */\nvar Matrix = /** @class */ (function () {\n    function Matrix(elements) {\n        if (elements === void 0) { elements = [1, 0, 0, 1, 0, 0]; }\n        this.elements = elements;\n    }\n    Matrix.prototype.setElements = function (elements) {\n        var e = this.elements;\n        // `this.elements = elements.slice()` is 4-5 times slower\n        // (in Chrome 71 and FF 64) than manually copying elements,\n        // since slicing allocates new memory.\n        // The performance of passing parameters individually\n        // vs as an array is about the same in both browsers, so we\n        // go with a single (array of elements) parameter, because\n        // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n        // calls give us roughly the same performance, versus\n        // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n        // where the spread operator causes a 20-30x performance drop\n        // (30x when compiled to ES5's `.apply(this, elements)`\n        //  20x when used natively).\n        e[0] = elements[0];\n        e[1] = elements[1];\n        e[2] = elements[2];\n        e[3] = elements[3];\n        e[4] = elements[4];\n        e[5] = elements[5];\n        return this;\n    };\n    Matrix.prototype.setIdentityElements = function () {\n        var e = this.elements;\n        e[0] = 1;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 1;\n        e[4] = 0;\n        e[5] = 0;\n        return this;\n    };\n    Object.defineProperty(Matrix.prototype, \"identity\", {\n        get: function () {\n            var e = this.elements;\n            return e[0] === 1 && e[1] === 0 && e[2] === 0 &&\n                e[3] === 1 && e[4] === 0 && e[5] === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"a\", {\n        get: function () {\n            return this.elements[0];\n        },\n        set: function (value) {\n            this.elements[0] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"b\", {\n        get: function () {\n            return this.elements[1];\n        },\n        set: function (value) {\n            this.elements[1] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"c\", {\n        get: function () {\n            return this.elements[2];\n        },\n        set: function (value) {\n            this.elements[2] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"d\", {\n        get: function () {\n            return this.elements[3];\n        },\n        set: function (value) {\n            this.elements[3] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"e\", {\n        get: function () {\n            return this.elements[4];\n        },\n        set: function (value) {\n            this.elements[4] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"f\", {\n        get: function () {\n            return this.elements[5];\n        },\n        set: function (value) {\n            this.elements[5] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Performs the AxB matrix multiplication and saves the result\n     * to `C`, if given, or to `A` otherwise.\n     */\n    Matrix.prototype.AxB = function (A, B, C) {\n        var m11 = A[0], m12 = A[1], m21 = A[2], m22 = A[3], m31 = A[4], m32 = A[5];\n        var o11 = B[0], o12 = B[1], o21 = B[2], o22 = B[3], o31 = B[4], o32 = B[5];\n        C = C || A;\n        C[0] = m11 * o11 + m21 * o12;\n        C[1] = m12 * o11 + m22 * o12;\n        C[2] = m11 * o21 + m21 * o22;\n        C[3] = m12 * o21 + m22 * o22;\n        C[4] = m11 * o31 + m21 * o32 + m31;\n        C[5] = m12 * o31 + m22 * o32 + m32;\n    };\n    /**\n     * The `other` matrix gets post-multiplied to the current matrix.\n     * Returns the current matrix.\n     * @param other\n     */\n    Matrix.prototype.multiplySelf = function (other) {\n        this.AxB(this.elements, other.elements);\n        return this;\n    };\n    /**\n     * The `other` matrix gets post-multiplied to the current matrix.\n     * Returns a new matrix.\n     * @param other\n     */\n    Matrix.prototype.multiply = function (other) {\n        var elements = new Array(6);\n        this.AxB(this.elements, other.elements, elements);\n        return new Matrix(elements);\n    };\n    Matrix.prototype.preMultiplySelf = function (other) {\n        this.AxB(other.elements, this.elements, this.elements);\n        return this;\n    };\n    /**\n     * Returns the inverse of this matrix as a new matrix.\n     */\n    Matrix.prototype.inverse = function () {\n        var _a = this.elements, a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4], f = _a[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    };\n    /**\n     * Save the inverse of this matrix to the given matrix.\n     */\n    Matrix.prototype.inverseTo = function (other) {\n        var _a = this.elements, a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4], f = _a[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n        return this;\n    };\n    Matrix.prototype.invertSelf = function () {\n        var elements = this.elements;\n        var a = elements[0], b = elements[1], c = elements[2], d = elements[3], e = elements[4], f = elements[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        elements[0] = d;\n        elements[1] = -b;\n        elements[2] = -c;\n        elements[3] = a;\n        elements[4] = c * f - d * e;\n        elements[5] = b * e - a * f;\n        return this;\n    };\n    Matrix.prototype.clone = function () {\n        return new Matrix(this.elements.slice());\n    };\n    Matrix.prototype.transformPoint = function (x, y) {\n        var e = this.elements;\n        return {\n            x: x * e[0] + y * e[2] + e[4],\n            y: x * e[1] + y * e[3] + e[5]\n        };\n    };\n    Matrix.prototype.transformBBox = function (bbox, radius, target) {\n        if (radius === void 0) { radius = 0; }\n        var elements = this.elements;\n        var xx = elements[0];\n        var xy = elements[1];\n        var yx = elements[2];\n        var yy = elements[3];\n        var h_w = bbox.width * 0.5;\n        var h_h = bbox.height * 0.5;\n        var cx = bbox.x + h_w;\n        var cy = bbox.y + h_h;\n        var w, h;\n        if (radius) {\n            h_w -= radius;\n            h_h -= radius;\n            var sx = Math.sqrt(xx * xx + yx * yx);\n            var sy = Math.sqrt(xy * xy + yy * yy);\n            w = Math.abs(h_w * xx) + Math.abs(h_h * yx) + Math.abs(sx * radius);\n            h = Math.abs(h_w * xy) + Math.abs(h_h * yy) + Math.abs(sy * radius);\n        }\n        else {\n            w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n            h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n        }\n        if (!target) {\n            target = new BBox(0, 0, 0, 0);\n        }\n        target.x = cx * xx + cy * yx + elements[4] - w;\n        target.y = cx * xy + cy * yy + elements[5] - h;\n        target.width = w + w;\n        target.height = h + h;\n        return target;\n    };\n    Matrix.prototype.toContext = function (ctx) {\n        // It's fair to say that matrix multiplications are not cheap.\n        // However, updating path definitions on every frame isn't either, so\n        // it may be cheaper to just translate paths. It's also fair to\n        // say, that most paths will have to be re-rendered anyway, say\n        // rectangle paths in a bar chart, where an animation would happen when\n        // the data set changes and existing bars are morphed into new ones.\n        // Or a pie chart, where old sectors are also morphed into new ones.\n        // Same for the line chart. The only plausible case where translating\n        // existing paths would be enough, is the scatter chart, where marker\n        // icons, typically circles, stay the same size. But if circle radii\n        // are bound to some data points, even circle paths would have to be\n        // updated. And thus it makes sense to optimize for fewer matrix\n        // transforms, where transform matrices of paths are mostly identity\n        // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n        // are used to define a path at specific coordinates. And only groups\n        // are used to collectively apply a transform to a set of nodes.\n        // If the matrix is mostly identity (95% of the time),\n        // the `if (this.isIdentity)` check can make this call 3-4 times\n        // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n        if (this.identity) {\n            return;\n        }\n        var e = this.elements;\n        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n    };\n    Matrix.flyweight = function (elements) {\n        if (elements) {\n            if (elements instanceof Matrix) {\n                Matrix.matrix.setElements(elements.elements);\n            }\n            else {\n                Matrix.matrix.setElements(elements);\n            }\n        }\n        else {\n            Matrix.matrix.setIdentityElements();\n        }\n        return Matrix.matrix;\n    };\n    Matrix.matrix = new Matrix();\n    return Matrix;\n}());\nexport { Matrix };\n"]},"metadata":{},"sourceType":"module"}