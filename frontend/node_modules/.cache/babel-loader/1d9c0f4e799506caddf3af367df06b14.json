{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar Observable =\n/** @class */\nfunction () {\n  function Observable() {\n    // Note that these maps can't be specified generically, so they are kept untyped.\n    // Some methods in this class only need generics in their signatures, the generics inside the methods\n    // are just for clarity. The generics in signatures allow for static type checking of user provided\n    // listeners and for type inference, so that the users wouldn't have to specify the type of parameters\n    // of their inline lambdas.\n    this.allPropertyListeners = new Map(); // property name => property change listener => scopes\n\n    this.allEventListeners = new Map(); // event type => event listener => scopes\n  }\n\n  Observable.prototype.addPropertyListener = function (name, listener, scope) {\n    if (scope === void 0) {\n      scope = this;\n    }\n\n    var allPropertyListeners = this.allPropertyListeners;\n    var propertyListeners = allPropertyListeners.get(name);\n\n    if (!propertyListeners) {\n      propertyListeners = new Map();\n      allPropertyListeners.set(name, propertyListeners);\n    }\n\n    if (!propertyListeners.has(listener)) {\n      var scopes_1 = new Set();\n      propertyListeners.set(listener, scopes_1);\n    }\n\n    var scopes = propertyListeners.get(listener);\n\n    if (scopes) {\n      scopes.add(scope);\n    }\n  };\n\n  Observable.prototype.removePropertyListener = function (name, listener, scope) {\n    if (scope === void 0) {\n      scope = this;\n    }\n\n    var allPropertyListeners = this.allPropertyListeners;\n    var propertyListeners = allPropertyListeners.get(name);\n\n    if (propertyListeners) {\n      if (listener) {\n        var scopes = propertyListeners.get(listener);\n\n        if (scopes) {\n          scopes.delete(scope);\n\n          if (!scopes.size) {\n            propertyListeners.delete(listener);\n          }\n        }\n      } else {\n        propertyListeners.clear();\n      }\n    }\n  };\n\n  Observable.prototype.notifyPropertyListeners = function (name, oldValue, value) {\n    var _this = this;\n\n    var allPropertyListeners = this.allPropertyListeners;\n    var propertyListeners = allPropertyListeners.get(name);\n\n    if (propertyListeners) {\n      propertyListeners.forEach(function (scopes, listener) {\n        scopes.forEach(function (scope) {\n          return listener.call(scope, {\n            type: name,\n            source: _this,\n            value: value,\n            oldValue: oldValue\n          });\n        });\n      });\n    }\n  };\n\n  Observable.prototype.addEventListener = function (type, listener, scope) {\n    if (scope === void 0) {\n      scope = this;\n    }\n\n    var allEventListeners = this.allEventListeners;\n    var eventListeners = allEventListeners.get(type);\n\n    if (!eventListeners) {\n      eventListeners = new Map();\n      allEventListeners.set(type, eventListeners);\n    }\n\n    if (!eventListeners.has(listener)) {\n      var scopes_2 = new Set();\n      eventListeners.set(listener, scopes_2);\n    }\n\n    var scopes = eventListeners.get(listener);\n\n    if (scopes) {\n      scopes.add(scope);\n    }\n  };\n\n  Observable.prototype.removeEventListener = function (type, listener, scope) {\n    if (scope === void 0) {\n      scope = this;\n    }\n\n    var allEventListeners = this.allEventListeners;\n    var eventListeners = allEventListeners.get(type);\n\n    if (eventListeners) {\n      if (listener) {\n        var scopes = eventListeners.get(listener);\n\n        if (scopes) {\n          scopes.delete(scope);\n\n          if (!scopes.size) {\n            eventListeners.delete(listener);\n          }\n        }\n      } else {\n        eventListeners.clear();\n      }\n    }\n  };\n\n  Observable.prototype.notifyEventListeners = function (types) {\n    var _this = this;\n\n    var allEventListeners = this.allEventListeners;\n    types.forEach(function (type) {\n      var listeners = allEventListeners.get(type);\n\n      if (listeners) {\n        listeners.forEach(function (scopes, listener) {\n          scopes.forEach(function (scope) {\n            return listener.call(scope, {\n              type: type,\n              source: _this\n            });\n          });\n        });\n      }\n    });\n  };\n\n  Observable.prototype.fireEvent = function (event) {\n    var _this = this;\n\n    var listeners = this.allEventListeners.get(event.type);\n\n    if (listeners) {\n      listeners.forEach(function (scopes, listener) {\n        scopes.forEach(function (scope) {\n          return listener.call(scope, __assign(__assign({}, event), {\n            source: _this\n          }));\n        });\n      });\n    }\n  };\n\n  Observable.privateKeyPrefix = '_';\n  return Observable;\n}();\n\nexport { Observable };\nexport function reactive() {\n  var events = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    events[_i] = arguments[_i];\n  } // let debug = events.indexOf('debugger') >= 0;\n\n\n  return function (target, key) {\n    // `target` is either a constructor (static member) or prototype (instance member)\n    var privateKey = Observable.privateKeyPrefix + key;\n    var privateKeyEvents = privateKey + 'Events';\n\n    if (!target[key]) {\n      if (events) {\n        target[privateKeyEvents] = events;\n      }\n\n      Object.defineProperty(target, key, {\n        set: function (value) {\n          var oldValue = this[privateKey]; // This is a way to stop inside the setter by adding the special\n          // 'debugger' event to a reactive property, for example:\n          //  @reactive('layoutChange', 'debugger') title?: Caption;\n          // if (debug) { // DO NOT REMOVE\n          //     debugger;\n          // }\n\n          if (value !== oldValue || typeof value === 'object' && value !== null) {\n            this[privateKey] = value;\n            this.notifyPropertyListeners(key, oldValue, value);\n            var events_1 = this[privateKeyEvents];\n\n            if (events_1) {\n              this.notifyEventListeners(events_1);\n            }\n          }\n        },\n        get: function () {\n          return this[privateKey];\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  };\n}","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/util/observable.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","Observable","allPropertyListeners","Map","allEventListeners","addPropertyListener","name","listener","scope","propertyListeners","get","set","has","scopes_1","Set","scopes","add","removePropertyListener","delete","size","clear","notifyPropertyListeners","oldValue","value","_this","forEach","type","source","addEventListener","eventListeners","scopes_2","removeEventListener","notifyEventListeners","types","listeners","fireEvent","event","privateKeyPrefix","reactive","events","_i","target","key","privateKey","privateKeyEvents","defineProperty","events_1","enumerable","configurable"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar Observable = /** @class */ (function () {\n    function Observable() {\n        // Note that these maps can't be specified generically, so they are kept untyped.\n        // Some methods in this class only need generics in their signatures, the generics inside the methods\n        // are just for clarity. The generics in signatures allow for static type checking of user provided\n        // listeners and for type inference, so that the users wouldn't have to specify the type of parameters\n        // of their inline lambdas.\n        this.allPropertyListeners = new Map(); // property name => property change listener => scopes\n        this.allEventListeners = new Map(); // event type => event listener => scopes\n    }\n    Observable.prototype.addPropertyListener = function (name, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allPropertyListeners = this.allPropertyListeners;\n        var propertyListeners = allPropertyListeners.get(name);\n        if (!propertyListeners) {\n            propertyListeners = new Map();\n            allPropertyListeners.set(name, propertyListeners);\n        }\n        if (!propertyListeners.has(listener)) {\n            var scopes_1 = new Set();\n            propertyListeners.set(listener, scopes_1);\n        }\n        var scopes = propertyListeners.get(listener);\n        if (scopes) {\n            scopes.add(scope);\n        }\n    };\n    Observable.prototype.removePropertyListener = function (name, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allPropertyListeners = this.allPropertyListeners;\n        var propertyListeners = allPropertyListeners.get(name);\n        if (propertyListeners) {\n            if (listener) {\n                var scopes = propertyListeners.get(listener);\n                if (scopes) {\n                    scopes.delete(scope);\n                    if (!scopes.size) {\n                        propertyListeners.delete(listener);\n                    }\n                }\n            }\n            else {\n                propertyListeners.clear();\n            }\n        }\n    };\n    Observable.prototype.notifyPropertyListeners = function (name, oldValue, value) {\n        var _this = this;\n        var allPropertyListeners = this.allPropertyListeners;\n        var propertyListeners = allPropertyListeners.get(name);\n        if (propertyListeners) {\n            propertyListeners.forEach(function (scopes, listener) {\n                scopes.forEach(function (scope) { return listener.call(scope, { type: name, source: _this, value: value, oldValue: oldValue }); });\n            });\n        }\n    };\n    Observable.prototype.addEventListener = function (type, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allEventListeners = this.allEventListeners;\n        var eventListeners = allEventListeners.get(type);\n        if (!eventListeners) {\n            eventListeners = new Map();\n            allEventListeners.set(type, eventListeners);\n        }\n        if (!eventListeners.has(listener)) {\n            var scopes_2 = new Set();\n            eventListeners.set(listener, scopes_2);\n        }\n        var scopes = eventListeners.get(listener);\n        if (scopes) {\n            scopes.add(scope);\n        }\n    };\n    Observable.prototype.removeEventListener = function (type, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allEventListeners = this.allEventListeners;\n        var eventListeners = allEventListeners.get(type);\n        if (eventListeners) {\n            if (listener) {\n                var scopes = eventListeners.get(listener);\n                if (scopes) {\n                    scopes.delete(scope);\n                    if (!scopes.size) {\n                        eventListeners.delete(listener);\n                    }\n                }\n            }\n            else {\n                eventListeners.clear();\n            }\n        }\n    };\n    Observable.prototype.notifyEventListeners = function (types) {\n        var _this = this;\n        var allEventListeners = this.allEventListeners;\n        types.forEach(function (type) {\n            var listeners = allEventListeners.get(type);\n            if (listeners) {\n                listeners.forEach(function (scopes, listener) {\n                    scopes.forEach(function (scope) { return listener.call(scope, { type: type, source: _this }); });\n                });\n            }\n        });\n    };\n    Observable.prototype.fireEvent = function (event) {\n        var _this = this;\n        var listeners = this.allEventListeners.get(event.type);\n        if (listeners) {\n            listeners.forEach(function (scopes, listener) {\n                scopes.forEach(function (scope) { return listener.call(scope, __assign(__assign({}, event), { source: _this })); });\n            });\n        }\n    };\n    Observable.privateKeyPrefix = '_';\n    return Observable;\n}());\nexport { Observable };\nexport function reactive() {\n    var events = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        events[_i] = arguments[_i];\n    }\n    // let debug = events.indexOf('debugger') >= 0;\n    return function (target, key) {\n        // `target` is either a constructor (static member) or prototype (instance member)\n        var privateKey = Observable.privateKeyPrefix + key;\n        var privateKeyEvents = privateKey + 'Events';\n        if (!target[key]) {\n            if (events) {\n                target[privateKeyEvents] = events;\n            }\n            Object.defineProperty(target, key, {\n                set: function (value) {\n                    var oldValue = this[privateKey];\n                    // This is a way to stop inside the setter by adding the special\n                    // 'debugger' event to a reactive property, for example:\n                    //  @reactive('layoutChange', 'debugger') title?: Caption;\n                    // if (debug) { // DO NOT REMOVE\n                    //     debugger;\n                    // }\n                    if (value !== oldValue || (typeof value === 'object' && value !== null)) {\n                        this[privateKey] = value;\n                        this.notifyPropertyListeners(key, oldValue, value);\n                        var events_1 = this[privateKeyEvents];\n                        if (events_1) {\n                            this.notifyEventListeners(events_1);\n                        }\n                    }\n                },\n                get: function () {\n                    return this[privateKey];\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}