{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Node } from \"./node\";\nimport { BBox } from \"./bbox\";\nimport { Matrix } from \"./matrix\";\n\nvar Group =\n/** @class */\nfunction (_super) {\n  __extends(Group, _super);\n\n  function Group() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.isContainerNode = true;\n    return _this;\n  } // We consider a group to be boundless, thus any point belongs to it.\n\n\n  Group.prototype.containsPoint = function (x, y) {\n    return true;\n  };\n\n  Group.prototype.computeBBox = function () {\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n\n    if (this.dirtyTransform) {\n      this.computeTransformMatrix();\n    }\n\n    this.children.forEach(function (child) {\n      if (!child.visible) {\n        return;\n      }\n\n      var bbox = child.computeBBox();\n\n      if (!bbox) {\n        return;\n      }\n\n      if (!(child instanceof Group)) {\n        if (child.dirtyTransform) {\n          child.computeTransformMatrix();\n        }\n\n        var matrix = Matrix.flyweight(child.matrix);\n        var parent_1 = child.parent;\n\n        while (parent_1) {\n          matrix.preMultiplySelf(parent_1.matrix);\n          parent_1 = parent_1.parent;\n        }\n\n        matrix.transformBBox(bbox, 0, bbox);\n      }\n\n      var x = bbox.x;\n      var y = bbox.y;\n\n      if (x < left) {\n        left = x;\n      }\n\n      if (y < top) {\n        top = y;\n      }\n\n      if (x + bbox.width > right) {\n        right = x + bbox.width;\n      }\n\n      if (y + bbox.height > bottom) {\n        bottom = y + bbox.height;\n      }\n    });\n    return new BBox(left, top, right - left, bottom - top);\n  };\n\n  Group.prototype.render = function (ctx) {\n    // A group can have `scaling`, `rotation`, `translation` properties\n    // that are applied to the canvas context before children are rendered,\n    // so all children can be transformed at once.\n    if (this.dirtyTransform) {\n      this.computeTransformMatrix();\n    }\n\n    this.matrix.toContext(ctx);\n    var children = this.children;\n    var n = children.length;\n\n    for (var i = 0; i < n; i++) {\n      ctx.save();\n      var child = children[i];\n\n      if (child.visible) {\n        child.render(ctx);\n      }\n\n      ctx.restore();\n    } // debug\n    // this.computeBBox().render(ctx, {\n    //     label: this.id,\n    //     resetTransform: true,\n    //     fillStyle: 'rgba(0, 0, 0, 0.5)'\n    // });\n\n  };\n\n  Group.className = 'Group';\n  return Group;\n}(Node);\n\nexport { Group };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/group.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Node","BBox","Matrix","Group","_super","_this","apply","arguments","isContainerNode","containsPoint","x","y","computeBBox","left","Infinity","right","top","bottom","dirtyTransform","computeTransformMatrix","children","forEach","child","visible","bbox","matrix","flyweight","parent_1","parent","preMultiplySelf","transformBBox","width","height","render","ctx","toContext","n","length","i","save","restore","className"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Node } from \"./node\";\nimport { BBox } from \"./bbox\";\nimport { Matrix } from \"./matrix\";\nvar Group = /** @class */ (function (_super) {\n    __extends(Group, _super);\n    function Group() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isContainerNode = true;\n        return _this;\n    }\n    // We consider a group to be boundless, thus any point belongs to it.\n    Group.prototype.containsPoint = function (x, y) {\n        return true;\n    };\n    Group.prototype.computeBBox = function () {\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.children.forEach(function (child) {\n            if (!child.visible) {\n                return;\n            }\n            var bbox = child.computeBBox();\n            if (!bbox) {\n                return;\n            }\n            if (!(child instanceof Group)) {\n                if (child.dirtyTransform) {\n                    child.computeTransformMatrix();\n                }\n                var matrix = Matrix.flyweight(child.matrix);\n                var parent_1 = child.parent;\n                while (parent_1) {\n                    matrix.preMultiplySelf(parent_1.matrix);\n                    parent_1 = parent_1.parent;\n                }\n                matrix.transformBBox(bbox, 0, bbox);\n            }\n            var x = bbox.x;\n            var y = bbox.y;\n            if (x < left) {\n                left = x;\n            }\n            if (y < top) {\n                top = y;\n            }\n            if (x + bbox.width > right) {\n                right = x + bbox.width;\n            }\n            if (y + bbox.height > bottom) {\n                bottom = y + bbox.height;\n            }\n        });\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    Group.prototype.render = function (ctx) {\n        // A group can have `scaling`, `rotation`, `translation` properties\n        // that are applied to the canvas context before children are rendered,\n        // so all children can be transformed at once.\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.matrix.toContext(ctx);\n        var children = this.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n            ctx.save();\n            var child = children[i];\n            if (child.visible) {\n                child.render(ctx);\n            }\n            ctx.restore();\n        }\n        // debug\n        // this.computeBBox().render(ctx, {\n        //     label: this.id,\n        //     resetTransform: true,\n        //     fillStyle: 'rgba(0, 0, 0, 0.5)'\n        // });\n    };\n    Group.className = 'Group';\n    return Group;\n}(Node));\nexport { Group };\n"]},"metadata":{},"sourceType":"module"}