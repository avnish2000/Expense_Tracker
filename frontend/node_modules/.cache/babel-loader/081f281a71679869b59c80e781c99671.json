{"ast":null,"code":"import { find } from \"../util/array\";\n/**\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\n * and the tree grows downward from the root.\n */\n\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode(label, parent, number) {\n    if (label === void 0) {\n      label = '';\n    }\n\n    if (number === void 0) {\n      number = 0;\n    }\n\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label; // screenX and screenY are meant to be recomputed from (layout) x and y\n    // when the tree is resized (without performing another layout)\n\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number;\n  }\n\n  TreeNode.prototype.getLeftSibling = function () {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\n  };\n\n  TreeNode.prototype.getLeftmostSibling = function () {\n    return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n  }; // traverse the left contour of a subtree, return the successor of v on this contour\n\n\n  TreeNode.prototype.nextLeft = function () {\n    return this.children ? this.children[0] : this.thread;\n  }; // traverse the right contour of a subtree, return the successor of v on this contour\n\n\n  TreeNode.prototype.nextRight = function () {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  };\n\n  TreeNode.prototype.getSiblings = function () {\n    var _this = this;\n\n    return this.parent ? this.parent.children.filter(function (_, i) {\n      return i !== _this.number;\n    }) : [];\n  };\n\n  return TreeNode;\n}();\n/**\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\n * creating empty labels.\n */\n\n\nexport function ticksToTree(ticks, pad) {\n  if (pad === void 0) {\n    pad = true;\n  }\n\n  var root = new TreeNode();\n  var depth = 0;\n\n  if (pad) {\n    ticks.forEach(function (tick) {\n      return depth = Math.max(depth, tick.labels.length);\n    });\n  }\n\n  ticks.forEach(function (tick) {\n    if (pad) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift('');\n      }\n    }\n\n    insertTick(root, tick);\n  });\n  return root;\n}\n\nfunction insertTick(root, tick) {\n  var pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n\n  var lastPartIndex = pathParts.length - 1;\n  pathParts.forEach(function (pathPart, partIndex) {\n    var children = root.children;\n    var existingNode = find(children, function (child) {\n      return child.label === pathPart;\n    });\n    var isNotLeaf = partIndex !== lastPartIndex;\n\n    if (existingNode && isNotLeaf) {\n      // the isNotLeaf check is to allow duplicate leafs\n      root = existingNode;\n    } else {\n      var node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n} // Shift the subtree.\n\n\nfunction moveSubtree(wm, wp, shift) {\n  var subtrees = wp.number - wm.number;\n  var ratio = shift / subtrees;\n  wp.change -= ratio;\n  wp.shift += shift;\n  wm.change += ratio;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\n\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n} // Spaces out the children.\n\n\nfunction executeShifts(v) {\n  var children = v.children;\n\n  if (children) {\n    var shift = 0;\n    var change = 0;\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      var w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n} // Moves current subtree with v as the root if some nodes are conflicting in space.\n\n\nfunction apportion(v, defaultAncestor, distance) {\n  var w = v.getLeftSibling();\n\n  if (w) {\n    var vop = v;\n    var vip = v;\n    var vim = w;\n    var vom = vip.getLeftmostSibling();\n    var sip = vip.mod;\n    var sop = vop.mod;\n    var sim = vim.mod;\n    var som = vom.mod;\n\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      var shift = vim.prelim + sim - (vip.prelim + sip) + distance;\n\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n\n      defaultAncestor = v;\n    }\n  }\n\n  return defaultAncestor;\n} // Compute the preliminary x-coordinate of node and its children (recursively).\n\n\nfunction firstWalk(node, distance) {\n  var children = node.children;\n\n  if (children.length) {\n    var defaultAncestor_1 = children[0];\n    children.forEach(function (child) {\n      firstWalk(child, distance);\n      defaultAncestor_1 = apportion(child, defaultAncestor_1, distance);\n    });\n    executeShifts(node);\n    var midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n    var leftSibling = node.getLeftSibling();\n\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    var leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n  }\n}\n\nvar Dimensions =\n/** @class */\nfunction () {\n  function Dimensions() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n\n  Dimensions.prototype.update = function (node, xy) {\n    var _a = xy(node),\n        x = _a.x,\n        y = _a.y;\n\n    if (x > this.right) {\n      this.right = x;\n    }\n\n    if (x < this.left) {\n      this.left = x;\n    }\n\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n\n    if (y < this.top) {\n      this.top = y;\n    }\n  };\n\n  return Dimensions;\n}();\n\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach(function (w) {\n    return secondWalk(w, m + v.mod, layout);\n  });\n} // After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\n\n\nfunction thirdWalk(v) {\n  var children = v.children;\n  var leafCount = 0;\n  children.forEach(function (w) {\n    thirdWalk(w);\n\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\n\nexport function treeLayout(root) {\n  var layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\n\nvar TreeLayout =\n/** @class */\nfunction () {\n  function TreeLayout() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = []; // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n\n  TreeLayout.prototype.update = function (node) {\n    this.dimensions.update(node, function (node) {\n      return {\n        x: node.x,\n        y: node.y\n      };\n    });\n\n    if (!node.children.length) {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    } else {\n      this.nonLeafNodes.push(node);\n    }\n\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n\n    this.nodes.push(node);\n  };\n\n  TreeLayout.prototype.resize = function (width, height, shiftX, shiftY, flipX) {\n    if (shiftX === void 0) {\n      shiftX = 0;\n    }\n\n    if (shiftY === void 0) {\n      shiftY = 0;\n    }\n\n    if (flipX === void 0) {\n      flipX = false;\n    }\n\n    var xSteps = this.leafCount - 1;\n    var ySteps = this.depth;\n    var dimensions = this.dimensions;\n    var scalingX = 1;\n    var scalingY = 1;\n\n    if (width > 0 && xSteps) {\n      var existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      var desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n\n    if (height > 0 && ySteps) {\n      var existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      var desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n\n    var screenDimensions = new Dimensions();\n    this.nodes.forEach(function (node) {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, function (node) {\n        return {\n          x: node.screenX,\n          y: node.screenY\n        };\n      });\n    }); // Normalize so that root top and leftmost leaf left start at zero.\n\n    var offsetX = -screenDimensions.left;\n    var offsetY = -screenDimensions.top;\n    this.nodes.forEach(function (node) {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  };\n\n  return TreeLayout;\n}();\n\nexport { TreeLayout };\n\nfunction logTree(root, formatter) {\n  root.children.forEach(function (child) {\n    return logTree(child, formatter);\n  });\n\n  if (formatter) {\n    console.log(formatter(root));\n  } else {\n    console.log(root);\n  }\n}","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/layout/tree.js"],"names":["find","TreeNode","label","parent","number","x","y","subtreeLeft","NaN","subtreeRight","screenX","screenY","children","leafCount","prelim","mod","ancestor","change","shift","depth","prototype","getLeftSibling","undefined","getLeftmostSibling","nextLeft","thread","nextRight","length","getSiblings","_this","filter","_","i","ticksToTree","ticks","pad","root","forEach","tick","Math","max","labels","unshift","insertTick","pathParts","slice","reverse","lastPartIndex","pathPart","partIndex","existingNode","child","isNotLeaf","node","push","moveSubtree","wm","wp","subtrees","ratio","vim","v","defaultAncestor","indexOf","executeShifts","w","apportion","distance","vop","vip","vom","sip","sop","sim","som","firstWalk","defaultAncestor_1","midpoint","leftSibling","Dimensions","top","Infinity","right","bottom","left","update","xy","_a","secondWalk","m","layout","thirdWalk","treeLayout","TreeLayout","dimensions","nodes","leafNodes","nonLeafNodes","resize","width","height","shiftX","shiftY","flipX","xSteps","ySteps","scalingX","scalingY","existingSpacingX","desiredSpacingX","existingSpacingY","desiredSpacingY","screenDimensions","offsetX","offsetY","logTree","formatter","console","log"],"mappings":"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","sourcesContent":["import { find } from \"../util/array\";\n/**\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\n * and the tree grows downward from the root.\n */\nvar TreeNode = /** @class */ (function () {\n    function TreeNode(label, parent, number) {\n        if (label === void 0) { label = ''; }\n        if (number === void 0) { number = 0; }\n        this.x = 0;\n        this.y = 0;\n        this.subtreeLeft = NaN;\n        this.subtreeRight = NaN;\n        this.screenX = 0;\n        this.screenY = 0;\n        this.children = [];\n        this.leafCount = 0;\n        this.prelim = 0;\n        this.mod = 0;\n        this.ancestor = this;\n        this.change = 0;\n        this.shift = 0;\n        this.label = label;\n        // screenX and screenY are meant to be recomputed from (layout) x and y\n        // when the tree is resized (without performing another layout)\n        this.parent = parent;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.number = number;\n    }\n    TreeNode.prototype.getLeftSibling = function () {\n        return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\n    };\n    TreeNode.prototype.getLeftmostSibling = function () {\n        return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n    };\n    // traverse the left contour of a subtree, return the successor of v on this contour\n    TreeNode.prototype.nextLeft = function () {\n        return this.children ? this.children[0] : this.thread;\n    };\n    // traverse the right contour of a subtree, return the successor of v on this contour\n    TreeNode.prototype.nextRight = function () {\n        return this.children ? this.children[this.children.length - 1] : this.thread;\n    };\n    TreeNode.prototype.getSiblings = function () {\n        var _this = this;\n        return this.parent ? this.parent.children.filter(function (_, i) { return i !== _this.number; }) : [];\n    };\n    return TreeNode;\n}());\n/**\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\n * creating empty labels.\n */\nexport function ticksToTree(ticks, pad) {\n    if (pad === void 0) { pad = true; }\n    var root = new TreeNode();\n    var depth = 0;\n    if (pad) {\n        ticks.forEach(function (tick) { return depth = Math.max(depth, tick.labels.length); });\n    }\n    ticks.forEach(function (tick) {\n        if (pad) {\n            while (tick.labels.length < depth) {\n                tick.labels.unshift('');\n            }\n        }\n        insertTick(root, tick);\n    });\n    return root;\n}\nfunction insertTick(root, tick) {\n    var pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n    var lastPartIndex = pathParts.length - 1;\n    pathParts.forEach(function (pathPart, partIndex) {\n        var children = root.children;\n        var existingNode = find(children, function (child) { return child.label === pathPart; });\n        var isNotLeaf = partIndex !== lastPartIndex;\n        if (existingNode && isNotLeaf) { // the isNotLeaf check is to allow duplicate leafs\n            root = existingNode;\n        }\n        else {\n            var node = new TreeNode(pathPart, root);\n            node.number = children.length;\n            children.push(node);\n            if (isNotLeaf) {\n                root = node;\n            }\n        }\n    });\n}\n// Shift the subtree.\nfunction moveSubtree(wm, wp, shift) {\n    var subtrees = wp.number - wm.number;\n    var ratio = shift / subtrees;\n    wp.change -= ratio;\n    wp.shift += shift;\n    wm.change += ratio;\n    wp.prelim += shift;\n    wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\n// Spaces out the children.\nfunction executeShifts(v) {\n    var children = v.children;\n    if (children) {\n        var shift = 0;\n        var change = 0;\n        for (var i = children.length - 1; i >= 0; i--) {\n            var w = children[i];\n            w.prelim += shift;\n            w.mod += shift;\n            change += w.change;\n            shift += w.shift + change;\n        }\n    }\n}\n// Moves current subtree with v as the root if some nodes are conflicting in space.\nfunction apportion(v, defaultAncestor, distance) {\n    var w = v.getLeftSibling();\n    if (w) {\n        var vop = v;\n        var vip = v;\n        var vim = w;\n        var vom = vip.getLeftmostSibling();\n        var sip = vip.mod;\n        var sop = vop.mod;\n        var sim = vim.mod;\n        var som = vom.mod;\n        while (vim.nextRight() && vip.nextLeft()) {\n            vim = vim.nextRight();\n            vip = vip.nextLeft();\n            vom = vom.nextLeft();\n            vop = vop.nextRight();\n            vop.ancestor = v;\n            var shift = (vim.prelim + sim) - (vip.prelim + sip) + distance;\n            if (shift > 0) {\n                moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n                sip += shift;\n                sop += shift;\n            }\n            sim += vim.mod;\n            sip += vip.mod;\n            som += vom.mod;\n            sop += vop.mod;\n        }\n        if (vim.nextRight() && !vop.nextRight()) {\n            vop.thread = vim.nextRight();\n            vop.mod += sim - sop;\n        }\n        else {\n            if (vip.nextLeft() && !vom.nextLeft()) {\n                vom.thread = vip.nextLeft();\n                vom.mod += sip - som;\n            }\n            defaultAncestor = v;\n        }\n    }\n    return defaultAncestor;\n}\n// Compute the preliminary x-coordinate of node and its children (recursively).\nfunction firstWalk(node, distance) {\n    var children = node.children;\n    if (children.length) {\n        var defaultAncestor_1 = children[0];\n        children.forEach(function (child) {\n            firstWalk(child, distance);\n            defaultAncestor_1 = apportion(child, defaultAncestor_1, distance);\n        });\n        executeShifts(node);\n        var midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n        var leftSibling = node.getLeftSibling();\n        if (leftSibling) {\n            node.prelim = leftSibling.prelim + distance;\n            node.mod = node.prelim - midpoint;\n        }\n        else {\n            node.prelim = midpoint;\n        }\n    }\n    else {\n        var leftSibling = node.getLeftSibling();\n        node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n    }\n}\nvar Dimensions = /** @class */ (function () {\n    function Dimensions() {\n        this.top = Infinity;\n        this.right = -Infinity;\n        this.bottom = -Infinity;\n        this.left = Infinity;\n    }\n    Dimensions.prototype.update = function (node, xy) {\n        var _a = xy(node), x = _a.x, y = _a.y;\n        if (x > this.right) {\n            this.right = x;\n        }\n        if (x < this.left) {\n            this.left = x;\n        }\n        if (y > this.bottom) {\n            this.bottom = y;\n        }\n        if (y < this.top) {\n            this.top = y;\n        }\n    };\n    return Dimensions;\n}());\nfunction secondWalk(v, m, layout) {\n    v.x = v.prelim + m;\n    v.y = v.depth;\n    layout.update(v);\n    v.children.forEach(function (w) { return secondWalk(w, m + v.mod, layout); });\n}\n// After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\nfunction thirdWalk(v) {\n    var children = v.children;\n    var leafCount = 0;\n    children.forEach(function (w) {\n        thirdWalk(w);\n        if (w.children.length) {\n            leafCount += w.leafCount;\n        }\n        else {\n            leafCount++;\n        }\n    });\n    v.leafCount = leafCount;\n    if (children.length) {\n        v.subtreeLeft = children[0].subtreeLeft;\n        v.subtreeRight = children[v.children.length - 1].subtreeRight;\n        v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n    }\n    else {\n        v.subtreeLeft = v.x;\n        v.subtreeRight = v.x;\n    }\n}\nexport function treeLayout(root) {\n    var layout = new TreeLayout;\n    firstWalk(root, 1);\n    secondWalk(root, -root.prelim, layout);\n    thirdWalk(root);\n    return layout;\n}\nvar TreeLayout = /** @class */ (function () {\n    function TreeLayout() {\n        this.dimensions = new Dimensions;\n        this.leafCount = 0;\n        this.nodes = [];\n        // One might want to process leaf nodes separately from the rest of the tree.\n        // For example, position labels corresponding to leafs vertically, rather than horizontally.\n        this.leafNodes = [];\n        this.nonLeafNodes = [];\n        this.depth = 0;\n    }\n    TreeLayout.prototype.update = function (node) {\n        this.dimensions.update(node, function (node) { return ({ x: node.x, y: node.y }); });\n        if (!node.children.length) {\n            this.leafCount++;\n            this.leafNodes.push(node);\n        }\n        else {\n            this.nonLeafNodes.push(node);\n        }\n        if (node.depth > this.depth) {\n            this.depth = node.depth;\n        }\n        this.nodes.push(node);\n    };\n    TreeLayout.prototype.resize = function (width, height, shiftX, shiftY, flipX) {\n        if (shiftX === void 0) { shiftX = 0; }\n        if (shiftY === void 0) { shiftY = 0; }\n        if (flipX === void 0) { flipX = false; }\n        var xSteps = this.leafCount - 1;\n        var ySteps = this.depth;\n        var dimensions = this.dimensions;\n        var scalingX = 1;\n        var scalingY = 1;\n        if (width > 0 && xSteps) {\n            var existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n            var desiredSpacingX = width / xSteps;\n            scalingX = desiredSpacingX / existingSpacingX;\n            if (flipX) {\n                scalingX = -scalingX;\n            }\n        }\n        if (height > 0 && ySteps) {\n            var existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n            var desiredSpacingY = height / ySteps;\n            scalingY = desiredSpacingY / existingSpacingY;\n        }\n        var screenDimensions = new Dimensions();\n        this.nodes.forEach(function (node) {\n            node.screenX = node.x * scalingX;\n            node.screenY = node.y * scalingY;\n            screenDimensions.update(node, function (node) { return ({ x: node.screenX, y: node.screenY }); });\n        });\n        // Normalize so that root top and leftmost leaf left start at zero.\n        var offsetX = -screenDimensions.left;\n        var offsetY = -screenDimensions.top;\n        this.nodes.forEach(function (node) {\n            node.screenX += offsetX + shiftX;\n            node.screenY += offsetY + shiftY;\n        });\n    };\n    return TreeLayout;\n}());\nexport { TreeLayout };\nfunction logTree(root, formatter) {\n    root.children.forEach(function (child) { return logTree(child, formatter); });\n    if (formatter) {\n        console.log(formatter(root));\n    }\n    else {\n        console.log(root);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}