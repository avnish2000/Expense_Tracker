{"ast":null,"code":"import { Matrix } from \"./matrix\";\nimport { createId } from \"../util/id\";\nexport var PointerEvents;\n\n(function (PointerEvents) {\n  PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n  PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  function Node() {\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = createId(this);\n    /**\n     * Some number to identify this node, typically within a `Group` node.\n     * Usually this will be some enum value used as a selector.\n     */\n\n    this.tag = NaN;\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n\n    this.isContainerNode = false;\n    this._children = []; // Used to check for duplicate nodes.\n\n    this.childSet = {}; // new Set<Node>()\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n\n    this.matrix = new Matrix();\n    this.inverseMatrix = new Matrix();\n    this._dirtyTransform = false;\n    this._scalingX = 1;\n    this._scalingY = 1;\n    /**\n     * The center of scaling.\n     * The default value of `null` means the scaling center will be\n     * determined automatically, as the center of the bounding box\n     * of a node.\n     */\n\n    this._scalingCenterX = null;\n    this._scalingCenterY = null;\n    this._rotationCenterX = null;\n    this._rotationCenterY = null;\n    /**\n     * Rotation angle in radians.\n     * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n     * interval is performed.\n     */\n\n    this._rotation = 0;\n    this._translationX = 0;\n    this._translationY = 0;\n    /**\n     * Each time a property of the node that effects how it renders changes\n     * the `dirty` property of the node should be set to `true`. The change\n     * to the `dirty` property of the node will propagate up to its parents\n     * and eventually to the scene, at which point an animation frame callback\n     * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n     * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n     * Since changes to node properties are not rendered immediately, it's possible\n     * to change as many properties on as many nodes as needed and the rendering\n     * will still only happen once in the next animation frame callback.\n     * The animation frame callback is only scheduled if it hasn't been already.\n     */\n\n    this._dirty = true;\n    this._visible = true;\n    this.pointerEvents = PointerEvents.All;\n  }\n  /**\n   * This is meaningfully faster than `instanceof` and should be the preferred way\n   * of checking inside loops.\n   * @param node\n   */\n\n\n  Node.isNode = function (node) {\n    return node ? node.matrix !== undefined : false;\n  };\n\n  Node.prototype._setScene = function (value) {\n    this._scene = value;\n    var children = this.children;\n    var n = children.length;\n\n    for (var i = 0; i < n; i++) {\n      children[i]._setScene(value);\n    }\n  };\n\n  Object.defineProperty(Node.prototype, \"scene\", {\n    get: function () {\n      return this._scene;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype._setParent = function (value) {\n    this._parent = value;\n  };\n\n  Object.defineProperty(Node.prototype, \"parent\", {\n    get: function () {\n      return this._parent;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"children\", {\n    get: function () {\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.countChildren = function (depth) {\n    if (depth === void 0) {\n      depth = Node.MAX_SAFE_INTEGER;\n    }\n\n    if (depth <= 0) {\n      return 0;\n    }\n\n    var children = this.children;\n    var n = children.length;\n    var size = n;\n\n    for (var i = 0; i < n; i++) {\n      size += children[i].countChildren(depth - 1);\n    }\n\n    return size;\n  };\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n\n\n  Node.prototype.append = function (nodes) {\n    // Passing a single parameter to an open-ended version of `append`\n    // would be 30-35% slower than this.\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    } // The function takes an array rather than having open-ended\n    // arguments like `...nodes: Node[]` because the latter is\n    // transpiled to a function where the `arguments` object\n    // is copied to a temporary array inside a loop.\n    // So an array is created either way. And if we already have\n    // an array of nodes we want to add, we have to use the prohibitively\n    // expensive spread operator to pass it to the function,\n    // and, on top of that, the copy of the `arguments` is still made.\n\n\n    var n = nodes.length;\n\n    for (var i = 0; i < n; i++) {\n      var node = nodes[i];\n\n      if (node.parent) {\n        throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n      }\n\n      if (node.scene) {\n        throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n      }\n\n      if (this.childSet[node.id]) {\n        // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n        throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n      }\n\n      this._children.push(node);\n\n      this.childSet[node.id] = true;\n\n      node._setParent(this);\n\n      node._setScene(this.scene);\n    }\n\n    this.dirty = true;\n  };\n\n  Node.prototype.appendChild = function (node) {\n    if (node.parent) {\n      throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n    }\n\n    if (node.scene) {\n      throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n    }\n\n    if (this.childSet[node.id]) {\n      // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n      throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n    }\n\n    this._children.push(node);\n\n    this.childSet[node.id] = true;\n\n    node._setParent(this);\n\n    node._setScene(this.scene);\n\n    this.dirty = true;\n    return node;\n  };\n\n  Node.prototype.removeChild = function (node) {\n    if (node.parent === this) {\n      var i = this.children.indexOf(node);\n\n      if (i >= 0) {\n        this._children.splice(i, 1);\n\n        delete this.childSet[node.id];\n\n        node._setParent(undefined);\n\n        node._setScene(undefined);\n\n        this.dirty = true;\n        return node;\n      }\n    }\n\n    throw new Error(\"The node to be removed is not a child of this node.\");\n  };\n  /**\n   * Inserts the node `node` before the existing child node `nextNode`.\n   * If `nextNode` is null, insert `node` at the end of the list of children.\n   * If the `node` belongs to another parent, it is first removed.\n   * Returns the `node`.\n   * @param node\n   * @param nextNode\n   */\n\n\n  Node.prototype.insertBefore = function (node, nextNode) {\n    var parent = node.parent;\n\n    if (node.parent) {\n      node.parent.removeChild(node);\n    }\n\n    if (nextNode && nextNode.parent === this) {\n      var i = this.children.indexOf(nextNode);\n\n      if (i >= 0) {\n        this._children.splice(i, 0, node);\n\n        this.childSet[node.id] = true;\n\n        node._setParent(this);\n\n        node._setScene(this.scene);\n      } else {\n        throw new Error(nextNode + \" has \" + parent + \" as the parent, \" + \"but is not in its list of children.\");\n      }\n\n      this.dirty = true;\n    } else {\n      this.append(node);\n    }\n\n    return node;\n  };\n\n  Object.defineProperty(Node.prototype, \"nextSibling\", {\n    get: function () {\n      var parent = this.parent;\n\n      if (parent) {\n        var children = parent.children;\n        var index = children.indexOf(this);\n\n        if (index >= 0 && index <= children.length - 1) {\n          return children[index + 1];\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.transformPoint = function (x, y) {\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n\n    return matrix.invertSelf().transformPoint(x, y);\n  };\n\n  Node.prototype.inverseTransformPoint = function (x, y) {\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n\n    return matrix.transformPoint(x, y);\n  };\n\n  Object.defineProperty(Node.prototype, \"dirtyTransform\", {\n    get: function () {\n      return this._dirtyTransform;\n    },\n    set: function (value) {\n      this._dirtyTransform = value;\n\n      if (value) {\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingX\", {\n    get: function () {\n      return this._scalingX;\n    },\n    set: function (value) {\n      if (this._scalingX !== value) {\n        this._scalingX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingY\", {\n    get: function () {\n      return this._scalingY;\n    },\n    set: function (value) {\n      if (this._scalingY !== value) {\n        this._scalingY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingCenterX\", {\n    get: function () {\n      return this._scalingCenterX;\n    },\n    set: function (value) {\n      if (this._scalingCenterX !== value) {\n        this._scalingCenterX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingCenterY\", {\n    get: function () {\n      return this._scalingCenterY;\n    },\n    set: function (value) {\n      if (this._scalingCenterY !== value) {\n        this._scalingCenterY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationCenterX\", {\n    get: function () {\n      return this._rotationCenterX;\n    },\n    set: function (value) {\n      if (this._rotationCenterX !== value) {\n        this._rotationCenterX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationCenterY\", {\n    get: function () {\n      return this._rotationCenterY;\n    },\n    set: function (value) {\n      if (this._rotationCenterY !== value) {\n        this._rotationCenterY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotation\", {\n    get: function () {\n      return this._rotation;\n    },\n    set: function (value) {\n      if (this._rotation !== value) {\n        this._rotation = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationDeg\", {\n    get: function () {\n      return this.rotation / Math.PI * 180;\n    },\n\n    /**\n     * For performance reasons the rotation angle's internal representation\n     * is in radians. Therefore, don't expect to get the same number you set.\n     * Even with integer angles about a quarter of them from 0 to 359 cannot\n     * be converted to radians and back without precision loss.\n     * For example:\n     *\n     *     node.rotationDeg = 11;\n     *     console.log(node.rotationDeg); // 10.999999999999998\n     *\n     * @param value Rotation angle in degrees.\n     */\n    set: function (value) {\n      this.rotation = value / 180 * Math.PI;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"translationX\", {\n    get: function () {\n      return this._translationX;\n    },\n    set: function (value) {\n      if (this._translationX !== value) {\n        this._translationX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"translationY\", {\n    get: function () {\n      return this._translationY;\n    },\n    set: function (value) {\n      if (this._translationY !== value) {\n        this._translationY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.containsPoint = function (x, y) {\n    return false;\n  };\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   * @param x\n   * @param y\n   */\n\n\n  Node.prototype.pickNode = function (x, y) {\n    if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n      return;\n    }\n\n    var children = this.children;\n\n    if (children.length) {\n      // Nodes added later should be hit-tested first,\n      // as they are rendered on top of the previously added nodes.\n      for (var i = children.length - 1; i >= 0; i--) {\n        var hit = children[i].pickNode(x, y);\n\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      // a leaf node, but not a container leaf\n      return this;\n    }\n  };\n\n  Node.prototype.computeBBox = function () {\n    return;\n  };\n\n  Node.prototype.computeBBoxCenter = function () {\n    var bbox = this.computeBBox && this.computeBBox();\n\n    if (bbox) {\n      return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];\n    }\n\n    return [0, 0];\n  };\n\n  Node.prototype.computeTransformMatrix = function () {\n    // TODO: transforms without center of scaling and rotation correspond directly\n    //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n    //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n    //       within a group, rotating groups at right angles (e.g. for axis) and translating\n    //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n    //       can be done using D3-like scales already by inverting the output range.\n    //       So for now, just assume that centers of scaling and rotation are at the origin.\n    // const [bbcx, bbcy] = this.computeBBoxCenter();\n    var _a = [0, 0],\n        bbcx = _a[0],\n        bbcy = _a[1];\n    var sx = this.scalingX;\n    var sy = this.scalingY;\n    var scx;\n    var scy;\n\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n      scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n    }\n\n    var r = this.rotation;\n    var cos = Math.cos(r);\n    var sin = Math.sin(r);\n    var rcx;\n    var rcy;\n\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n      rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n    }\n\n    var tx = this.translationX;\n    var ty = this.translationY; // The transform matrix `M` is a result of the following transformations:\n    // 1) translate the center of scaling to the origin\n    // 2) scale\n    // 3) translate back\n    // 4) translate the center of rotation to the origin\n    // 5) rotate\n    // 6) translate back\n    // 7) translate\n    //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n    //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n    // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n    //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n    // Translation after steps 1-4 above:\n\n    var tx4 = scx * (1 - sx) - rcx;\n    var ty4 = scy * (1 - sy) - rcy;\n    this.dirtyTransform = false;\n    this.matrix.setElements([cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx4 - sin * ty4 + rcx + tx, sin * tx4 + cos * ty4 + rcy + ty]).inverseTo(this.inverseMatrix);\n  };\n\n  Object.defineProperty(Node.prototype, \"dirty\", {\n    get: function () {\n      return this._dirty;\n    },\n    set: function (value) {\n      // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n      //       if we are, then all parents and the scene have been\n      //       notified already, and we are doing redundant work\n      //       (but test if this is indeed the case)\n      this._dirty = value;\n\n      if (value) {\n        if (this.parent) {\n          this.parent.dirty = true;\n        } else if (this.scene) {\n          this.scene.dirty = true;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"visible\", {\n    get: function () {\n      return this._visible;\n    },\n    set: function (value) {\n      if (this._visible !== value) {\n        this._visible = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n\n  return Node;\n}();\n\nexport { Node };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/scene/node.js"],"names":["Matrix","createId","PointerEvents","Node","id","tag","NaN","isContainerNode","_children","childSet","matrix","inverseMatrix","_dirtyTransform","_scalingX","_scalingY","_scalingCenterX","_scalingCenterY","_rotationCenterX","_rotationCenterY","_rotation","_translationX","_translationY","_dirty","_visible","pointerEvents","All","isNode","node","undefined","prototype","_setScene","value","_scene","children","n","length","i","Object","defineProperty","get","enumerable","configurable","_setParent","_parent","countChildren","depth","MAX_SAFE_INTEGER","size","append","nodes","parent","Error","scene","constructor","name","push","dirty","appendChild","removeChild","indexOf","splice","insertBefore","nextNode","index","transformPoint","x","y","flyweight","preMultiplySelf","invertSelf","inverseTransformPoint","set","dirtyTransform","rotation","Math","PI","containsPoint","pickNode","visible","None","hit","computeBBox","computeBBoxCenter","bbox","width","height","computeTransformMatrix","_a","bbcx","bbcy","sx","scalingX","sy","scalingY","scx","scy","scalingCenterX","scalingCenterY","r","cos","sin","rcx","rcy","rotationCenterX","rotationCenterY","tx","translationX","ty","translationY","tx4","ty4","setElements","inverseTo","pow"],"mappings":"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","sourcesContent":["import { Matrix } from \"./matrix\";\nimport { createId } from \"../util/id\";\nexport var PointerEvents;\n(function (PointerEvents) {\n    PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n    PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        /**\n         * Unique node ID in the form `ClassName-NaturalNumber`.\n         */\n        this.id = createId(this);\n        /**\n         * Some number to identify this node, typically within a `Group` node.\n         * Usually this will be some enum value used as a selector.\n         */\n        this.tag = NaN;\n        /**\n         * To simplify the type system (especially in Selections) we don't have the `Parent` node\n         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n         * But we still need to distinguish regular leaf nodes from container leafs somehow.\n         */\n        this.isContainerNode = false;\n        this._children = [];\n        // Used to check for duplicate nodes.\n        this.childSet = {}; // new Set<Node>()\n        // These matrices may need to have package level visibility\n        // for performance optimization purposes.\n        this.matrix = new Matrix();\n        this.inverseMatrix = new Matrix();\n        this._dirtyTransform = false;\n        this._scalingX = 1;\n        this._scalingY = 1;\n        /**\n         * The center of scaling.\n         * The default value of `null` means the scaling center will be\n         * determined automatically, as the center of the bounding box\n         * of a node.\n         */\n        this._scalingCenterX = null;\n        this._scalingCenterY = null;\n        this._rotationCenterX = null;\n        this._rotationCenterY = null;\n        /**\n         * Rotation angle in radians.\n         * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n         * interval is performed.\n         */\n        this._rotation = 0;\n        this._translationX = 0;\n        this._translationY = 0;\n        /**\n         * Each time a property of the node that effects how it renders changes\n         * the `dirty` property of the node should be set to `true`. The change\n         * to the `dirty` property of the node will propagate up to its parents\n         * and eventually to the scene, at which point an animation frame callback\n         * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n         * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n         * Since changes to node properties are not rendered immediately, it's possible\n         * to change as many properties on as many nodes as needed and the rendering\n         * will still only happen once in the next animation frame callback.\n         * The animation frame callback is only scheduled if it hasn't been already.\n         */\n        this._dirty = true;\n        this._visible = true;\n        this.pointerEvents = PointerEvents.All;\n    }\n    /**\n     * This is meaningfully faster than `instanceof` and should be the preferred way\n     * of checking inside loops.\n     * @param node\n     */\n    Node.isNode = function (node) {\n        return node ? node.matrix !== undefined : false;\n    };\n    Node.prototype._setScene = function (value) {\n        this._scene = value;\n        var children = this.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n            children[i]._setScene(value);\n        }\n    };\n    Object.defineProperty(Node.prototype, \"scene\", {\n        get: function () {\n            return this._scene;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype._setParent = function (value) {\n        this._parent = value;\n    };\n    Object.defineProperty(Node.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"children\", {\n        get: function () {\n            return this._children;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.countChildren = function (depth) {\n        if (depth === void 0) { depth = Node.MAX_SAFE_INTEGER; }\n        if (depth <= 0) {\n            return 0;\n        }\n        var children = this.children;\n        var n = children.length;\n        var size = n;\n        for (var i = 0; i < n; i++) {\n            size += children[i].countChildren(depth - 1);\n        }\n        return size;\n    };\n    /**\n     * Appends one or more new node instances to this parent.\n     * If one needs to:\n     * - move a child to the end of the list of children\n     * - move a child from one parent to another (including parents in other scenes)\n     * one should use the {@link insertBefore} method instead.\n     * @param nodes A node or nodes to append.\n     */\n    Node.prototype.append = function (nodes) {\n        // Passing a single parameter to an open-ended version of `append`\n        // would be 30-35% slower than this.\n        if (Node.isNode(nodes)) {\n            nodes = [nodes];\n        }\n        // The function takes an array rather than having open-ended\n        // arguments like `...nodes: Node[]` because the latter is\n        // transpiled to a function where the `arguments` object\n        // is copied to a temporary array inside a loop.\n        // So an array is created either way. And if we already have\n        // an array of nodes we want to add, we have to use the prohibitively\n        // expensive spread operator to pass it to the function,\n        // and, on top of that, the copy of the `arguments` is still made.\n        var n = nodes.length;\n        for (var i = 0; i < n; i++) {\n            var node = nodes[i];\n            if (node.parent) {\n                throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n            }\n            if (node.scene) {\n                throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n            }\n            if (this.childSet[node.id]) {\n                // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n                throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n            }\n            this._children.push(node);\n            this.childSet[node.id] = true;\n            node._setParent(this);\n            node._setScene(this.scene);\n        }\n        this.dirty = true;\n    };\n    Node.prototype.appendChild = function (node) {\n        if (node.parent) {\n            throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n        }\n        if (node.scene) {\n            throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n        }\n        if (this.childSet[node.id]) {\n            // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n            throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n        }\n        this._children.push(node);\n        this.childSet[node.id] = true;\n        node._setParent(this);\n        node._setScene(this.scene);\n        this.dirty = true;\n        return node;\n    };\n    Node.prototype.removeChild = function (node) {\n        if (node.parent === this) {\n            var i = this.children.indexOf(node);\n            if (i >= 0) {\n                this._children.splice(i, 1);\n                delete this.childSet[node.id];\n                node._setParent(undefined);\n                node._setScene(undefined);\n                this.dirty = true;\n                return node;\n            }\n        }\n        throw new Error(\"The node to be removed is not a child of this node.\");\n    };\n    /**\n     * Inserts the node `node` before the existing child node `nextNode`.\n     * If `nextNode` is null, insert `node` at the end of the list of children.\n     * If the `node` belongs to another parent, it is first removed.\n     * Returns the `node`.\n     * @param node\n     * @param nextNode\n     */\n    Node.prototype.insertBefore = function (node, nextNode) {\n        var parent = node.parent;\n        if (node.parent) {\n            node.parent.removeChild(node);\n        }\n        if (nextNode && nextNode.parent === this) {\n            var i = this.children.indexOf(nextNode);\n            if (i >= 0) {\n                this._children.splice(i, 0, node);\n                this.childSet[node.id] = true;\n                node._setParent(this);\n                node._setScene(this.scene);\n            }\n            else {\n                throw new Error(nextNode + \" has \" + parent + \" as the parent, \"\n                    + \"but is not in its list of children.\");\n            }\n            this.dirty = true;\n        }\n        else {\n            this.append(node);\n        }\n        return node;\n    };\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        get: function () {\n            var parent = this.parent;\n            if (parent) {\n                var children = parent.children;\n                var index = children.indexOf(this);\n                if (index >= 0 && index <= children.length - 1) {\n                    return children[index + 1];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.transformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.invertSelf().transformPoint(x, y);\n    };\n    Node.prototype.inverseTransformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.transformPoint(x, y);\n    };\n    Object.defineProperty(Node.prototype, \"dirtyTransform\", {\n        get: function () {\n            return this._dirtyTransform;\n        },\n        set: function (value) {\n            this._dirtyTransform = value;\n            if (value) {\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingX\", {\n        get: function () {\n            return this._scalingX;\n        },\n        set: function (value) {\n            if (this._scalingX !== value) {\n                this._scalingX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingY\", {\n        get: function () {\n            return this._scalingY;\n        },\n        set: function (value) {\n            if (this._scalingY !== value) {\n                this._scalingY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingCenterX\", {\n        get: function () {\n            return this._scalingCenterX;\n        },\n        set: function (value) {\n            if (this._scalingCenterX !== value) {\n                this._scalingCenterX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingCenterY\", {\n        get: function () {\n            return this._scalingCenterY;\n        },\n        set: function (value) {\n            if (this._scalingCenterY !== value) {\n                this._scalingCenterY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationCenterX\", {\n        get: function () {\n            return this._rotationCenterX;\n        },\n        set: function (value) {\n            if (this._rotationCenterX !== value) {\n                this._rotationCenterX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationCenterY\", {\n        get: function () {\n            return this._rotationCenterY;\n        },\n        set: function (value) {\n            if (this._rotationCenterY !== value) {\n                this._rotationCenterY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotation\", {\n        get: function () {\n            return this._rotation;\n        },\n        set: function (value) {\n            if (this._rotation !== value) {\n                this._rotation = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationDeg\", {\n        get: function () {\n            return this.rotation / Math.PI * 180;\n        },\n        /**\n         * For performance reasons the rotation angle's internal representation\n         * is in radians. Therefore, don't expect to get the same number you set.\n         * Even with integer angles about a quarter of them from 0 to 359 cannot\n         * be converted to radians and back without precision loss.\n         * For example:\n         *\n         *     node.rotationDeg = 11;\n         *     console.log(node.rotationDeg); // 10.999999999999998\n         *\n         * @param value Rotation angle in degrees.\n         */\n        set: function (value) {\n            this.rotation = value / 180 * Math.PI;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"translationX\", {\n        get: function () {\n            return this._translationX;\n        },\n        set: function (value) {\n            if (this._translationX !== value) {\n                this._translationX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"translationY\", {\n        get: function () {\n            return this._translationY;\n        },\n        set: function (value) {\n            if (this._translationY !== value) {\n                this._translationY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.containsPoint = function (x, y) {\n        return false;\n    };\n    /**\n     * Hit testing method.\n     * Recursively checks if the given point is inside this node or any of its children.\n     * Returns the first matching node or `undefined`.\n     * Nodes that render later (show on top) are hit tested first.\n     * @param x\n     * @param y\n     */\n    Node.prototype.pickNode = function (x, y) {\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n            return;\n        }\n        var children = this.children;\n        if (children.length) {\n            // Nodes added later should be hit-tested first,\n            // as they are rendered on top of the previously added nodes.\n            for (var i = children.length - 1; i >= 0; i--) {\n                var hit = children[i].pickNode(x, y);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n        else if (!this.isContainerNode) { // a leaf node, but not a container leaf\n            return this;\n        }\n    };\n    Node.prototype.computeBBox = function () { return; };\n    Node.prototype.computeBBoxCenter = function () {\n        var bbox = this.computeBBox && this.computeBBox();\n        if (bbox) {\n            return [\n                bbox.x + bbox.width * 0.5,\n                bbox.y + bbox.height * 0.5\n            ];\n        }\n        return [0, 0];\n    };\n    Node.prototype.computeTransformMatrix = function () {\n        // TODO: transforms without center of scaling and rotation correspond directly\n        //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n        //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n        //       within a group, rotating groups at right angles (e.g. for axis) and translating\n        //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n        //       can be done using D3-like scales already by inverting the output range.\n        //       So for now, just assume that centers of scaling and rotation are at the origin.\n        // const [bbcx, bbcy] = this.computeBBoxCenter();\n        var _a = [0, 0], bbcx = _a[0], bbcy = _a[1];\n        var sx = this.scalingX;\n        var sy = this.scalingY;\n        var scx;\n        var scy;\n        if (sx === 1 && sy === 1) {\n            scx = 0;\n            scy = 0;\n        }\n        else {\n            scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n            scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n        }\n        var r = this.rotation;\n        var cos = Math.cos(r);\n        var sin = Math.sin(r);\n        var rcx;\n        var rcy;\n        if (r === 0) {\n            rcx = 0;\n            rcy = 0;\n        }\n        else {\n            rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n            rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n        }\n        var tx = this.translationX;\n        var ty = this.translationY;\n        // The transform matrix `M` is a result of the following transformations:\n        // 1) translate the center of scaling to the origin\n        // 2) scale\n        // 3) translate back\n        // 4) translate the center of rotation to the origin\n        // 5) rotate\n        // 6) translate back\n        // 7) translate\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n        // Translation after steps 1-4 above:\n        var tx4 = scx * (1 - sx) - rcx;\n        var ty4 = scy * (1 - sy) - rcy;\n        this.dirtyTransform = false;\n        this.matrix.setElements([\n            cos * sx, sin * sx,\n            -sin * sy, cos * sy,\n            cos * tx4 - sin * ty4 + rcx + tx,\n            sin * tx4 + cos * ty4 + rcy + ty\n        ]).inverseTo(this.inverseMatrix);\n    };\n    Object.defineProperty(Node.prototype, \"dirty\", {\n        get: function () {\n            return this._dirty;\n        },\n        set: function (value) {\n            // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n            //       if we are, then all parents and the scene have been\n            //       notified already, and we are doing redundant work\n            //       (but test if this is indeed the case)\n            this._dirty = value;\n            if (value) {\n                if (this.parent) {\n                    this.parent.dirty = true;\n                }\n                else if (this.scene) {\n                    this.scene.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"visible\", {\n        get: function () {\n            return this._visible;\n        },\n        set: function (value) {\n            if (this._visible !== value) {\n                this._visible = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n    return Node;\n}());\nexport { Node };\n"]},"metadata":{},"sourceType":"module"}