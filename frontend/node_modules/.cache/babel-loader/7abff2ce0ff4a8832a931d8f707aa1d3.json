{"ast":null,"code":"import { ascending } from \"./compare\";\n/**\n * Returns the insertion point for `x` in array to maintain sorted order.\n * The arguments `lo` and `hi` may be used to specify a subset of the array which should be considered;\n * by default the entire array is used. If `x` is already present in array, the insertion point will be before\n * (to the left of) any existing entries. The return value is suitable for use as the first argument to `splice`\n * assuming that array is already sorted. The returned insertion point `i` partitions the array into two halves\n * so that all `v < x` for `v` in `array.slice(lo, i)` for the left side and all `v >= x` for `v` in `array.slice(i, hi)`\n * for the right side.\n * @param list\n * @param x\n * @param comparator\n * @param lo\n * @param hi\n */\n\nexport function bisectLeft(list, x, comparator, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n\n  if (hi === void 0) {\n    hi = list.length;\n  }\n\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (comparator(list[mid], x) < 0) {\n      // list[mid] < x\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return lo;\n}\nexport function bisectRight(list, x, comparator, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n\n  if (hi === void 0) {\n    hi = list.length;\n  }\n\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (comparator(list[mid], x) > 0) {\n      // list[mid] > x\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  return lo;\n}\n/**\n * A specialized version of `bisectLeft` that works with the arrays whose elements cannot be compared directly.\n * The map function is used instead to produce a comparable value for a given array element, then the values\n * returned by the map are compared using the `ascendingComparator`.\n * @param list\n * @param x\n * @param map\n * @param lo\n * @param hi\n */\n\nexport function complexBisectLeft(list, x, map, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n\n  if (hi === void 0) {\n    hi = list.length;\n  }\n\n  var comparator = ascendingComparator(map);\n\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (comparator(list[mid], x) < 0) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return lo;\n}\nexport function complexBisectRight(list, x, map, lo, hi) {\n  if (lo === void 0) {\n    lo = 0;\n  }\n\n  if (hi === void 0) {\n    hi = list.length;\n  }\n\n  var comparator = ascendingComparator(map);\n\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (comparator(list[mid], x) < 0) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return lo;\n}\n\nfunction ascendingComparator(map) {\n  return function (item, x) {\n    return ascending(map(item), x);\n  };\n}","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/util/bisect.js"],"names":["ascending","bisectLeft","list","x","comparator","lo","hi","length","mid","bisectRight","complexBisectLeft","map","ascendingComparator","complexBisectRight","item"],"mappings":"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","sourcesContent":["import { ascending } from \"./compare\";\n/**\n * Returns the insertion point for `x` in array to maintain sorted order.\n * The arguments `lo` and `hi` may be used to specify a subset of the array which should be considered;\n * by default the entire array is used. If `x` is already present in array, the insertion point will be before\n * (to the left of) any existing entries. The return value is suitable for use as the first argument to `splice`\n * assuming that array is already sorted. The returned insertion point `i` partitions the array into two halves\n * so that all `v < x` for `v` in `array.slice(lo, i)` for the left side and all `v >= x` for `v` in `array.slice(i, hi)`\n * for the right side.\n * @param list\n * @param x\n * @param comparator\n * @param lo\n * @param hi\n */\nexport function bisectLeft(list, x, comparator, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) { // list[mid] < x\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nexport function bisectRight(list, x, comparator, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) > 0) { // list[mid] > x\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    return lo;\n}\n/**\n * A specialized version of `bisectLeft` that works with the arrays whose elements cannot be compared directly.\n * The map function is used instead to produce a comparable value for a given array element, then the values\n * returned by the map are compared using the `ascendingComparator`.\n * @param list\n * @param x\n * @param map\n * @param lo\n * @param hi\n */\nexport function complexBisectLeft(list, x, map, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    var comparator = ascendingComparator(map);\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) {\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nexport function complexBisectRight(list, x, map, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    var comparator = ascendingComparator(map);\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) {\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nfunction ascendingComparator(map) {\n    return function (item, x) {\n        return ascending(map(item), x);\n    };\n}\n"]},"metadata":{},"sourceType":"module"}