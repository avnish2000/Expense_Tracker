{"ast":null,"code":"import { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\";\nimport { Text } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\";\n// import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\nvar Tags;\n(function (Tags) {\n  Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n  Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisTick = /** @class */function () {\n  function AxisTick() {\n    /**\n     * The line width to be used by axis ticks.\n     */\n    this.width = 1;\n    /**\n     * The line length to be used by axis ticks.\n     */\n    this.size = 6;\n    /**\n     * The color of the axis ticks.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n     */\n    this.color = 'rgba(195, 195, 195, 1)';\n    /**\n     * A hint of how many ticks to use (the exact number of ticks might differ),\n     * a `TimeInterval` or a `CountableTimeInterval`.\n     * For example:\n     *\n     *     axis.tick.count = 5;\n     *     axis.tick.count = year;\n     *     axis.tick.count = month.every(6);\n     */\n    this.count = 10;\n  }\n  return AxisTick;\n}();\nexport { AxisTick };\nvar AxisLabel = /** @class */function () {\n  function AxisLabel() {\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\n     * The padding between the labels and the ticks.\n     */\n    this.padding = 5;\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n    this.color = 'rgba(87, 87, 87, 1)';\n    /**\n     * Custom label rotation in degrees.\n     * Labels are rendered perpendicular to the axis line by default.\n     * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n     * The value of this config is used as the angular offset/deflection\n     * from the default rotation.\n     */\n    this.rotation = 0;\n    /**\n     * By default labels and ticks are positioned to the left of the axis line.\n     * `true` positions the labels to the right of the axis line.\n     * However, if the axis is rotated, its easier to think in terms\n     * of this side or the opposite side, rather than left and right.\n     * We use the term `mirror` for conciseness, although it's not\n     * true mirroring - for example, when a label is rotated, so that\n     * it is inclined at the 45 degree angle, text flowing from north-west\n     * to south-east, ending at the tick to the left of the axis line,\n     * and then we set this config to `true`, the text will still be flowing\n     * from north-west to south-east, _starting_ at the tick to the right\n     * of the axis line.\n     */\n    this.mirrored = false;\n    /**\n     * Labels are rendered perpendicular to the axis line by default.\n     * Setting this config to `true` makes labels render parallel to the axis line\n     * and center aligns labels' text at the ticks.\n     */\n    this.parallel = false;\n  }\n  Object.defineProperty(AxisLabel.prototype, \"format\", {\n    get: function () {\n      return this._format;\n    },\n    set: function (value) {\n      // See `TimeLocaleObject` docs for the list of supported format directives.\n      if (this._format !== value) {\n        this._format = value;\n        if (this.onFormatChange) {\n          this.onFormatChange(value);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AxisLabel;\n}();\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */function () {\n  function Axis(scale) {\n    this.lineNode = new Line();\n    this.group = new Group();\n    this.line = {\n      width: 1,\n      color: 'rgba(195, 195, 195, 1)'\n    };\n    this.tick = new AxisTick();\n    this.label = new AxisLabel();\n    this.translation = {\n      x: 0,\n      y: 0\n    };\n    this.rotation = 0; // axis rotation angle in degrees\n    this._visibleRange = [0, 1];\n    this._title = undefined;\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n     * (in degrees).\n     */\n    this._gridLength = 0;\n    /**\n     * The array of styles to cycle through when rendering grid lines.\n     * For example, use two {@link GridStyle} objects for alternating styles.\n     * Contains only one {@link GridStyle} object by default, meaning all grid lines\n     * have the same style.\n     */\n    this.gridStyle = [{\n      stroke: 'rgba(219, 219, 219, 1)',\n      lineDash: [4, 2]\n    }];\n    /**\n     * `false` - render grid as lines of {@link gridLength} that extend the ticks\n     *           on the opposite side of the axis\n     * `true` - render grid as concentric circles that go through the ticks\n     */\n    this._radialGrid = false;\n    this.scale = scale;\n    this.requestedRange = scale.range.slice();\n    this.groupSelection = Selection.select(this.group).selectAll();\n    this.label.onFormatChange = this.onTickFormatChange.bind(this);\n    this.group.append(this.lineNode);\n    this.onTickFormatChange();\n    // this.group.append(this.bboxRect); // debug (bbox)\n  }\n\n  Axis.prototype.updateRange = function () {\n    var _a = this,\n      rr = _a.requestedRange,\n      vr = _a.visibleRange,\n      scale = _a.scale;\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    scale.range = [start, start + span];\n  };\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param width Object's width.\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  Axis.prototype.inRange = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n    return this.inRangeEx(x, width, tolerance) === 0;\n  };\n  Axis.prototype.inRangeEx = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n    var range = this.range;\n    if (x + width < range[0] - tolerance) {\n      return -1; // left or range\n    }\n\n    if (x > range[1] + tolerance) {\n      return 1; // right of range\n    }\n\n    return 0; // in range\n  };\n\n  Object.defineProperty(Axis.prototype, \"range\", {\n    get: function () {\n      return this.requestedRange.slice();\n    },\n    set: function (value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"visibleRange\", {\n    get: function () {\n      return this._visibleRange.slice();\n    },\n    set: function (value) {\n      if (value && value.length === 2) {\n        var min = value[0],\n          max = value[1];\n        min = Math.max(0, min);\n        max = Math.min(1, max);\n        min = Math.min(min, max);\n        max = Math.max(min, max);\n        this._visibleRange = [min, max];\n        this.updateRange();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"domain\", {\n    get: function () {\n      return this.scale.domain.slice();\n    },\n    set: function (value) {\n      this.scale.domain = value.slice();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Axis.prototype.onTickFormatChange = function (format) {\n    if (format) {\n      if (this.scale.tickFormat) {\n        this.tickFormatter = this.scale.tickFormat(10, format);\n      }\n    } else {\n      if (this.scale.tickFormat) {\n        this.tickFormatter = this.scale.tickFormat(10, undefined);\n      } else {\n        this.tickFormatter = undefined;\n      }\n    }\n  };\n  Object.defineProperty(Axis.prototype, \"title\", {\n    get: function () {\n      return this._title;\n    },\n    set: function (value) {\n      var oldTitle = this._title;\n      if (oldTitle !== value) {\n        if (oldTitle) {\n          this.group.removeChild(oldTitle.node);\n        }\n        if (value) {\n          value.node.rotation = -Math.PI / 2;\n          this.group.appendChild(value.node);\n        }\n        this._title = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"gridLength\", {\n    get: function () {\n      return this._gridLength;\n    },\n    set: function (value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"radialGrid\", {\n    get: function () {\n      return this._radialGrid;\n    },\n    set: function (value) {\n      if (this._radialGrid !== value) {\n        this._radialGrid = value;\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  Axis.prototype.update = function () {\n    var _this = this;\n    var _a = this,\n      group = _a.group,\n      scale = _a.scale,\n      tick = _a.tick,\n      label = _a.label,\n      gridStyle = _a.gridStyle,\n      requestedRange = _a.requestedRange;\n    var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n    var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n    var rotation = toRadians(this.rotation);\n    var parallelLabels = label.parallel;\n    var labelRotation = normalizeAngle360(toRadians(label.rotation));\n    group.translationX = this.translation.x;\n    group.translationY = this.translation.y;\n    group.rotation = rotation;\n    var halfBandwidth = (scale.bandwidth || 0) / 2;\n    // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n    var sideFlag = label.mirrored ? 1 : -1;\n    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    // Flip if the axis rotation angle is in the top hemisphere.\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n    var ticks = scale.ticks(this.tick.count);\n    var update = this.groupSelection.setData(ticks);\n    update.exit.remove();\n    var enter = update.enter.append(Group);\n    // Line auto-snaps to pixel grid if vertical or horizontal.\n    enter.append(Line).each(function (node) {\n      return node.tag = Tags.Tick;\n    });\n    if (this.gridLength) {\n      if (this.radialGrid) {\n        enter.append(Arc).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      } else {\n        enter.append(Line).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      }\n    }\n    enter.append(Text);\n    var groupSelection = update.merge(enter);\n    groupSelection.attrFn('translationY', function (_, datum) {\n      return Math.round(scale.convert(datum) + halfBandwidth);\n    }).attrFn('visible', function (node) {\n      return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n    });\n    groupSelection.selectByTag(Tags.Tick).each(function (line) {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.color;\n    }).attr('x1', sideFlag * tick.size).attr('x2', 0).attr('y1', 0).attr('y2', 0);\n    if (this.gridLength && gridStyle.length) {\n      var styleCount_1 = gridStyle.length;\n      var gridLines = void 0;\n      if (this.radialGrid) {\n        var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (arc, datum) {\n          var radius = Math.round(scale.convert(datum) + halfBandwidth);\n          arc.centerX = 0;\n          arc.centerY = scale.range[0] - radius;\n          arc.endAngle = angularGridLength_1;\n          arc.radiusX = radius;\n          arc.radiusY = radius;\n        });\n      } else {\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (line) {\n          line.x1 = 0;\n          line.x2 = -sideFlag * _this.gridLength;\n          line.y1 = 0;\n          line.y2 = 0;\n          line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n        });\n      }\n      gridLines.each(function (gridLine, _, index) {\n        var style = gridStyle[index % styleCount_1];\n        gridLine.stroke = style.stroke;\n        gridLine.strokeWidth = tick.width;\n        gridLine.lineDash = style.lineDash;\n        gridLine.fill = undefined;\n      });\n    }\n    var tickFormatter = this.tickFormatter;\n    // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n    var fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n    var labelSelection = groupSelection.selectByClass(Text).each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelLabels && !labelRotation ? sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom' : 'middle';\n      node.text = label.formatter ? label.formatter({\n        value: fractionDigits >= 0 ? datum : String(datum),\n        index: index,\n        fractionDigits: fractionDigits,\n        formatter: tickFormatter\n      }) : fractionDigits\n      // the `datum` is a floating point number\n      ? datum.toFixed(fractionDigits)\n      // the `datum` is an integer, a string or an object\n      : tickFormatter ? tickFormatter(datum) : String(datum);\n      node.textAlign = parallelLabels ? labelRotation ? sideFlag * alignFlag === -1 ? 'end' : 'start' : 'center' : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n    });\n    var labelX = sideFlag * (tick.size + label.padding);\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    labelSelection.each(function (label) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n      label.rotation = autoRotation + labelRotation;\n    });\n    this.groupSelection = groupSelection;\n    // Render axis line.\n    var lineNode = this.lineNode;\n    lineNode.x1 = 0;\n    lineNode.x2 = 0;\n    lineNode.y1 = requestedRange[0];\n    lineNode.y2 = requestedRange[1];\n    lineNode.strokeWidth = this.line.width;\n    lineNode.stroke = this.line.color;\n    lineNode.visible = ticks.length > 0;\n    var title = this.title;\n    var titleVisible = false;\n    if (title && title.enabled) {\n      titleVisible = true;\n      var padding = title.padding.bottom;\n      var titleNode = title.node;\n      var bbox = this.computeBBox({\n        excludeTitle: true\n      });\n      var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n      titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n      titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n      titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n      if (sideFlag === -1) {\n        titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n      } else {\n        titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n      }\n      // title.text = `Axis Title: ${sideFlag} ${toDegrees(parallelFlipRotation).toFixed(0)} ${titleRotationFlag}`;\n      titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n    }\n    if (title) {\n      title.node.visible = titleVisible;\n    }\n    // debug (bbox)\n    // const bbox = this.computeBBox();\n    // const bboxRect = this.bboxRect;\n    // bboxRect.x = bbox.x;\n    // bboxRect.y = bbox.y;\n    // bboxRect.width = bbox.width;\n    // bboxRect.height = bbox.height;\n  };\n\n  Axis.prototype.computeBBox = function (options) {\n    var _a = this,\n      title = _a.title,\n      lineNode = _a.lineNode;\n    var labels = this.groupSelection.selectByClass(Text);\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    labels.each(function (label) {\n      // The label itself is rotated, but not translated, the group that\n      // contains it is. So to capture the group transform in the label bbox\n      // calculation we combine the transform matrices of the label and the group.\n      // Depending on the timing of the `axis.computeBBox()` method call, we may\n      // not have the group's and the label's transform matrices updated yet (because\n      // the transform matrix is not recalculated whenever a node's transform attributes\n      // change, instead it's marked for recalculation on the next frame by setting\n      // the node's `dirtyTransform` flag to `true`), so we force them to update\n      // right here by calling `computeTransformMatrix`.\n      label.computeTransformMatrix();\n      var matrix = Matrix.flyweight(label.matrix);\n      var group = label.parent;\n      group.computeTransformMatrix();\n      matrix.preMultiplySelf(group.matrix);\n      var labelBBox = label.computeBBox();\n      if (labelBBox) {\n        var bbox = matrix.transformBBox(labelBBox);\n        left = Math.min(left, bbox.x);\n        right = Math.max(right, bbox.x + bbox.width);\n        top = Math.min(top, bbox.y);\n        bottom = Math.max(bottom, bbox.y + bbox.height);\n      }\n    });\n    if (title && title.enabled && (!options || !options.excludeTitle)) {\n      var label = title.node;\n      label.computeTransformMatrix();\n      var matrix = Matrix.flyweight(label.matrix);\n      var labelBBox = label.computeBBox();\n      if (labelBBox) {\n        var bbox = matrix.transformBBox(labelBBox);\n        left = Math.min(left, bbox.x);\n        right = Math.max(right, bbox.x + bbox.width);\n        top = Math.min(top, bbox.y);\n        bottom = Math.max(bottom, bbox.y + bbox.height);\n      }\n    }\n    left = Math.min(left, 0);\n    right = Math.max(right, 0);\n    top = Math.min(top, lineNode.y1, lineNode.y2);\n    bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n    return new BBox(left, top, right - left, bottom - top);\n  };\n  return Axis;\n}();\nexport { Axis };","map":{"version":3,"names":["Group","Selection","Line","normalizeAngle360","normalizeAngle360Inclusive","toRadians","Text","Arc","BBox","Matrix","Tags","AxisTick","width","size","color","count","AxisLabel","fontSize","fontFamily","padding","rotation","mirrored","parallel","Object","defineProperty","prototype","get","_format","set","value","onFormatChange","enumerable","configurable","Axis","scale","lineNode","group","line","tick","label","translation","x","y","_visibleRange","_title","undefined","_gridLength","gridStyle","stroke","lineDash","_radialGrid","requestedRange","range","slice","groupSelection","select","selectAll","onTickFormatChange","bind","append","updateRange","_a","rr","vr","visibleRange","span","shift","start","inRange","tolerance","inRangeEx","length","min","max","Math","domain","format","tickFormat","tickFormatter","oldTitle","removeChild","node","PI","appendChild","remove","setData","update","_this","requestedRangeMin","requestedRangeMax","parallelLabels","labelRotation","translationX","translationY","halfBandwidth","bandwidth","sideFlag","parallelFlipRotation","parallelFlipFlag","regularFlipRotation","regularFlipFlag","alignFlag","ticks","exit","enter","each","tag","Tick","gridLength","radialGrid","GridLine","merge","attrFn","_","datum","round","convert","selectByTag","strokeWidth","attr","styleCount_1","gridLines","angularGridLength_1","arc","radius","centerX","centerY","endAngle","radiusX","radiusY","x1","x2","y1","y2","visible","abs","parent","gridLine","index","style","fill","fractionDigits","labelSelection","selectByClass","fontStyle","fontWeight","textBaseline","text","formatter","String","toFixed","textAlign","labelX","autoRotation","rotationCenterX","title","titleVisible","enabled","bottom","titleNode","bbox","computeBBox","excludeTitle","titleRotationFlag","options","labels","left","Infinity","right","top","computeTransformMatrix","matrix","flyweight","preMultiplySelf","labelBBox","transformBBox","height"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/axis.js"],"sourcesContent":["import { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\";\nimport { Text } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\";\n// import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\nvar Tags;\n(function (Tags) {\n    Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n    Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisTick = /** @class */ (function () {\n    function AxisTick() {\n        /**\n         * The line width to be used by axis ticks.\n         */\n        this.width = 1;\n        /**\n         * The line length to be used by axis ticks.\n         */\n        this.size = 6;\n        /**\n         * The color of the axis ticks.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n         */\n        this.color = 'rgba(195, 195, 195, 1)';\n        /**\n         * A hint of how many ticks to use (the exact number of ticks might differ),\n         * a `TimeInterval` or a `CountableTimeInterval`.\n         * For example:\n         *\n         *     axis.tick.count = 5;\n         *     axis.tick.count = year;\n         *     axis.tick.count = month.every(6);\n         */\n        this.count = 10;\n    }\n    return AxisTick;\n}());\nexport { AxisTick };\nvar AxisLabel = /** @class */ (function () {\n    function AxisLabel() {\n        this.fontSize = 12;\n        this.fontFamily = 'Verdana, sans-serif';\n        /**\n         * The padding between the labels and the ticks.\n         */\n        this.padding = 5;\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        this.color = 'rgba(87, 87, 87, 1)';\n        /**\n         * Custom label rotation in degrees.\n         * Labels are rendered perpendicular to the axis line by default.\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n         * The value of this config is used as the angular offset/deflection\n         * from the default rotation.\n         */\n        this.rotation = 0;\n        /**\n         * By default labels and ticks are positioned to the left of the axis line.\n         * `true` positions the labels to the right of the axis line.\n         * However, if the axis is rotated, its easier to think in terms\n         * of this side or the opposite side, rather than left and right.\n         * We use the term `mirror` for conciseness, although it's not\n         * true mirroring - for example, when a label is rotated, so that\n         * it is inclined at the 45 degree angle, text flowing from north-west\n         * to south-east, ending at the tick to the left of the axis line,\n         * and then we set this config to `true`, the text will still be flowing\n         * from north-west to south-east, _starting_ at the tick to the right\n         * of the axis line.\n         */\n        this.mirrored = false;\n        /**\n         * Labels are rendered perpendicular to the axis line by default.\n         * Setting this config to `true` makes labels render parallel to the axis line\n         * and center aligns labels' text at the ticks.\n         */\n        this.parallel = false;\n    }\n    Object.defineProperty(AxisLabel.prototype, \"format\", {\n        get: function () {\n            return this._format;\n        },\n        set: function (value) {\n            // See `TimeLocaleObject` docs for the list of supported format directives.\n            if (this._format !== value) {\n                this._format = value;\n                if (this.onFormatChange) {\n                    this.onFormatChange(value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AxisLabel;\n}());\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */ (function () {\n    function Axis(scale) {\n        this.lineNode = new Line();\n        this.group = new Group();\n        this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        this.tick = new AxisTick();\n        this.label = new AxisLabel();\n        this.translation = { x: 0, y: 0 };\n        this.rotation = 0; // axis rotation angle in degrees\n        this._visibleRange = [0, 1];\n        this._title = undefined;\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n         * (in degrees).\n         */\n        this._gridLength = 0;\n        /**\n         * The array of styles to cycle through when rendering grid lines.\n         * For example, use two {@link GridStyle} objects for alternating styles.\n         * Contains only one {@link GridStyle} object by default, meaning all grid lines\n         * have the same style.\n         */\n        this.gridStyle = [{\n                stroke: 'rgba(219, 219, 219, 1)',\n                lineDash: [4, 2]\n            }];\n        /**\n         * `false` - render grid as lines of {@link gridLength} that extend the ticks\n         *           on the opposite side of the axis\n         * `true` - render grid as concentric circles that go through the ticks\n         */\n        this._radialGrid = false;\n        this.scale = scale;\n        this.requestedRange = scale.range.slice();\n        this.groupSelection = Selection.select(this.group).selectAll();\n        this.label.onFormatChange = this.onTickFormatChange.bind(this);\n        this.group.append(this.lineNode);\n        this.onTickFormatChange();\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Axis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        scale.range = [start, start + span];\n    };\n    /**\n     * Checks if a point or an object is in range.\n     * @param x A point (or object's starting point).\n     * @param width Object's width.\n     * @param tolerance Expands the range on both ends by this amount.\n     */\n    Axis.prototype.inRange = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        return this.inRangeEx(x, width, tolerance) === 0;\n    };\n    Axis.prototype.inRangeEx = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        var range = this.range;\n        if ((x + width) < (range[0] - tolerance)) {\n            return -1; // left or range\n        }\n        if (x > (range[1] + tolerance)) {\n            return 1; // right of range\n        }\n        return 0; // in range\n    };\n    Object.defineProperty(Axis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"visibleRange\", {\n        get: function () {\n            return this._visibleRange.slice();\n        },\n        set: function (value) {\n            if (value && value.length === 2) {\n                var min = value[0], max = value[1];\n                min = Math.max(0, min);\n                max = Math.min(1, max);\n                min = Math.min(min, max);\n                max = Math.max(min, max);\n                this._visibleRange = [min, max];\n                this.updateRange();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain.slice();\n        },\n        set: function (value) {\n            this.scale.domain = value.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Axis.prototype.onTickFormatChange = function (format) {\n        if (format) {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, format);\n            }\n        }\n        else {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, undefined);\n            }\n            else {\n                this.tickFormatter = undefined;\n            }\n        }\n    };\n    Object.defineProperty(Axis.prototype, \"title\", {\n        get: function () {\n            return this._title;\n        },\n        set: function (value) {\n            var oldTitle = this._title;\n            if (oldTitle !== value) {\n                if (oldTitle) {\n                    this.group.removeChild(oldTitle.node);\n                }\n                if (value) {\n                    value.node.rotation = -Math.PI / 2;\n                    this.group.appendChild(value.node);\n                }\n                this._title = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"radialGrid\", {\n        get: function () {\n            return this._radialGrid;\n        },\n        set: function (value) {\n            if (this._radialGrid !== value) {\n                this._radialGrid = value;\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    Axis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, tick = _a.tick, label = _a.label, gridStyle = _a.gridStyle, requestedRange = _a.requestedRange;\n        var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n        var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n        var rotation = toRadians(this.rotation);\n        var parallelLabels = label.parallel;\n        var labelRotation = normalizeAngle360(toRadians(label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var halfBandwidth = (scale.bandwidth || 0) / 2;\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, π] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n        var ticks = scale.ticks(this.tick.count);\n        var update = this.groupSelection.setData(ticks);\n        update.exit.remove();\n        var enter = update.enter.append(Group);\n        // Line auto-snaps to pixel grid if vertical or horizontal.\n        enter.append(Line).each(function (node) { return node.tag = Tags.Tick; });\n        if (this.gridLength) {\n            if (this.radialGrid) {\n                enter.append(Arc).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n            else {\n                enter.append(Line).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n        }\n        enter.append(Text);\n        var groupSelection = update.merge(enter);\n        groupSelection\n            .attrFn('translationY', function (_, datum) {\n            return Math.round(scale.convert(datum) + halfBandwidth);\n        })\n            .attrFn('visible', function (node) {\n            return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n        });\n        groupSelection.selectByTag(Tags.Tick)\n            .each(function (line) {\n            line.strokeWidth = tick.width;\n            line.stroke = tick.color;\n        })\n            .attr('x1', sideFlag * tick.size)\n            .attr('x2', 0)\n            .attr('y1', 0)\n            .attr('y2', 0);\n        if (this.gridLength && gridStyle.length) {\n            var styleCount_1 = gridStyle.length;\n            var gridLines = void 0;\n            if (this.radialGrid) {\n                var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (arc, datum) {\n                    var radius = Math.round(scale.convert(datum) + halfBandwidth);\n                    arc.centerX = 0;\n                    arc.centerY = scale.range[0] - radius;\n                    arc.endAngle = angularGridLength_1;\n                    arc.radiusX = radius;\n                    arc.radiusY = radius;\n                });\n            }\n            else {\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (line) {\n                    line.x1 = 0;\n                    line.x2 = -sideFlag * _this.gridLength;\n                    line.y1 = 0;\n                    line.y2 = 0;\n                    line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n                });\n            }\n            gridLines.each(function (gridLine, _, index) {\n                var style = gridStyle[index % styleCount_1];\n                gridLine.stroke = style.stroke;\n                gridLine.strokeWidth = tick.width;\n                gridLine.lineDash = style.lineDash;\n                gridLine.fill = undefined;\n            });\n        }\n        var tickFormatter = this.tickFormatter;\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n        var fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n        var labelSelection = groupSelection.selectByClass(Text)\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelLabels && !labelRotation\n                ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n                : 'middle';\n            node.text = label.formatter\n                ? label.formatter({\n                    value: fractionDigits >= 0 ? datum : String(datum),\n                    index: index,\n                    fractionDigits: fractionDigits,\n                    formatter: tickFormatter\n                })\n                : fractionDigits\n                    // the `datum` is a floating point number\n                    ? datum.toFixed(fractionDigits)\n                    // the `datum` is an integer, a string or an object\n                    : tickFormatter\n                        ? tickFormatter(datum)\n                        : String(datum);\n            node.textAlign = parallelLabels\n                ? labelRotation ? (sideFlag * alignFlag === -1 ? 'end' : 'start') : 'center'\n                : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n        });\n        var labelX = sideFlag * (tick.size + label.padding);\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        labelSelection.each(function (label) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            label.rotation = autoRotation + labelRotation;\n        });\n        this.groupSelection = groupSelection;\n        // Render axis line.\n        var lineNode = this.lineNode;\n        lineNode.x1 = 0;\n        lineNode.x2 = 0;\n        lineNode.y1 = requestedRange[0];\n        lineNode.y2 = requestedRange[1];\n        lineNode.strokeWidth = this.line.width;\n        lineNode.stroke = this.line.color;\n        lineNode.visible = ticks.length > 0;\n        var title = this.title;\n        var titleVisible = false;\n        if (title && title.enabled) {\n            titleVisible = true;\n            var padding = title.padding.bottom;\n            var titleNode = title.node;\n            var bbox = this.computeBBox({ excludeTitle: true });\n            var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n            titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n            if (sideFlag === -1) {\n                titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n            }\n            else {\n                titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n            }\n            // title.text = `Axis Title: ${sideFlag} ${toDegrees(parallelFlipRotation).toFixed(0)} ${titleRotationFlag}`;\n            titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n        }\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    Axis.prototype.computeBBox = function (options) {\n        var _a = this, title = _a.title, lineNode = _a.lineNode;\n        var labels = this.groupSelection.selectByClass(Text);\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        labels.each(function (label) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var group = label.parent;\n            group.computeTransformMatrix();\n            matrix.preMultiplySelf(group.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        });\n        if (title && title.enabled && (!options || !options.excludeTitle)) {\n            var label = title.node;\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        }\n        left = Math.min(left, 0);\n        right = Math.max(right, 0);\n        top = Math.min(top, lineNode.y1, lineNode.y2);\n        bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    return Axis;\n}());\nexport { Axis };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}