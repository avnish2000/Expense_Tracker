{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar t0 = new Date();\nvar t1 = new Date();\n/**\n * The interval methods don't mutate Date parameters.\n */\nvar TimeInterval = /** @class */function () {\n  function TimeInterval(floor, offset) {\n    this._floor = floor;\n    this._offset = offset;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  TimeInterval.prototype.floor = function (date) {\n    date = new Date(+date);\n    this._floor(date);\n    return date;\n  };\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  TimeInterval.prototype.ceil = function (date) {\n    date = new Date(+date - 1);\n    this._floor(date);\n    this._offset(date, 1);\n    this._floor(date);\n    return date;\n  };\n  /**\n   * Returns a new date representing the closest interval boundary date to date.\n   * @param date\n   */\n  TimeInterval.prototype.round = function (date) {\n    var d0 = this.floor(date);\n    var d1 = this.ceil(date);\n    var ms = +date;\n    return ms - d0.getTime() < d1.getTime() - ms ? d0 : d1;\n  };\n  /**\n   * Returns a new date equal to date plus step intervals.\n   * @param date\n   * @param step\n   */\n  TimeInterval.prototype.offset = function (date, step) {\n    if (step === void 0) {\n      step = 1;\n    }\n    date = new Date(+date);\n    this._offset(date, Math.floor(step));\n    return date;\n  };\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start\n   * @param stop\n   * @param step\n   */\n  TimeInterval.prototype.range = function (start, stop, step) {\n    if (step === void 0) {\n      step = 1;\n    }\n    var range = [];\n    start = this.ceil(start);\n    step = Math.floor(step);\n    if (start > stop || step <= 0) {\n      return range;\n    }\n    var previous;\n    do {\n      previous = new Date(+start);\n      range.push(previous);\n      this._offset(start, step);\n      this._floor(start);\n    } while (previous < start && start < stop);\n    return range;\n  };\n  // Returns an interval that is a subset of this interval.\n  // For example, to create an interval that return 1st, 11th, 21st and 31st of each month:\n  // day.filter(date => (date.getDate() - 1) % 10 === 0)\n  TimeInterval.prototype.filter = function (test) {\n    var _this = this;\n    var floor = function (date) {\n      if (date >= date) {\n        while (_this._floor(date), !test(date)) {\n          date.setTime(date.getTime() - 1);\n        }\n      }\n      return date;\n    };\n    var offset = function (date, step) {\n      if (date >= date) {\n        if (step < 0) {\n          while (++step <= 0) {\n            do {\n              _this._offset(date, -1);\n            } while (!test(date));\n          }\n        } else {\n          while (--step >= 0) {\n            do {\n              _this._offset(date, 1);\n            } while (!test(date));\n          }\n        }\n      }\n      return date;\n    };\n    return new TimeInterval(floor, offset);\n  };\n  return TimeInterval;\n}();\nexport { TimeInterval };\nvar CountableTimeInterval = /** @class */function (_super) {\n  __extends(CountableTimeInterval, _super);\n  function CountableTimeInterval(floor, offset, count, field) {\n    var _this = _super.call(this, floor, offset) || this;\n    _this._count = count;\n    _this._field = field;\n    return _this;\n  }\n  /**\n   * Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive).\n   * @param start\n   * @param end\n   */\n  CountableTimeInterval.prototype.count = function (start, end) {\n    t0.setTime(+start);\n    t1.setTime(+end);\n    this._floor(t0);\n    this._floor(t1);\n    return Math.floor(this._count(t0, t1));\n  };\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * The meaning of step is dependent on this interval’s parent interval as defined by the `field` function.\n   * @param step\n   */\n  CountableTimeInterval.prototype.every = function (step) {\n    var _this = this;\n    var result;\n    step = Math.floor(step);\n    if (isFinite(step) && step > 0) {\n      if (step > 1) {\n        var field_1 = this._field;\n        if (field_1) {\n          result = this.filter(function (d) {\n            return field_1(d) % step === 0;\n          });\n        } else {\n          result = this.filter(function (d) {\n            return _this.count(0, d) % step === 0;\n          });\n        }\n      } else {\n        result = this;\n      }\n    }\n    return result;\n  };\n  return CountableTimeInterval;\n}(TimeInterval);\nexport { CountableTimeInterval };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","t0","Date","t1","TimeInterval","floor","offset","_floor","_offset","date","ceil","round","d0","d1","ms","getTime","step","Math","range","start","stop","previous","push","filter","test","_this","setTime","CountableTimeInterval","_super","count","field","call","_count","_field","end","every","result","isFinite","field_1"],"sources":["C:/Users/avnis/Documents/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/util/time/interval.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar t0 = new Date;\nvar t1 = new Date;\n/**\n * The interval methods don't mutate Date parameters.\n */\nvar TimeInterval = /** @class */ (function () {\n    function TimeInterval(floor, offset) {\n        this._floor = floor;\n        this._offset = offset;\n    }\n    /**\n     * Returns a new date representing the latest interval boundary date before or equal to date.\n     * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n     * @param date\n     */\n    TimeInterval.prototype.floor = function (date) {\n        date = new Date(+date);\n        this._floor(date);\n        return date;\n    };\n    /**\n     * Returns a new date representing the earliest interval boundary date after or equal to date.\n     * @param date\n     */\n    TimeInterval.prototype.ceil = function (date) {\n        date = new Date(+date - 1);\n        this._floor(date);\n        this._offset(date, 1);\n        this._floor(date);\n        return date;\n    };\n    /**\n     * Returns a new date representing the closest interval boundary date to date.\n     * @param date\n     */\n    TimeInterval.prototype.round = function (date) {\n        var d0 = this.floor(date);\n        var d1 = this.ceil(date);\n        var ms = +date;\n        return ms - d0.getTime() < d1.getTime() - ms ? d0 : d1;\n    };\n    /**\n     * Returns a new date equal to date plus step intervals.\n     * @param date\n     * @param step\n     */\n    TimeInterval.prototype.offset = function (date, step) {\n        if (step === void 0) { step = 1; }\n        date = new Date(+date);\n        this._offset(date, Math.floor(step));\n        return date;\n    };\n    /**\n     * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n     * @param start\n     * @param stop\n     * @param step\n     */\n    TimeInterval.prototype.range = function (start, stop, step) {\n        if (step === void 0) { step = 1; }\n        var range = [];\n        start = this.ceil(start);\n        step = Math.floor(step);\n        if (start > stop || step <= 0) {\n            return range;\n        }\n        var previous;\n        do {\n            previous = new Date(+start);\n            range.push(previous);\n            this._offset(start, step);\n            this._floor(start);\n        } while (previous < start && start < stop);\n        return range;\n    };\n    // Returns an interval that is a subset of this interval.\n    // For example, to create an interval that return 1st, 11th, 21st and 31st of each month:\n    // day.filter(date => (date.getDate() - 1) % 10 === 0)\n    TimeInterval.prototype.filter = function (test) {\n        var _this = this;\n        var floor = function (date) {\n            if (date >= date) {\n                while (_this._floor(date), !test(date)) {\n                    date.setTime(date.getTime() - 1);\n                }\n            }\n            return date;\n        };\n        var offset = function (date, step) {\n            if (date >= date) {\n                if (step < 0) {\n                    while (++step <= 0) {\n                        do {\n                            _this._offset(date, -1);\n                        } while (!test(date));\n                    }\n                }\n                else {\n                    while (--step >= 0) {\n                        do {\n                            _this._offset(date, 1);\n                        } while (!test(date));\n                    }\n                }\n            }\n            return date;\n        };\n        return new TimeInterval(floor, offset);\n    };\n    return TimeInterval;\n}());\nexport { TimeInterval };\nvar CountableTimeInterval = /** @class */ (function (_super) {\n    __extends(CountableTimeInterval, _super);\n    function CountableTimeInterval(floor, offset, count, field) {\n        var _this = _super.call(this, floor, offset) || this;\n        _this._count = count;\n        _this._field = field;\n        return _this;\n    }\n    /**\n     * Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive).\n     * @param start\n     * @param end\n     */\n    CountableTimeInterval.prototype.count = function (start, end) {\n        t0.setTime(+start);\n        t1.setTime(+end);\n        this._floor(t0);\n        this._floor(t1);\n        return Math.floor(this._count(t0, t1));\n    };\n    /**\n     * Returns a filtered view of this interval representing every step'th date.\n     * The meaning of step is dependent on this interval’s parent interval as defined by the `field` function.\n     * @param step\n     */\n    CountableTimeInterval.prototype.every = function (step) {\n        var _this = this;\n        var result;\n        step = Math.floor(step);\n        if (isFinite(step) && step > 0) {\n            if (step > 1) {\n                var field_1 = this._field;\n                if (field_1) {\n                    result = this.filter(function (d) { return field_1(d) % step === 0; });\n                }\n                else {\n                    result = this.filter(function (d) { return _this.count(0, d) % step === 0; });\n                }\n            }\n            else {\n                result = this;\n            }\n        }\n        return result;\n    };\n    return CountableTimeInterval;\n}(TimeInterval));\nexport { CountableTimeInterval };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}