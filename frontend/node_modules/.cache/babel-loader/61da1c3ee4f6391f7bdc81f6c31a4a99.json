{"ast":null,"code":"import { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\";\nimport { Text } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\"; // import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\n\nvar Tags;\n\n(function (Tags) {\n  Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n  Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\n\nvar AxisTick =\n/** @class */\nfunction () {\n  function AxisTick() {\n    /**\n     * The line width to be used by axis ticks.\n     */\n    this.width = 1;\n    /**\n     * The line length to be used by axis ticks.\n     */\n\n    this.size = 6;\n    /**\n     * The color of the axis ticks.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n     */\n\n    this.color = 'rgba(195, 195, 195, 1)';\n    /**\n     * A hint of how many ticks to use (the exact number of ticks might differ),\n     * a `TimeInterval` or a `CountableTimeInterval`.\n     * For example:\n     *\n     *     axis.tick.count = 5;\n     *     axis.tick.count = year;\n     *     axis.tick.count = month.every(6);\n     */\n\n    this.count = 10;\n  }\n\n  return AxisTick;\n}();\n\nexport { AxisTick };\n\nvar AxisLabel =\n/** @class */\nfunction () {\n  function AxisLabel() {\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\n     * The padding between the labels and the ticks.\n     */\n\n    this.padding = 5;\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n\n    this.color = 'rgba(87, 87, 87, 1)';\n    /**\n     * Custom label rotation in degrees.\n     * Labels are rendered perpendicular to the axis line by default.\n     * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n     * The value of this config is used as the angular offset/deflection\n     * from the default rotation.\n     */\n\n    this.rotation = 0;\n    /**\n     * By default labels and ticks are positioned to the left of the axis line.\n     * `true` positions the labels to the right of the axis line.\n     * However, if the axis is rotated, its easier to think in terms\n     * of this side or the opposite side, rather than left and right.\n     * We use the term `mirror` for conciseness, although it's not\n     * true mirroring - for example, when a label is rotated, so that\n     * it is inclined at the 45 degree angle, text flowing from north-west\n     * to south-east, ending at the tick to the left of the axis line,\n     * and then we set this config to `true`, the text will still be flowing\n     * from north-west to south-east, _starting_ at the tick to the right\n     * of the axis line.\n     */\n\n    this.mirrored = false;\n    /**\n     * Labels are rendered perpendicular to the axis line by default.\n     * Setting this config to `true` makes labels render parallel to the axis line\n     * and center aligns labels' text at the ticks.\n     */\n\n    this.parallel = false;\n  }\n\n  Object.defineProperty(AxisLabel.prototype, \"format\", {\n    get: function () {\n      return this._format;\n    },\n    set: function (value) {\n      // See `TimeLocaleObject` docs for the list of supported format directives.\n      if (this._format !== value) {\n        this._format = value;\n\n        if (this.onFormatChange) {\n          this.onFormatChange(value);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AxisLabel;\n}();\n\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\n\nvar Axis =\n/** @class */\nfunction () {\n  function Axis(scale) {\n    this.lineNode = new Line();\n    this.group = new Group();\n    this.line = {\n      width: 1,\n      color: 'rgba(195, 195, 195, 1)'\n    };\n    this.tick = new AxisTick();\n    this.label = new AxisLabel();\n    this.translation = {\n      x: 0,\n      y: 0\n    };\n    this.rotation = 0; // axis rotation angle in degrees\n\n    this._visibleRange = [0, 1];\n    this._title = undefined;\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n     * (in degrees).\n     */\n\n    this._gridLength = 0;\n    /**\n     * The array of styles to cycle through when rendering grid lines.\n     * For example, use two {@link GridStyle} objects for alternating styles.\n     * Contains only one {@link GridStyle} object by default, meaning all grid lines\n     * have the same style.\n     */\n\n    this.gridStyle = [{\n      stroke: 'rgba(219, 219, 219, 1)',\n      lineDash: [4, 2]\n    }];\n    /**\n     * `false` - render grid as lines of {@link gridLength} that extend the ticks\n     *           on the opposite side of the axis\n     * `true` - render grid as concentric circles that go through the ticks\n     */\n\n    this._radialGrid = false;\n    this.scale = scale;\n    this.requestedRange = scale.range.slice();\n    this.groupSelection = Selection.select(this.group).selectAll();\n    this.label.onFormatChange = this.onTickFormatChange.bind(this);\n    this.group.append(this.lineNode);\n    this.onTickFormatChange(); // this.group.append(this.bboxRect); // debug (bbox)\n  }\n\n  Axis.prototype.updateRange = function () {\n    var _a = this,\n        rr = _a.requestedRange,\n        vr = _a.visibleRange,\n        scale = _a.scale;\n\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    scale.range = [start, start + span];\n  };\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param width Object's width.\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n\n\n  Axis.prototype.inRange = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n\n    return this.inRangeEx(x, width, tolerance) === 0;\n  };\n\n  Axis.prototype.inRangeEx = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n\n    var range = this.range;\n\n    if (x + width < range[0] - tolerance) {\n      return -1; // left or range\n    }\n\n    if (x > range[1] + tolerance) {\n      return 1; // right of range\n    }\n\n    return 0; // in range\n  };\n\n  Object.defineProperty(Axis.prototype, \"range\", {\n    get: function () {\n      return this.requestedRange.slice();\n    },\n    set: function (value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"visibleRange\", {\n    get: function () {\n      return this._visibleRange.slice();\n    },\n    set: function (value) {\n      if (value && value.length === 2) {\n        var min = value[0],\n            max = value[1];\n        min = Math.max(0, min);\n        max = Math.min(1, max);\n        min = Math.min(min, max);\n        max = Math.max(min, max);\n        this._visibleRange = [min, max];\n        this.updateRange();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"domain\", {\n    get: function () {\n      return this.scale.domain.slice();\n    },\n    set: function (value) {\n      this.scale.domain = value.slice();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Axis.prototype.onTickFormatChange = function (format) {\n    if (format) {\n      if (this.scale.tickFormat) {\n        this.tickFormatter = this.scale.tickFormat(10, format);\n      }\n    } else {\n      if (this.scale.tickFormat) {\n        this.tickFormatter = this.scale.tickFormat(10, undefined);\n      } else {\n        this.tickFormatter = undefined;\n      }\n    }\n  };\n\n  Object.defineProperty(Axis.prototype, \"title\", {\n    get: function () {\n      return this._title;\n    },\n    set: function (value) {\n      var oldTitle = this._title;\n\n      if (oldTitle !== value) {\n        if (oldTitle) {\n          this.group.removeChild(oldTitle.node);\n        }\n\n        if (value) {\n          value.node.rotation = -Math.PI / 2;\n          this.group.appendChild(value.node);\n        }\n\n        this._title = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"gridLength\", {\n    get: function () {\n      return this._gridLength;\n    },\n    set: function (value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"radialGrid\", {\n    get: function () {\n      return this._radialGrid;\n    },\n    set: function (value) {\n      if (this._radialGrid !== value) {\n        this._radialGrid = value;\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n\n  Axis.prototype.update = function () {\n    var _this = this;\n\n    var _a = this,\n        group = _a.group,\n        scale = _a.scale,\n        tick = _a.tick,\n        label = _a.label,\n        gridStyle = _a.gridStyle,\n        requestedRange = _a.requestedRange;\n\n    var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n    var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n    var rotation = toRadians(this.rotation);\n    var parallelLabels = label.parallel;\n    var labelRotation = normalizeAngle360(toRadians(label.rotation));\n    group.translationX = this.translation.x;\n    group.translationY = this.translation.y;\n    group.rotation = rotation;\n    var halfBandwidth = (scale.bandwidth || 0) / 2; // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n\n    var sideFlag = label.mirrored ? 1 : -1; // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2); // Flip if the axis rotation angle is in the top hemisphere.\n\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n    var ticks = scale.ticks(this.tick.count);\n    var update = this.groupSelection.setData(ticks);\n    update.exit.remove();\n    var enter = update.enter.append(Group); // Line auto-snaps to pixel grid if vertical or horizontal.\n\n    enter.append(Line).each(function (node) {\n      return node.tag = Tags.Tick;\n    });\n\n    if (this.gridLength) {\n      if (this.radialGrid) {\n        enter.append(Arc).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      } else {\n        enter.append(Line).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      }\n    }\n\n    enter.append(Text);\n    var groupSelection = update.merge(enter);\n    groupSelection.attrFn('translationY', function (_, datum) {\n      return Math.round(scale.convert(datum) + halfBandwidth);\n    }).attrFn('visible', function (node) {\n      return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n    });\n    groupSelection.selectByTag(Tags.Tick).each(function (line) {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.color;\n    }).attr('x1', sideFlag * tick.size).attr('x2', 0).attr('y1', 0).attr('y2', 0);\n\n    if (this.gridLength && gridStyle.length) {\n      var styleCount_1 = gridStyle.length;\n      var gridLines = void 0;\n\n      if (this.radialGrid) {\n        var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (arc, datum) {\n          var radius = Math.round(scale.convert(datum) + halfBandwidth);\n          arc.centerX = 0;\n          arc.centerY = scale.range[0] - radius;\n          arc.endAngle = angularGridLength_1;\n          arc.radiusX = radius;\n          arc.radiusY = radius;\n        });\n      } else {\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (line) {\n          line.x1 = 0;\n          line.x2 = -sideFlag * _this.gridLength;\n          line.y1 = 0;\n          line.y2 = 0;\n          line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n        });\n      }\n\n      gridLines.each(function (gridLine, _, index) {\n        var style = gridStyle[index % styleCount_1];\n        gridLine.stroke = style.stroke;\n        gridLine.strokeWidth = tick.width;\n        gridLine.lineDash = style.lineDash;\n        gridLine.fill = undefined;\n      });\n    }\n\n    var tickFormatter = this.tickFormatter; // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n\n    var fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n    var labelSelection = groupSelection.selectByClass(Text).each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelLabels && !labelRotation ? sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom' : 'middle';\n      node.text = label.formatter ? label.formatter({\n        value: fractionDigits >= 0 ? datum : String(datum),\n        index: index,\n        fractionDigits: fractionDigits,\n        formatter: tickFormatter\n      }) : fractionDigits // the `datum` is a floating point number\n      ? datum.toFixed(fractionDigits) // the `datum` is an integer, a string or an object\n      : tickFormatter ? tickFormatter(datum) : String(datum);\n      node.textAlign = parallelLabels ? labelRotation ? sideFlag * alignFlag === -1 ? 'end' : 'start' : 'center' : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n    });\n    var labelX = sideFlag * (tick.size + label.padding);\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    labelSelection.each(function (label) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n      label.rotation = autoRotation + labelRotation;\n    });\n    this.groupSelection = groupSelection; // Render axis line.\n\n    var lineNode = this.lineNode;\n    lineNode.x1 = 0;\n    lineNode.x2 = 0;\n    lineNode.y1 = requestedRange[0];\n    lineNode.y2 = requestedRange[1];\n    lineNode.strokeWidth = this.line.width;\n    lineNode.stroke = this.line.color;\n    lineNode.visible = ticks.length > 0;\n    var title = this.title;\n    var titleVisible = false;\n\n    if (title && title.enabled) {\n      titleVisible = true;\n      var padding = title.padding.bottom;\n      var titleNode = title.node;\n      var bbox = this.computeBBox({\n        excludeTitle: true\n      });\n      var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n      titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n      titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n      titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n\n      if (sideFlag === -1) {\n        titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n      } else {\n        titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n      } // title.text = `Axis Title: ${sideFlag} ${toDegrees(parallelFlipRotation).toFixed(0)} ${titleRotationFlag}`;\n\n\n      titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n    }\n\n    if (title) {\n      title.node.visible = titleVisible;\n    } // debug (bbox)\n    // const bbox = this.computeBBox();\n    // const bboxRect = this.bboxRect;\n    // bboxRect.x = bbox.x;\n    // bboxRect.y = bbox.y;\n    // bboxRect.width = bbox.width;\n    // bboxRect.height = bbox.height;\n\n  };\n\n  Axis.prototype.computeBBox = function (options) {\n    var _a = this,\n        title = _a.title,\n        lineNode = _a.lineNode;\n\n    var labels = this.groupSelection.selectByClass(Text);\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    labels.each(function (label) {\n      // The label itself is rotated, but not translated, the group that\n      // contains it is. So to capture the group transform in the label bbox\n      // calculation we combine the transform matrices of the label and the group.\n      // Depending on the timing of the `axis.computeBBox()` method call, we may\n      // not have the group's and the label's transform matrices updated yet (because\n      // the transform matrix is not recalculated whenever a node's transform attributes\n      // change, instead it's marked for recalculation on the next frame by setting\n      // the node's `dirtyTransform` flag to `true`), so we force them to update\n      // right here by calling `computeTransformMatrix`.\n      label.computeTransformMatrix();\n      var matrix = Matrix.flyweight(label.matrix);\n      var group = label.parent;\n      group.computeTransformMatrix();\n      matrix.preMultiplySelf(group.matrix);\n      var labelBBox = label.computeBBox();\n\n      if (labelBBox) {\n        var bbox = matrix.transformBBox(labelBBox);\n        left = Math.min(left, bbox.x);\n        right = Math.max(right, bbox.x + bbox.width);\n        top = Math.min(top, bbox.y);\n        bottom = Math.max(bottom, bbox.y + bbox.height);\n      }\n    });\n\n    if (title && title.enabled && (!options || !options.excludeTitle)) {\n      var label = title.node;\n      label.computeTransformMatrix();\n      var matrix = Matrix.flyweight(label.matrix);\n      var labelBBox = label.computeBBox();\n\n      if (labelBBox) {\n        var bbox = matrix.transformBBox(labelBBox);\n        left = Math.min(left, bbox.x);\n        right = Math.max(right, bbox.x + bbox.width);\n        top = Math.min(top, bbox.y);\n        bottom = Math.max(bottom, bbox.y + bbox.height);\n      }\n    }\n\n    left = Math.min(left, 0);\n    right = Math.max(right, 0);\n    top = Math.min(top, lineNode.y1, lineNode.y2);\n    bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n    return new BBox(left, top, right - left, bottom - top);\n  };\n\n  return Axis;\n}();\n\nexport { Axis };","map":{"version":3,"sources":["E:/Expense-Tracker/frontend/node_modules/ag-charts-community/dist/es6/axis.js"],"names":["Group","Selection","Line","normalizeAngle360","normalizeAngle360Inclusive","toRadians","Text","Arc","BBox","Matrix","Tags","AxisTick","width","size","color","count","AxisLabel","fontSize","fontFamily","padding","rotation","mirrored","parallel","Object","defineProperty","prototype","get","_format","set","value","onFormatChange","enumerable","configurable","Axis","scale","lineNode","group","line","tick","label","translation","x","y","_visibleRange","_title","undefined","_gridLength","gridStyle","stroke","lineDash","_radialGrid","requestedRange","range","slice","groupSelection","select","selectAll","onTickFormatChange","bind","append","updateRange","_a","rr","vr","visibleRange","span","shift","start","inRange","tolerance","inRangeEx","length","min","max","Math","domain","format","tickFormat","tickFormatter","oldTitle","removeChild","node","PI","appendChild","remove","setData","update","_this","requestedRangeMin","requestedRangeMax","parallelLabels","labelRotation","translationX","translationY","halfBandwidth","bandwidth","sideFlag","parallelFlipRotation","parallelFlipFlag","regularFlipRotation","regularFlipFlag","alignFlag","ticks","exit","enter","each","tag","Tick","gridLength","radialGrid","GridLine","merge","attrFn","_","datum","round","convert","selectByTag","strokeWidth","attr","styleCount_1","gridLines","angularGridLength_1","arc","radius","centerX","centerY","endAngle","radiusX","radiusY","x1","x2","y1","y2","visible","abs","parent","gridLine","index","style","fill","fractionDigits","labelSelection","selectByClass","fontStyle","fontWeight","textBaseline","text","formatter","String","toFixed","textAlign","labelX","autoRotation","rotationCenterX","title","titleVisible","enabled","bottom","titleNode","bbox","computeBBox","excludeTitle","titleRotationFlag","options","labels","left","Infinity","right","top","computeTransformMatrix","matrix","flyweight","preMultiplySelf","labelBBox","transformBBox","height"],"mappings":"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","sourcesContent":["import { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\";\nimport { Text } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\";\n// import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\nvar Tags;\n(function (Tags) {\n    Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n    Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisTick = /** @class */ (function () {\n    function AxisTick() {\n        /**\n         * The line width to be used by axis ticks.\n         */\n        this.width = 1;\n        /**\n         * The line length to be used by axis ticks.\n         */\n        this.size = 6;\n        /**\n         * The color of the axis ticks.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n         */\n        this.color = 'rgba(195, 195, 195, 1)';\n        /**\n         * A hint of how many ticks to use (the exact number of ticks might differ),\n         * a `TimeInterval` or a `CountableTimeInterval`.\n         * For example:\n         *\n         *     axis.tick.count = 5;\n         *     axis.tick.count = year;\n         *     axis.tick.count = month.every(6);\n         */\n        this.count = 10;\n    }\n    return AxisTick;\n}());\nexport { AxisTick };\nvar AxisLabel = /** @class */ (function () {\n    function AxisLabel() {\n        this.fontSize = 12;\n        this.fontFamily = 'Verdana, sans-serif';\n        /**\n         * The padding between the labels and the ticks.\n         */\n        this.padding = 5;\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        this.color = 'rgba(87, 87, 87, 1)';\n        /**\n         * Custom label rotation in degrees.\n         * Labels are rendered perpendicular to the axis line by default.\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n         * The value of this config is used as the angular offset/deflection\n         * from the default rotation.\n         */\n        this.rotation = 0;\n        /**\n         * By default labels and ticks are positioned to the left of the axis line.\n         * `true` positions the labels to the right of the axis line.\n         * However, if the axis is rotated, its easier to think in terms\n         * of this side or the opposite side, rather than left and right.\n         * We use the term `mirror` for conciseness, although it's not\n         * true mirroring - for example, when a label is rotated, so that\n         * it is inclined at the 45 degree angle, text flowing from north-west\n         * to south-east, ending at the tick to the left of the axis line,\n         * and then we set this config to `true`, the text will still be flowing\n         * from north-west to south-east, _starting_ at the tick to the right\n         * of the axis line.\n         */\n        this.mirrored = false;\n        /**\n         * Labels are rendered perpendicular to the axis line by default.\n         * Setting this config to `true` makes labels render parallel to the axis line\n         * and center aligns labels' text at the ticks.\n         */\n        this.parallel = false;\n    }\n    Object.defineProperty(AxisLabel.prototype, \"format\", {\n        get: function () {\n            return this._format;\n        },\n        set: function (value) {\n            // See `TimeLocaleObject` docs for the list of supported format directives.\n            if (this._format !== value) {\n                this._format = value;\n                if (this.onFormatChange) {\n                    this.onFormatChange(value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AxisLabel;\n}());\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */ (function () {\n    function Axis(scale) {\n        this.lineNode = new Line();\n        this.group = new Group();\n        this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        this.tick = new AxisTick();\n        this.label = new AxisLabel();\n        this.translation = { x: 0, y: 0 };\n        this.rotation = 0; // axis rotation angle in degrees\n        this._visibleRange = [0, 1];\n        this._title = undefined;\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n         * (in degrees).\n         */\n        this._gridLength = 0;\n        /**\n         * The array of styles to cycle through when rendering grid lines.\n         * For example, use two {@link GridStyle} objects for alternating styles.\n         * Contains only one {@link GridStyle} object by default, meaning all grid lines\n         * have the same style.\n         */\n        this.gridStyle = [{\n                stroke: 'rgba(219, 219, 219, 1)',\n                lineDash: [4, 2]\n            }];\n        /**\n         * `false` - render grid as lines of {@link gridLength} that extend the ticks\n         *           on the opposite side of the axis\n         * `true` - render grid as concentric circles that go through the ticks\n         */\n        this._radialGrid = false;\n        this.scale = scale;\n        this.requestedRange = scale.range.slice();\n        this.groupSelection = Selection.select(this.group).selectAll();\n        this.label.onFormatChange = this.onTickFormatChange.bind(this);\n        this.group.append(this.lineNode);\n        this.onTickFormatChange();\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Axis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        scale.range = [start, start + span];\n    };\n    /**\n     * Checks if a point or an object is in range.\n     * @param x A point (or object's starting point).\n     * @param width Object's width.\n     * @param tolerance Expands the range on both ends by this amount.\n     */\n    Axis.prototype.inRange = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        return this.inRangeEx(x, width, tolerance) === 0;\n    };\n    Axis.prototype.inRangeEx = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        var range = this.range;\n        if ((x + width) < (range[0] - tolerance)) {\n            return -1; // left or range\n        }\n        if (x > (range[1] + tolerance)) {\n            return 1; // right of range\n        }\n        return 0; // in range\n    };\n    Object.defineProperty(Axis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"visibleRange\", {\n        get: function () {\n            return this._visibleRange.slice();\n        },\n        set: function (value) {\n            if (value && value.length === 2) {\n                var min = value[0], max = value[1];\n                min = Math.max(0, min);\n                max = Math.min(1, max);\n                min = Math.min(min, max);\n                max = Math.max(min, max);\n                this._visibleRange = [min, max];\n                this.updateRange();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain.slice();\n        },\n        set: function (value) {\n            this.scale.domain = value.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Axis.prototype.onTickFormatChange = function (format) {\n        if (format) {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, format);\n            }\n        }\n        else {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, undefined);\n            }\n            else {\n                this.tickFormatter = undefined;\n            }\n        }\n    };\n    Object.defineProperty(Axis.prototype, \"title\", {\n        get: function () {\n            return this._title;\n        },\n        set: function (value) {\n            var oldTitle = this._title;\n            if (oldTitle !== value) {\n                if (oldTitle) {\n                    this.group.removeChild(oldTitle.node);\n                }\n                if (value) {\n                    value.node.rotation = -Math.PI / 2;\n                    this.group.appendChild(value.node);\n                }\n                this._title = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"radialGrid\", {\n        get: function () {\n            return this._radialGrid;\n        },\n        set: function (value) {\n            if (this._radialGrid !== value) {\n                this._radialGrid = value;\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    Axis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, tick = _a.tick, label = _a.label, gridStyle = _a.gridStyle, requestedRange = _a.requestedRange;\n        var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n        var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n        var rotation = toRadians(this.rotation);\n        var parallelLabels = label.parallel;\n        var labelRotation = normalizeAngle360(toRadians(label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var halfBandwidth = (scale.bandwidth || 0) / 2;\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, π] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n        var ticks = scale.ticks(this.tick.count);\n        var update = this.groupSelection.setData(ticks);\n        update.exit.remove();\n        var enter = update.enter.append(Group);\n        // Line auto-snaps to pixel grid if vertical or horizontal.\n        enter.append(Line).each(function (node) { return node.tag = Tags.Tick; });\n        if (this.gridLength) {\n            if (this.radialGrid) {\n                enter.append(Arc).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n            else {\n                enter.append(Line).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n        }\n        enter.append(Text);\n        var groupSelection = update.merge(enter);\n        groupSelection\n            .attrFn('translationY', function (_, datum) {\n            return Math.round(scale.convert(datum) + halfBandwidth);\n        })\n            .attrFn('visible', function (node) {\n            return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n        });\n        groupSelection.selectByTag(Tags.Tick)\n            .each(function (line) {\n            line.strokeWidth = tick.width;\n            line.stroke = tick.color;\n        })\n            .attr('x1', sideFlag * tick.size)\n            .attr('x2', 0)\n            .attr('y1', 0)\n            .attr('y2', 0);\n        if (this.gridLength && gridStyle.length) {\n            var styleCount_1 = gridStyle.length;\n            var gridLines = void 0;\n            if (this.radialGrid) {\n                var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (arc, datum) {\n                    var radius = Math.round(scale.convert(datum) + halfBandwidth);\n                    arc.centerX = 0;\n                    arc.centerY = scale.range[0] - radius;\n                    arc.endAngle = angularGridLength_1;\n                    arc.radiusX = radius;\n                    arc.radiusY = radius;\n                });\n            }\n            else {\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (line) {\n                    line.x1 = 0;\n                    line.x2 = -sideFlag * _this.gridLength;\n                    line.y1 = 0;\n                    line.y2 = 0;\n                    line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n                });\n            }\n            gridLines.each(function (gridLine, _, index) {\n                var style = gridStyle[index % styleCount_1];\n                gridLine.stroke = style.stroke;\n                gridLine.strokeWidth = tick.width;\n                gridLine.lineDash = style.lineDash;\n                gridLine.fill = undefined;\n            });\n        }\n        var tickFormatter = this.tickFormatter;\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n        var fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n        var labelSelection = groupSelection.selectByClass(Text)\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelLabels && !labelRotation\n                ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n                : 'middle';\n            node.text = label.formatter\n                ? label.formatter({\n                    value: fractionDigits >= 0 ? datum : String(datum),\n                    index: index,\n                    fractionDigits: fractionDigits,\n                    formatter: tickFormatter\n                })\n                : fractionDigits\n                    // the `datum` is a floating point number\n                    ? datum.toFixed(fractionDigits)\n                    // the `datum` is an integer, a string or an object\n                    : tickFormatter\n                        ? tickFormatter(datum)\n                        : String(datum);\n            node.textAlign = parallelLabels\n                ? labelRotation ? (sideFlag * alignFlag === -1 ? 'end' : 'start') : 'center'\n                : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n        });\n        var labelX = sideFlag * (tick.size + label.padding);\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        labelSelection.each(function (label) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            label.rotation = autoRotation + labelRotation;\n        });\n        this.groupSelection = groupSelection;\n        // Render axis line.\n        var lineNode = this.lineNode;\n        lineNode.x1 = 0;\n        lineNode.x2 = 0;\n        lineNode.y1 = requestedRange[0];\n        lineNode.y2 = requestedRange[1];\n        lineNode.strokeWidth = this.line.width;\n        lineNode.stroke = this.line.color;\n        lineNode.visible = ticks.length > 0;\n        var title = this.title;\n        var titleVisible = false;\n        if (title && title.enabled) {\n            titleVisible = true;\n            var padding = title.padding.bottom;\n            var titleNode = title.node;\n            var bbox = this.computeBBox({ excludeTitle: true });\n            var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n            titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n            if (sideFlag === -1) {\n                titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n            }\n            else {\n                titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n            }\n            // title.text = `Axis Title: ${sideFlag} ${toDegrees(parallelFlipRotation).toFixed(0)} ${titleRotationFlag}`;\n            titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n        }\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    Axis.prototype.computeBBox = function (options) {\n        var _a = this, title = _a.title, lineNode = _a.lineNode;\n        var labels = this.groupSelection.selectByClass(Text);\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        labels.each(function (label) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var group = label.parent;\n            group.computeTransformMatrix();\n            matrix.preMultiplySelf(group.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        });\n        if (title && title.enabled && (!options || !options.excludeTitle)) {\n            var label = title.node;\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        }\n        left = Math.min(left, 0);\n        right = Math.max(right, 0);\n        top = Math.min(top, lineNode.y1, lineNode.y2);\n        bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    return Axis;\n}());\nexport { Axis };\n"]},"metadata":{},"sourceType":"module"}